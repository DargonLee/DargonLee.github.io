<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dargonlee.github.io</id>
    <title>七里田间的守望者</title>
    <updated>2020-02-17T06:44:00.436Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dargonlee.github.io"/>
    <link rel="self" href="https://dargonlee.github.io/atom.xml"/>
    <subtitle>我不在乎是悲伤的离别还是不痛快的离别，只要是离开一个地方，我总希望离开的时候自己心中有数。</subtitle>
    <logo>https://dargonlee.github.io/images/avatar.png</logo>
    <icon>https://dargonlee.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 七里田间的守望者</rights>
    <entry>
        <title type="html"><![CDATA[iOS控制器View加载顺序详细版]]></title>
        <id>https://dargonlee.github.io/post/ios-kong-zhi-qi-view-jia-zai-shun-xu-xiang-xi-ban/</id>
        <link href="https://dargonlee.github.io/post/ios-kong-zhi-qi-view-jia-zai-shun-xu-xiang-xi-ban/">
        </link>
        <updated>2020-02-17T06:35:16.000Z</updated>
        <summary type="html"><![CDATA[<p><code>控制器声明周期</code></p>
<pre><code>//通过nib问价初始化触发
- (instancetype)initWithCoder:(NSCoder *)aDecoder

//nib文件被加载的时候，会发送一个消息到nib文件中的每一个对象
- (void)awakeFromNib

//开始加载视图控制器自带的view
- (void)loadView

//视图控制器的view被加载完成
- (void)viewDidLoad

//视图控制器的view将要显示在window上</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p><code>控制器声明周期</code></p>
<pre><code>//通过nib问价初始化触发
- (instancetype)initWithCoder:(NSCoder *)aDecoder

//nib文件被加载的时候，会发送一个消息到nib文件中的每一个对象
- (void)awakeFromNib

//开始加载视图控制器自带的view
- (void)loadView

//视图控制器的view被加载完成
- (void)viewDidLoad

//视图控制器的view将要显示在window上
&lt;!-- more --&gt;
- (void)viewWillAppear:(BOOL)animated

//视图控制器的view开始更新Autolayout
- (void)updateViewConstraints

//视图控制器的view开始更新内容视图的位置
- (void)viewWillLayoutSubviews

//视图控制器的view已经更新内容视图的位置
- (void)viewDidLayoutSubviews

//视图控制器的view已经显示到window上
- (void)viewDidAppear:(BOOL)animated

//视图控制的view将要从window上消失
- (void)viewWillDisappear:(BOOL)animated

//视图控制器的view已经从window上消失
- (void)viewDidDisappear:(BOOL)animated
</code></pre>
<p>加载过程:<br>
1 一般情况下调用 init方法或者调用initWithNibName方法实例化UIViewController, 不管调用哪个方法都为调用initWithNibName(方法定义如下)</p>
<ul>
<li>
<p><code>-(id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil</code></p>
</li>
<li>
<p>接着会调用loadView方法来生成UIViewController.view</p>
</li>
<li>
<p><code>- (void)loadView</code></p>
</li>
<li>
<p>下面来简单说下loadView底层</p>
<ul>
<li>
<p>判断下有没有指定storyboard，如果有，就去加载storyboard描述的控制器的view</p>
</li>
<li>
<p>判断下有没有指定nibName,如果有，就去加载nibName描述的控制器的view</p>
</li>
<li>
<p><code>- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil</code></p>
</li>
<li>
<p>如果判断有没有指定nibName,[self nibName]</p>
</li>
<li>
<p>判断下nibName是否为空，如果为空，他会尝试找下有没有跟控制器同名，但是不带Controller的xib</p>
</li>
<li>
<p>跟控制器同名的xib,nibName = ViewController,但是这一步有条件，前提条件你没有重写loadView</p>
</li>
<li>
<p>如果都没有找到，直接创建默认控制器的view</p>
</li>
</ul>
</li>
</ul>
<p><code>- (void)awakeFromNib;</code></p>
<ul>
<li>
<p>这个方法用的时候，outlet还没有连接起来，是view Controller刚从storyboard建的时候，没有完全建好，不过可能有一些事情要在这个方法里面完成，比如splitViewDelegate，需要在非常早期完成。然后调用 viewDidLoad方法<br>
<code>- (void)viewDidLoad</code></p>
</li>
<li>
<p>如果loadView不能生成UIViewController.view系统将会反复调用loadView及viewDidLoad方法, 并且最终调用[super loadView] 方法返回UIViewController.view<br>
然后依次调用如下2个方法, 这2个方法也十分重要, 在UINavigationController的POP操作后有时将要显示的UIViewController中的View并没有释放(也有可能释放掉) , UIViewController将不会调用上面的三个方法(initWithNibName,loadView,viewDidLoad) 而会调用下面这2个方法</p>
</li>
<li>
<p><code>- (void)viewWillAppear:(BOOL)animated;</code></p>
</li>
<li>
<p><code>- (void)viewDidAppear:(BOOL)animated;</code><br>
紧接着调用下面两个方法view中frame值布局，使子控制器的frame值更加准确</p>
</li>
<li>
<p><code>- (void)viewWillLayoutSubviews</code></p>
</li>
<li>
<p><code>-(void)viewDidLayoutSubviews</code></p>
</li>
<li>
<p>页面消失的方法</p>
</li>
</ul>
<p><code>- (void)viewWillDisappear:(BOOL)animated;</code><br>
<code>- (void)viewDidDisappear:(BOOL)animated;</code><br>
<code>- (void)viewWillUnload;</code>//iOS5.0添加- (void)viewDidUnload;<br>
<code>- (void)dealloc；</code></p>
<ul>
<li>
<p>控制器View一些方法的区分</p>
<ul>
<li>viewDidLoad其实没什么可混淆的,无论通过什么途径加载(Xcode或者IB,这里的加载属于实例化)完view后肯定会执行这个方法.</li>
<li><code>- loadView</code>需要分两种情况.
<ul>
<li>当你通过Xcode实例化一个类的时候就需要自己在controller中实现这个方法.</li>
<li>而在IB中实例化就不需要实现它.</li>
<li><code>- initWithNibName</code>这个方法是在controller的类在IB中创建,但是通过Xcode实例化controller的时候用的.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>awakeFromNib这个方法是一个类在IB中被实例化是被调用的.</p>
</li>
<li>
<p>看了帖子发现大家都推荐使用viewDidLoad而不要使用awakeFromNib,应为viewDidLoad会被多次调用,</p>
</li>
<li>
<p>而awakeFromNib只会当从nib文件中unarchive的时候才会被调用一次.</p>
</li>
<li>
<p>实际测试中发现,当一个类的awakeFromNib被调用的时候,那么这个类的viewDidLoad就不会被调用了,这个感觉很奇怪.</p>
</li>
<li>
<p><code>- initWithCoder</code>是一个类在IB中创建但在Xcode中被实例化时被调用的.</p>
</li>
<li>
<p>比如,通过IB创建一个controller的nib文件,然后在xocde中通过initWithNibName来实例化这个controller,那么这个controller的initWithCoder会被调用.</p>
</li>
<li>
<p><code>- awakeFromNib</code> 当.nib文件被加载的时候，会发送一个awakeFromNib的消息到.nib文件中的每个对象，每个对象都可以定义自己的awakeFromNib函数来响应这个消息，执行一些必要的操作。也就是说通过nib文件创建view对象是执行awakeFromNib</p>
</li>
</ul>
<p>viewDidLoad 当view对象被加载到内存是就会执行viewDidLoad，所以不管通过nib文件还是代码的方式创建对象都会执行viewDidLoad</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS开发将一个工程添加到另一个工程中]]></title>
        <id>https://dargonlee.github.io/post/ios-kai-fa-jiang-yi-ge-gong-cheng-tian-jia-dao-ling-yi-ge-gong-cheng-zhong/</id>
        <link href="https://dargonlee.github.io/post/ios-kai-fa-jiang-yi-ge-gong-cheng-tian-jia-dao-ling-yi-ge-gong-cheng-zhong/">
        </link>
        <updated>2019-11-16T06:38:45.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>一个项目引用另一个项目这里列举两种情况</p>
<ul>
<li>一个 Single View App 项目要引用另一个Single View App 项目</li>
<li>一个 Single View App 项目要引用 动态库的项目（Cocoa Touch Framework）</li>
</ul>
</blockquote>
<h4 id="先说第一种情况的做法">先说第一种情况的做法</h4>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>一个项目引用另一个项目这里列举两种情况</p>
<ul>
<li>一个 Single View App 项目要引用另一个Single View App 项目</li>
<li>一个 Single View App 项目要引用 动态库的项目（Cocoa Touch Framework）</li>
</ul>
</blockquote>
<h4 id="先说第一种情况的做法">先说第一种情况的做法</h4>
<!-- more -->
<ul>
<li>先在一个文件夹下 新建两个 Single View App 项目 一个为demo1 另一个为demo2</li>
</ul>
<blockquote>
<p>注意 现在的需求是 <code>demo1 要引用 demo2</code></p>
</blockquote>
<ul>
<li>
<p>然后在demo1项目中新建一个Group 命名为 <code>Frameworks</code> 创建完成如下图<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-a9bd6106264a07eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100047@2x.png" loading="lazy"></p>
</li>
<li>
<p>然后 <code>show in finder</code> <code>Frameworks</code> 把<code>demo2</code> 拖进去 完成后如下图<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-03744768dbf8acda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100400@2x.png" loading="lazy"></p>
</li>
<li>
<p>最后 进入到 <code>Frameworks</code>里面的 <code>demo2</code>找到 <code>demo2.xcodeproj</code> 然后把  <code>demo2.xcodeproj</code>  拖动到 <code>demo1</code>的<code>Frameworks</code>文件夹里面 操作完成如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-20a3f6a7cdbf069b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100707@2x.png" loading="lazy"></p>
</li>
<li>
<p>下面开始操作<code>demo2</code>了</p>
</li>
<li>
<p>选中 <code>Frameworks</code>里面的 <code>demo2.xcodeproj</code> 添加一个 Target 操作如图所示</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/646265-64fdf9f64b75e438.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100943@2x.png" loading="lazy"></figure>
<p><em><strong>创建动态库</strong></em></p>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/646265-e06cc019ed28e160.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100959@2x.png" loading="lazy"></figure>
<blockquote>
<p>我这里命名的target 为<code>xxx</code> 你可以按需求命名 因为到时候在 <code>demo1</code>中导入头文件的时候 就是这个名字</p>
</blockquote>
<ul>
<li>在 <code>demo2</code>中创建一个 <code>Person</code>类 （这个类就是一会我们要在<code>demo1</code>中使用的） 操作完成如下图<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-11a7c5c634e49ff6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-101342@2x.png" loading="lazy"></li>
</ul>
<blockquote>
<p>注意要想在 <code>demo1</code>使用的文件添加到 <code>xxx</code> 的target当中去 如下图所示 如果又想给<code>demo1</code>用又想自己用 那就两个target都勾选</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://upload-images.jianshu.io/upload_images/646265-14c3ab67d01a6f1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<ul>
<li>然后选中 刚才创建的那个 <code>xxx</code>target 进行如下图操作所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-e4097bda92932e75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-101451@2x.png" loading="lazy"></li>
</ul>
<blockquote>
<p>上图操作为 把<code>Project</code> 中的 <code>Person.h</code> 拖动到 <code>Public</code>中</p>
</blockquote>
<ul>
<li>
<p>然后选中 <code>demo1</code>进行如下图操作<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-6199f3ebc95efdd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-102412@2x.png" loading="lazy"></p>
</li>
<li>
<p>然后继续设置 <code>demo1</code>  在 <code>Build Settings</code>中设置<code>Header Search Paths</code> 的路径为 <code>${SRCROOT}/Frameworks/demo2</code> 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-1003fdf2f8b79706.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-102551@2x.png" loading="lazy"></p>
</li>
<li>
<p>至此 一个项目引入另一个项目的功能就完成了 在 <code>demo1</code>中 就可以快乐的使用 <code>demo2</code>的文件了 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-ae52f9c5f13fe3e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-102917@2x.png" loading="lazy"></p>
</li>
</ul>
<h1 id="下面是-single-view-app-项目要引用-动态库的项目cocoa-touch-framework">下面是 Single View App 项目要引用 动态库的项目（Cocoa Touch Framework）</h1>
<blockquote>
<p>思路跟上面差不多</p>
</blockquote>
<p>这里以 <code>Demo1</code> 为例子 以下图所示 操作<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-e31ad3c0f0dec7a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<p>然后按照下图选择创建动态库<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-e06cc019ed28e160.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100959@2x.png" loading="lazy"><br>
然后创建好的动态库如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-d103b7200d550368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<p>我在动态库里面 新建了 一个<code>Person</code>文件，并声明了一个属性和一个方法<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-e7048f8d3422fd79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<p>切记箭头指向的地方 如果在 <code>UUPerson</code> 中打钩就是只在<code>UUPerson</code>动态库中用。<br>
然后在 动态库的头文件中，配置要暴露出去的头文件 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-2e912de99b775b57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<p>接着就要配置外界能访问的头文件了 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-167dac6407dbb774.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<blockquote>
<p>把要对外的 <code>.h</code>文件都拖动到 Public的里面去</p>
</blockquote>
<p>然后就可以在当前项目中使用了 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-5035cf57f5cfad11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决定时器的循环引用]]></title>
        <id>https://dargonlee.github.io/post/jie-jue-ding-shi-qi-de-xun-huan-yin-yong/</id>
        <link href="https://dargonlee.github.io/post/jie-jue-ding-shi-qi-de-xun-huan-yin-yong/">
        </link>
        <updated>2019-11-15T02:40:51.000Z</updated>
        <summary type="html"><![CDATA[<p>一般使用定时器的方法，在控制器返回上级的时候。定时器都不会停止，会导致循环引用，控制器的<code>delloc</code>方法不会调用。<br>
以下两种方式就是为了解决，定时器在控制器返回上级的时候解决循环引用的问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一般使用定时器的方法，在控制器返回上级的时候。定时器都不会停止，会导致循环引用，控制器的<code>delloc</code>方法不会调用。<br>
以下两种方式就是为了解决，定时器在控制器返回上级的时候解决循环引用的问题。</p>
<!-- more --> 
<h5 id="在控制器中使用定时器常规的方法">在控制器中使用定时器常规的方法</h5>
<pre><code class="language-objc">@interface ViewController ()

@property (nonatomic,strong) NSTimer *timer;

@property (nonatomic,strong) CADisplayLink *link;

@end
</code></pre>
<pre><code class="language-objc">
- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    // Timer的使用
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTest) userInfo:nil repeats:YES];
    
    // CADisplayLink的使用
    self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(timerTest)];
    [self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
}

- (void)timerTest
{
    NSLog(@&quot;%s&quot;, __func__);
}
</code></pre>
<p>以上这种写法就是常规的写法，就是在一个控制器push到当前这个控制器的时候开启定时器。<br>
但是这种写法有问题，会产生循环引用问题，从而导致内存泄露。<br>
<code>ViewController</code> 引用 <code>timer定时器</code> <code>timer</code>的<code>target</code>又引用<code>ViewController</code> 而且三者都是使用 <code>storng</code>引用 这样在 <code>ViewController</code>返回上级的时候，不会调用<code>delloc</code>方法 从而导致循环引用。</p>
<h4 id="解决方法的思路">解决方法的思路：</h4>
<p>我们知道引起循环引用的问题是 <code>ViewController</code> <code>timer</code> <code>timer的target</code> 三者都是强引用导致的 我们只要在这个三个中间一个地方给设置<code>weak</code>引用 就不会产生循环引用了。<br>
思路就是 -&gt; 设置<code>timer</code>的<code>target</code>的时候不要直接设置 <code>ViewController</code> 而是设置一个 自定义的对象 比如 <code>TimerTarget</code> 然后由这个对象对控制器<code>弱引用</code>，本来由控制器的直接调用的定时方法，现在由 <code>TimerTarget</code> 对象对控制器进行转发。从而达到解决循环引用的问题。<br>
代码如下：</p>
<pre><code class="language-objc">
- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    
    self.link = [CADisplayLink displayLinkWithTarget:[TimerTarget proxyWithTarget:self] selector:@selector(timerTest)];
    
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[TimerTarget proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];
}

- (void)timerTest
{
    NSLog(@&quot;%s&quot;, __func__);
}
</code></pre>
<p><code>TimerTarget对象的方法实现</code></p>
<pre><code class="language-objc">@interface TimerTarget : NSObject

@property (nonatomic, weak) id target;
// 接收一个可以相应 定时器的对象
+ (instancetype)proxyWithTarget:(id)target;

@end


+ (instancetype)proxyWithTarget:(id)target
{
    TimerTarget *targets = [[TimerTarget alloc]init];
    targets.target = target;//然后对外部的对象进行弱引用
    return targets;
}
// 在定时器给当前对象发送方法的时候 会走当前对象的消息转发机制 
// 然后可以在这个方法里面对弱应用的对象去响应要调用的方法
- (id)forwardingTargetForSelector:(SEL)aSelector
{
    return self.target;
}
</code></pre>
<blockquote>
<p>上面的方法可以解决问题，但是这样效率不够高。因为在 <code>TimerTarget</code> 在做消息转发之前，会对父类方法查找和方法缓存中去找方法。这样效率不高。</p>
</blockquote>
<p>下面介绍一个苹果提供专门进行消息转发的类叫<code>NSProxy</code> 上面的解决方法我们是继承<code>NSObject</code> 下面我们可以直接继承这个类<br>
代码如下：</p>
<pre><code class="language-objc">@interface TimerProxy : NSProxy

@property (nonatomic, weak) id target;

+ (instancetype)proxyWithTarget:(id)target;

@end



+ (instancetype)proxyWithTarget:(id)target
{
    // NSProxy 不需要init方法
    TimerProxy *targets = [TimerProxy alloc];
    targets.target = target;
    return targets;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel
{
    return [self.target methodSignatureForSelector:sel];
}

- (void)forwardInvocation:(NSInvocation *)invocation
{
    [invocation invokeWithTarget:self.target];
}
</code></pre>
<p>这样的话 在定时的方法来的时候可以直接进行转发，而不会再去父类找了。</p>
<h4 id="补充">补充</h4>
<pre><code>__weak typeof(self) weakSelf = self;
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
        [weakSelf timerTest];
    }];
</code></pre>
<p>这种block的方法也可以解决循环引用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NSLayoutAnchor实践]]></title>
        <id>https://dargonlee.github.io/post/nslayoutanchor-shi-jian/</id>
        <link href="https://dargonlee.github.io/post/nslayoutanchor-shi-jian/">
        </link>
        <updated>2019-11-14T06:37:44.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>iOS如果项目中不用xib或者storyboard的话，给view做约束一般都是用第三方库<code>Masonry</code>，为什么不用系统提供的AutoLayout呢？<code>因为代码太多不好用</code></p>
</blockquote>
<ul>
<li>今天给大家介绍一个苹果iOS9后更新的一个布局的好用的类 <code>NSLayoutAnchor</code></li>
</ul>
<hr>
<h4 id="分别用-nslayoutconstraint-nslayoutanchor-和-masonry来进行如下图所示的布局">分别用 <code>NSLayoutConstraint</code> <code>NSLayoutAnchor</code> 和 <code>Masonry</code>来进行如下图所示的布局</h4>
<blockquote>
<p>在进行布局的时候，我会分别讲解下系统 <code>NSLayoutConstraint</code> <code>NSLayoutAnchor</code>两种布局的方法使用和参数说明<br>
至于<code>Masonry</code>的使用 我就不做多介绍了（官方介绍的很清楚，网上资料也不少）</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/646265-8b480a3ee6085ef6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190509-105625@2x.png" loading="lazy"></figure>
<h3 id="第一种-nslayoutconstraint">第一种 <code>NSLayoutConstraint</code></h3>
<pre><code># NSLayoutConstraint 的核心布局方法
[NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];

</code></pre>
<p>上面代码的白话文就是<br>
<code>红色view 的 centerX 等于 self.view 的 centerX 1.0倍 加 0</code><br>
如果还不是很明白的话 看下图就一目了然了</p>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/646265-b155f2e0c3eaa558.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190509-110720@2x.png" loading="lazy"></figure>
<h4 id="接下来我们来讲一下初始化方法中各个参数的意义">接下来我们来讲一下初始化方法中各个参数的意义：</h4>
<pre><code>item:        要布局的view

attribute: 是一个NSLayoutAttribute枚举，可以看到他的枚举值有 left、right、bottom、top 等

relatedBy:  是一个NSLayoutRelation枚举，他的枚举值有 lessThanOrEqual（小于等于）、equal（等于）、greaterThanOrEqual（大于等于）， 指定 view1和接下来那个参数 view2两个视图之
间的约束关系的

toItem:     第一个view的参照view 你要参照哪个view 这个就是哪个view（本例中的是self.view控制器view）

attribute:  和第二个参数一样，是来表示第一个视图对第二个视图的
参考位置 ，上下左右 还是 center等

multiplier: 是来计算两个视图之间约束的倍数关系

constant:  是来计算两个视图之间约束的倍数关系的基础上再加一些常量

</code></pre>
<h4 id="下面看约束代码">下面看约束代码</h4>
<pre><code>// 布局redView
    NSLayoutConstraint *centerX = [NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];
    NSLayoutConstraint *top = [NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeTopMargin multiplier:1.0 constant:10];
    
    NSLayoutConstraint *width = [NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:200];
    NSLayoutConstraint *heith = [NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:200];
    
    //可以单个添加约束
    [self.view addConstraint:centerX];
    [self.view addConstraint:top];
    
    //也可以添加约束多个约束
    [self.redView addConstraints:@[width, heith]];
    
    
    
    // 布局blueView
    NSLayoutConstraint *centerX1 = [NSLayoutConstraint constraintWithItem:self.blueView attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.redView attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];
    NSLayoutConstraint *top1 = [NSLayoutConstraint constraintWithItem:self.blueView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self.redView attribute:NSLayoutAttributeBottom multiplier:1.0 constant:20];
    
    NSLayoutConstraint *width1 = [NSLayoutConstraint constraintWithItem:self.blueView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:self.redView attribute:NSLayoutAttributeWidth multiplier:1.5 constant:0];
    NSLayoutConstraint *heith1 = [NSLayoutConstraint constraintWithItem:self.blueView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:self.redView attribute:NSLayoutAttributeWidth multiplier:1.5 constant:0];
    
    //iOS8 以后 NSLayoutConstraint 的类方法 也可以把约束添加到视图上，而且省掉了判断添加到那个视图上的问题，避免了上面例子中因为视图添加错误而导致的崩溃
    [NSLayoutConstraint activateConstraints:@[centerX1,top1, width1, heith1]];
</code></pre>
<h5 id="nslayoutconstraint添加约束注意事项"><code>NSLayoutConstraint</code>添加约束注意事项</h5>
<p>1.如果两个视图（也就是参数 item 和 toItem）是父子关系，设置子控件的约束，约束添加到父控件上<br>
2.如果两个视图（也就是参数 item 和 toItem）是兄弟关系，设置两兄弟的约束，约束会添加到第一个共同的父控件上<br>
3.如果两个视图（也就是参数 item 和 toItem）是同一个视图，约束会添加到自己上(一般给自己添加约束toItem为nil attribute为NSLayoutAttributeNotAnAttribute)<br>
4.要给添加约束的view要设置<code>translatesAutoresizingMaskIntoConstraints</code>为NO 否则约束不生效</p>
<pre><code>    UIView *redView = [[UIView alloc]init];
    redView.backgroundColor = [UIColor redColor];
    // 要禁止 autoresize 意思就是遵循autoLayout抛弃原有设置的高度宽度等
    // 使用autolayout的视图必须要设置该属性
    redView.translatesAutoresizingMaskIntoConstraints = NO;
</code></pre>
<h3 id="第二种-nslayoutanchor-ios9以后">第二种 <code>NSLayoutAnchor</code> ios9以后</h3>
<pre><code>- (NSLayoutConstraint *)constraintEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;
- (NSLayoutConstraint *)constraintGreaterThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;
- (NSLayoutConstraint *)constraintLessThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;

/* These methods return an inactive constraint of the form thisAnchor = otherAnchor + constant.
 */
- (NSLayoutConstraint *)constraintEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c;
- (NSLayoutConstraint *)constraintGreaterThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c;
- (NSLayoutConstraint *)constraintLessThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c;

</code></pre>
<h4 id="接下来我们来讲一下使用方法">接下来我们来讲一下使用方法</h4>
<p>比如要给redView设置一个约束，如下</p>
<pre><code>[self.redView.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor];
</code></pre>
<p>上面代码的意思为 <code>红色的view的centerX和self.view的centerX相等</code></p>
<h4 id="下面看使用nslayoutanchor写的约束代码">下面看使用<code>NSLayoutAnchor</code>写的约束代码</h4>
<pre><code>    [self.redView.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor].active = YES;
    [self.redView.topAnchor constraintEqualToAnchor:self.view.safeAreaLayoutGuide.topAnchor constant:20].active = YES;
    [self.redView.widthAnchor constraintEqualToConstant:200].active = YES;
    [self.redView.heightAnchor constraintEqualToConstant:200].active = YES;
    
    [self.blueView.centerXAnchor constraintEqualToAnchor:self.redView.centerXAnchor].active = YES;
    [self.blueView.topAnchor constraintEqualToAnchor:self.redView.bottomAnchor constant:20].active = YES;
    [self.blueView.widthAnchor constraintEqualToAnchor:self.redView.widthAnchor multiplier:1.5].active = YES;
    [self.blueView.heightAnchor constraintEqualToAnchor:self.redView.heightAnchor multiplier:1.5].active = YES;
</code></pre>
<h5 id="nslayoutanchor添加约束注意事项"><code>NSLayoutAnchor</code>添加约束注意事项</h5>
<p>1.要给添加约束的view要设置<code>translatesAutoresizingMaskIntoConstraints</code>为NO 否则约束不生效 <code>自定义view的时候也要给子view设置此属性，总之你要给哪个view设置Layout就要给哪个view设置此属性为NO</code><br>
2.<code>active</code>要设置为YES 这个是控制约束是否真正添加的开关 设置为NO的时候 约束失效</p>
<h3 id="第三种-masonry">第三种 <code>Masonry</code></h3>
<h4 id="直接上代码了">直接上代码了</h4>
<pre><code>    [self.redView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.top.equalTo(self.view.mas_topMargin).with.offset(20);
        make.centerX.equalTo(self.view.mas_centerX);
        make.width.height.equalTo(@200);
    }];
    
    [self.blueView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.top.equalTo(self.redView.mas_bottom).offset(20);
        make.centerX.equalTo(self.redView.mas_centerX);
        make.width.height.equalTo(self.redView).multipliedBy(1.5);
    }];
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter 常用布局]]></title>
        <id>https://dargonlee.github.io/post/flutter-chang-yong-bu-ju/</id>
        <link href="https://dargonlee.github.io/post/flutter-chang-yong-bu-ju/">
        </link>
        <updated>2019-09-17T06:33:37.000Z</updated>
        <content type="html"><![CDATA[<h4 id="行布局-在x轴上">行布局 （在X轴上）</h4>
<blockquote>
<p>Row.mainAxisAlignment 主轴排列方式</p>
</blockquote>
<pre><code>Row(
  mainAxisAlignment: MainAxisAlignment.spaceAround,  // 改变这个值 可以更改排列方式 如下图
  mainAxisSize: MainAxisSize.max,
  children: [
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
], )
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/646265-2fc1ab8a4b7f57a4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="row.jpg" loading="lazy"></figure>
<blockquote>
<p>Row.crossAxisAlignment 纵轴排列方式</p>
</blockquote>
<pre><code>Row(
  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
  crossAxisAlignment: CrossAxisAlignment.start,  // 改变这个值 可以更改排列方式 如下图
  children: [
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 100.0),
    Icon(Icons.stars, size: 50.0),
], )
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/646265-90a2530f54792a81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="列布局在y轴上">列布局（在Y轴上）</h4>
<blockquote>
<p>Column.mainAxisAlignment 列布局 主轴排列方式</p>
</blockquote>
<pre><code>Column(
  mainAxisAlignment: MainAxisAlignment.start, // 改变这个值 可以更改排列方式 如下图
  mainAxisSize: MainAxisSize.max,
  children: [
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
], )
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://upload-images.jianshu.io/upload_images/646265-ef8cbc570e2abf84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<blockquote>
<p>Column.mainAxisAlignment 列布局 纵轴排列方式</p>
</blockquote>
<pre><code>Column(
  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
  crossAxisAlignment: CrossAxisAlignment.start, // 改变这个值 可以更改排列方式 如下图
  children: [
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 100.0),
    Icon(Icons.stars, size: 50.0),
], )
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://upload-images.jianshu.io/upload_images/646265-d03f1a32a2a66c41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="stack布局允许子widget堆叠可以叠加布局view也就是在-z-轴上">Stack布局（允许子widget堆叠，可以叠加布局View，也就是在 Z 轴上）</h4>
<blockquote>
<p>Stack.alignment</p>
</blockquote>
<pre><code>Stack(
  alignment: AlignmentDirectional.topStart, //改变这个值 可以更改排列方式 如下面两张图
  children:[
    SizedBox(
      width: 300.0,
      height: 300.0,
      child: Container(color: Colors.green),
), SizedBox(
      width: 200.0,
      height: 200.0,
      child: Container(color: Colors.yellow),
), SizedBox(
      width: 100.0,
      height: 100.0,
      child: Container(color: Colors.red),
), ],
)
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/646265-6ea3906a2a13098f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"><br>
<img src="https://upload-images.jianshu.io/upload_images/646265-9e0c8ba13561b3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<h4 id="positioned布局">Positioned布局</h4>
<blockquote>
<p>Stack允许子widget堆叠，而Positioned可以给子widget定位 <code>根据Stack的四个角</code></p>
</blockquote>
<pre><code>Stack(
  children: [
    SizedBox(
      width: 300.0,
      height: 300.0,
      child: Container(color: Colors.green),
    ),
    Positioned( // 这里的位置都是相对于 上面的SizeBox的位置的
      left: 20.0, 
      top: 20.0,
      width: 100.0,
      height: 100.0,
      child: Container(color: Colors.indigo),
    ),
    Positioned( // 这里的位置都是相对于 上面的SizeBox的位置的
      bottom: 20.0,
      right: 20.0,
      width: 100.0,
      height: 100.0,
      child: Container(color: Colors.black87),
), ],
)
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://upload-images.jianshu.io/upload_images/646265-32432b7a3de5aa7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="expanded布局">Expanded布局</h4>
<blockquote>
<p>Expanded组件可以使Row、Column、Flex等子组件在其主轴方向上展开并填充可用空间(例如，Row在水平方向，Column在垂直方向)。如果多个子组件展开，可用空间会被其flex factor(表示扩展的速度、比例)分割。</p>
</blockquote>
<pre><code>Row(
      crossAxisAlignment: CrossAxisAlignment.stretch,
          children: &lt;Widget&gt;[
            Expanded(
              flex: 1, //组件占据剩余空间的比例
              child: Container(
                color: Colors.yellow,
                child: Center(child: Text('flex: 1'),),
              ),
            ),
            Expanded(
              flex: 2,
              child: Container(
                color: Colors.orange,
                child: Center(child: Text('flex: 2'),),
              ),
            ),
            Expanded(
              flex: 3,
              child: Container(
                color: Colors.cyan,
                child: Center(child: Text('flex: 3'),),
              ),
            )
          ],
        ),
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://upload-images.jianshu.io/upload_images/646265-072a28dbc18077cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="expanded-padding-sizedbox">Expanded + Padding + SizedBox</h4>
<blockquote>
<p>如何用 <code>padding</code> 和 <code>SizeBox</code> 给内容之间添加间隙</p>
</blockquote>
<pre><code>Container(
        height: 200.0,
        color: Colors.yellow,
        padding: EdgeInsets.all(16.0),
        child: Row(
          children: &lt;Widget&gt;[
            Expanded(
              flex: 1,
              child: Container(
                color: Colors.green,
                child: Center(child: Text('flex: 1'),),
              ),
            ),
            SizedBox(width: 40.0,),
            Expanded(
              flex: 2,
              child: Container(
                color: Colors.orange,
                child: Center(child: Text('flex: 2'),),
              ),
            )
          ],
        ),
      ),
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://upload-images.jianshu.io/upload_images/646265-105875d9a122bce3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git的常用命令]]></title>
        <id>https://dargonlee.github.io/post/git-de-chang-yong-ming-ling/</id>
        <link href="https://dargonlee.github.io/post/git-de-chang-yong-ming-ling/">
        </link>
        <updated>2019-08-12T05:38:57.000Z</updated>
        <summary type="html"><![CDATA[<pre><code class="language-bash"># 显示当前的Git配置
$ git config --list

# 查看仓库配置
git config --local -l 

# 查看用户配置
git config --global -l 

# 查看系统配置
git config --system -l </code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code class="language-bash"># 显示当前的Git配置
$ git config --list

# 查看仓库配置
git config --local -l 

# 查看用户配置
git config --global -l 

# 查看系统配置
git config --system -l 

&lt;!-- more --&gt;

# 编辑Git配置文件

git config --local -e 编辑仓库级别配置文件
git config --global -e 编辑用户级别配置文件
git config --system -e 编辑系统级别配置文件

# 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;
</code></pre>
<p>推送操作 切记直接使用 <code>git push</code></p>
<pre><code class="language-bash">git push origin HEAD:refs/for/develop  
</code></pre>
<p>创建并切换到dev分支（本地分支）</p>
<pre><code class="language-bash">git checkout -b dev
</code></pre>
<p>删除本地dev分支(本地)</p>
<pre><code class="language-bash">git branch -d dev
</code></pre>
<p>分支合并</p>
<pre><code class="language-scheme">git checkout master
git merge dev
</code></pre>
<p>推送本地分支到远程</p>
<pre><code class="language-bash">git push -u origin develop
</code></pre>
<p>查看分支：</p>
<pre><code class="language-bash">git branch
</code></pre>
<p>创建分支：</p>
<pre><code class="language-bash">git branch 
</code></pre>
<p>切换分支：</p>
<pre><code class="language-bash">git checkout `或者`git switch `
</code></pre>
<p>删除远程分支：</p>
<pre><code class="language-bash"> git push origin --delete 
</code></pre>
<p>打tag</p>
<pre><code class="language-bash">git tag 
</code></pre>
<p>删除本地tag</p>
<pre><code class="language-bash">git tag -d 
</code></pre>
<p>删除远程tag</p>
<pre><code class="language-bash">git push origin --delete tag 
</code></pre>
<p>推送到哪个分支</p>
<pre><code class="language-bash">git push origin HEAD:refs/for/branch
</code></pre>
<p>回退相关操作</p>
<pre><code class="language-bash">git reset --hard HEAD^ // 回退pull操作

git reset --mixed HEAD^ // 回退commit 只退一步

git reset --hard 139dcfaa558e3276b30b6b2e5cbbb9c00bbdca96 // 回退到某一个版本
git reset --soft HEAD^//该命令会将工作去的文件回退到目标版本，但是不会改变暂存区的状态。

--hard 会清空工作目录和暂存区的改动,而 --soft则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区
</code></pre>
<p>执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</p>
<pre><code class="language-bash">git stash save &quot;save message&quot; :
</code></pre>
<p>查看stash了哪些存储</p>
<pre><code class="language-bash">git stash list
</code></pre>
<p>显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}</p>
<pre><code class="language-scheme">git stash show
</code></pre>
<p>显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p</p>
<pre><code class="language-bash">git stash show -p
</code></pre>
<p>应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1}</p>
<pre><code class="language-bash">git stash apply
</code></pre>
<p>命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}</p>
<pre><code class="language-bash">git stash pop
</code></pre>
<p>从列表中删除这个存储</p>
<pre><code class="language-bash">git stash drop stash@{$num} ：丢弃stash@{$num}存储
</code></pre>
<p>删除所有缓存的stash</p>
<pre><code class="language-bash">git stash clear
</code></pre>
<p>代码提交</p>
<pre><code class="language-bash"># 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
</code></pre>
<p>分支</p>
<pre><code class="language-bash"># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre>
<p>查看信息</p>
<pre><code class="language-bash"># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
</code></pre>
<p>远程同步</p>
<pre><code class="language-bash"># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
</code></pre>
<p>撤销</p>
<pre><code class="language-bash"># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
</code></pre>
<p>撤销本地提交</p>
<blockquote>
<p>HEAD^的意思是上一个版本，也可以写成HEAD~1<br>
如果你进行了2次commit，想都撤回，可以使用HEAD~2</p>
</blockquote>
<p>至于这几个参数：</p>
<pre><code>--mixed 
意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作
这个为默认参数,git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的
</code></pre>
<pre><code>--soft  
不删除工作空间改动代码，撤销commit，不撤销git add . 
</code></pre>
<pre><code>--hard
删除工作空间改动代码，撤销commit，撤销git add . 
注意完成这个操作后，就恢复到了上一次的commit状态。
</code></pre>
<pre><code>顺便说一下，如果commit注释写错了，只是想改一下注释，只需要：
git commit --amend
此时会进入默认vim编辑器，修改注释完毕后保存就好了
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS布局]]></title>
        <id>https://dargonlee.github.io/post/css-bu-ju/</id>
        <link href="https://dargonlee.github.io/post/css-bu-ju/">
        </link>
        <updated>2019-07-09T05:36:06.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="position">position</h1>
<blockquote>
<p>为了制作更多复杂的布局，我们需要讨论下<code>position</code>属性。它有一大堆的值，名字还都特抽象，别提有多难记了。让我们先一个个的过一遍，不过你最好还是把这页放到书签里。</p>
</blockquote>
<ul>
<li><code>static</code>元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分；行内元素则会创建一个或多个行框，置于其父元素中。</li>
</ul>
<pre><code class="language-css">.static {
    position: static;
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="position">position</h1>
<blockquote>
<p>为了制作更多复杂的布局，我们需要讨论下<code>position</code>属性。它有一大堆的值，名字还都特抽象，别提有多难记了。让我们先一个个的过一遍，不过你最好还是把这页放到书签里。</p>
</blockquote>
<ul>
<li><code>static</code>元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分；行内元素则会创建一个或多个行框，置于其父元素中。</li>
</ul>
<pre><code class="language-css">.static {
    position: static;
}
</code></pre>
<!--more-->
<p><code>static</code>是默认值。任意<code>position: static;</code>的元素不会被特殊的定位。一个 static 元素表示它<em>不会被“positioned”</em>，一个 position 属性被设置为其他值的元素表示它<em>会被“positioned”</em>。</p>
<ul>
<li><code>relative</code>元素框相对于之前正常文档流中的位置发生偏移，并且原先的位置仍然被占据。发生偏移的时候，可能会覆盖其他元素。</li>
</ul>
<pre><code class="language-css">.relative1 {
  position: relative;
}

.relative2 {
  position: relative;
  top: -20px;
  left: 20px;
  background-color: white;
  width: 500px;
}
</code></pre>
<blockquote>
<p>relative1 的表现和static一样，除非你添加了一些额外的属性</p>
<p>在一个相对定位（position属性的值为relative）的元素上设置<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙</p>
</blockquote>
<p><code>absolute</code>元素框不再占有文档流位置，并且相对于包含块进行偏移(所谓的包含块就是最近一级外层元素position不为static的元素)</p>
<p><code>absolute</code>与<code>fixed</code>的表现类似，但是它不是相对于视窗而是相对于<em>最近的“positioned”祖先元素</em>。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。记住一个“positioned”元素是指 position 值不是<code>static</code>的元素。</p>
<pre><code class="language-css">.relative { // 父元素
  position: relative; 
  width: 600px;
  height: 400px;
}
.absolute { // 子元素
  position: absolute;
  top: 120px;
  right: 0;
  width: 300px;
  height: 200px;
}
</code></pre>
<blockquote>
<p>子元素是相对定位的。如果它的父元素是<code>position: static;</code>，子元素会跳过父元素直接相对于body元素定位。</p>
<p>换句话说就是 子元素要想使用  `absolute 进行绝对定位 那么它相对的那个元素postition必须relative，如果父元素没有relative的话 子元素会相对本身最近的一个有relative属性的元素进行定位</p>
</blockquote>
<p><code>fixed</code>元素框不再占有文档流位置，并且相对于视窗进行定位</p>
<pre><code class="language-css">&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;
.footer {
  position: fixed;
  bottom: 0;
  left: 0;
  height: 70px;
  background-color: white;
  width: 100%;
}
</code></pre>
<p><code>sticky</code>(这是css3新增的属性值)粘性定位，官方的介绍比较简单，或许你不能理解。其实，它就相当于relative和fixed混合。最初会被当作是relative，相对于原来的位置进行偏移；一旦超过一定阈值之后，会被当成fixed定位，相对于视口进行定位</p>
<blockquote>
<p>相对于body定位并且是悬浮的</p>
</blockquote>
<ul>
<li><code>floate</code></li>
</ul>
<blockquote>
<p>另一个布局中常用的CSS属性是<code>float</code>。Float 可用于实现文字环绕图片</p>
</blockquote>
<pre><code class="language-css">img {
  float: right;
  margin: 0 0 1em 1em;
}
</code></pre>
<ul>
<li><code>clear</code></li>
</ul>
<blockquote>
<p><code>clear</code>属性被用于控制浮动。比较下面两个例子：</p>
</blockquote>
<pre><code class="language-html">&lt;div class=&quot;box&quot;&gt;...&lt;/div&gt;
&lt;section&gt;...&lt;/section&gt;
</code></pre>
<pre><code class="language-css">.box {
  float: left;
  width: 200px;
  height: 100px;
  margin: 1em;
}
在这个例子中， section 元素实际上是在 div 之后的（译注：DOM结构上）。然而 div 元素是浮动到左边的，于是 section 中的文字就围绕了 div ，并且 section 元素包围了整个元素。如果我们想让 section 显示在浮动元素之后呢？
</code></pre>
<pre><code class="language-css">.box {
  float: left;
  width: 200px;
  height: 100px;
  margin: 1em;
}
.after-box {
  clear: left;
}
使用 clear 我们就可以将这个段落移动到浮动元素 div 下面。你需要用 left 值才能清除元素的向左浮动。你还可以用 right 或 both 来清除向右浮动或同时清除向左向右浮动。
</code></pre>
<p>清除浮动</p>
<pre><code class="language-css">img {
  float: right;
}

.clearfix { //清除浮动
  overflow: auto;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS-给UILabel增加复制粘贴功能]]></title>
        <id>https://dargonlee.github.io/post/ios-gei-uilabel-zeng-jia-fu-zhi-nian-tie-gong-neng/</id>
        <link href="https://dargonlee.github.io/post/ios-gei-uilabel-zeng-jia-fu-zhi-nian-tie-gong-neng/">
        </link>
        <updated>2019-06-11T05:37:07.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="第一步">第一步</h2>
<pre><code class="language-objectivec">//让label有资格成为第一响应者
- (BOOL)becomeFirstResponder
{
    return YES;
}

//label能执行哪些操作(比如 拷贝 等)
- (BOOL)canPerformAction:(SEL)action withSender:(id)sender
{
    if (action == @selector(copy:) || action == @selector(paste:) || action == @selector(cut:)) return YES;
    return NO;
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="第一步">第一步</h2>
<pre><code class="language-objectivec">//让label有资格成为第一响应者
- (BOOL)becomeFirstResponder
{
    return YES;
}

//label能执行哪些操作(比如 拷贝 等)
- (BOOL)canPerformAction:(SEL)action withSender:(id)sender
{
    if (action == @selector(copy:) || action == @selector(paste:) || action == @selector(cut:)) return YES;
    return NO;
}
</code></pre>
<!--more-->
<h2 id="第二步">第二步</h2>
<pre><code class="language-objectivec">
- (void)copy:(UIMenuController *)menu
{
    //将自己的文字赋值到粘贴板
    [self copy:menu];
    //清空文字
    self.text = nil;
}

- (void)paste:(UIMenuController *)menu
{
    //将自己的文字赋值到粘贴板
    UIPasteboard * board = [UIPasteboard generalPasteboard];
    board.string = self.text;
}

- (void)cut:(UIMenuController *)menu
{
    UIPasteboard * board = [UIPasteboard generalPasteboard];
    self.text = board.string;
}
</code></pre>
<h2 id="第三步">第三步</h2>
<pre><code class="language-objectivec">- (void)awakeFromNib
{
    [self setup];
    [super awakeFromNib];
}

- (instancetype)initWithFrame:(CGRect)frame
{
    if (self == [super initWithFrame:frame]) {
        [self setup];
    }
    return self;
}

- (void)setup
{
    self.userInteractionEnabled = YES;

    [self addGestureRecognizer:[[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(labelClick)]];
}
</code></pre>
<p>显示menu</p>
<pre><code class="language-objectivec">- (void)labelClick
{
    //1.让label成为第一响应者(这里的self是UILabel)
    [self becomeFirstResponder];

    //2.显示menuController
    UIMenuController * menu = [UIMenuController sharedMenuController];
//    [menu setTargetRect:self.frame inView:self.superview];
    [menu setTargetRect:self.bounds inView:self];
    [menu setMenuVisible:YES animated:YES];

    NSLog(@&quot;%s&quot;,__func__);
}
</code></pre>
<h1 id="over">OVER</h1>
<p>如果你想自定义的话可以写下面方法(相应的实现方法需要再控制器里面实现不然用不了)</p>
<pre><code class="language-objectivec">UIMenuController * menu = [UIMenuController sharedMenuController];
UIMenuItem * reply = [[UIMenuItem alloc]initWithTitle:@&quot;回复&quot; action:@selector(replay:)];
UIMenuItem * ding = [[UIMenuItem alloc]initWithTitle:@&quot;顶&quot; action:@selector(ding:)];
UIMenuItem * report = [[UIMenuItem alloc]initWithTitle:@&quot;举报&quot; action:@selector(report:)];
menu.menuItems = @[reply,ding,report];
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[修改iOS返回按钮的几种方式]]></title>
        <id>https://dargonlee.github.io/post/xiu-gai-ios-fan-hui-an-niu-de-ji-chong-fang-shi/</id>
        <link href="https://dargonlee.github.io/post/xiu-gai-ios-fan-hui-an-niu-de-ji-chong-fang-shi/">
        </link>
        <updated>2019-02-13T02:43:05.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="第一种">第一种</h3>
<pre><code class="language-objectivec">UIImage *backButtonImage = [[UIImage imageNamed:@&quot;back&quot;] resizableImageWithCapInsets:UIEdgeInsetsMake(0, 25, 0, 0)];

[[UIBarButtonItem appearance] setBackButtonBackgroundImage:backButtonImage forState:UIControlStateNormal barMetrics:UIBarMetricsDefault];

[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(NSIntegerMin, NSIntegerMin) forBarMetrics:UIBarMetricsDefault];
</code></pre>
<blockquote>
<p>提示:上面这种方法会被系统给拉伸,需要在当前控制器里面设置</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="第一种">第一种</h3>
<pre><code class="language-objectivec">UIImage *backButtonImage = [[UIImage imageNamed:@&quot;back&quot;] resizableImageWithCapInsets:UIEdgeInsetsMake(0, 25, 0, 0)];

[[UIBarButtonItem appearance] setBackButtonBackgroundImage:backButtonImage forState:UIControlStateNormal barMetrics:UIBarMetricsDefault];

[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(NSIntegerMin, NSIntegerMin) forBarMetrics:UIBarMetricsDefault];
</code></pre>
<blockquote>
<p>提示:上面这种方法会被系统给拉伸,需要在当前控制器里面设置</p>
</blockquote>
<!--more-->
<h3 id="第二种">第二种</h3>
<pre><code class="language-objectivec">UIBarButtonItem *backItem = [[UIBarButtonItem alloc] init];
backItem.title = @&quot;&quot;;
//主要是以下两个图片设置
self.navigationController.navigationBar.backIndicatorImage = [UIImage imageNamed:@&quot;backPic&quot;];
self.navigationController.navigationBar.backIndicatorTransitionMaskImage = [UIImage imageNamed:@&quot;backPic&quot;];        
self.navigationItem.backBarButtonItem = backItem;
</code></pre>
<blockquote>
<p>提示: 这种方法在父类方法中设置好使</p>
</blockquote>
<h3 id="-以上两种方法都是在不改变系统手势滑动返回的情况下的">- 以上两种方法都是在不改变系统手势滑动返回的情况下的</h3>
<h3 id="第三种">第三种</h3>
<pre><code class="language-objectivec">//创建一个UIButton
UIButton *backButton = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 40, 40)];
//设置UIButton的图像
[backButton setImage:[UIImage imageNamed:@&quot;left_select_img.png&quot;] forState:UIControlStateNormal];
//给UIButton绑定一个方法，在这个方法中进行popViewControllerAnimated
[backButton addTarget:self action:@selector(backItemClick) forControlEvents:UIControlEventTouchUpInside];
//然后通过系统给的自定义BarButtonItem的方法创建BarButtonItem
UIBarButtonItem *backItem = [[UIBarButtonItem alloc]initWithCustomView:backButton];
//覆盖返回按键
self.navigationItem.leftBarButtonItem = backItem;
</code></pre>
<blockquote>
<p>提示:这种方法会失去手势滑动返回的功能</p>
</blockquote>
<h3 id="第四种">第四种</h3>
<pre><code class="language-objectivec">//重新创建一个barButtonItem
UIBarButtonItem *backItem = [[UIBarButtonItem alloc]initWithTitle:@&quot;你想要设置的返回按钮文字&quot; style:UIBarButtonItemStylePlain target:nil action:nil];
//设置backBarButtonItem即可
self.navigationItem.backBarButtonItem = backItem;
</code></pre>
<blockquote>
<p>提示:上面这种方式只是修改返回文字而已 至于返回图标还是系统提供的 手势滑动返回依然存在</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://dargonlee.github.io/post/hello-gridea/</id>
        <link href="https://dargonlee.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>