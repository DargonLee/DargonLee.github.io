<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dargonlee.github.io</id>
    <title>七里田间的守望者</title>
    <updated>2021-01-27T13:26:16.819Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dargonlee.github.io"/>
    <link rel="self" href="https://dargonlee.github.io/atom.xml"/>
    <subtitle>我不在乎是悲伤的离别还是不痛快的离别，只要是离开一个地方，我总希望离开的时候自己心中有数。</subtitle>
    <logo>https://dargonlee.github.io/images/avatar.png</logo>
    <icon>https://dargonlee.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 七里田间的守望者</rights>
    <entry>
        <title type="html"><![CDATA[Python文件操作]]></title>
        <id>https://dargonlee.github.io/post/python-wen-jian-cao-zuo/</id>
        <link href="https://dargonlee.github.io/post/python-wen-jian-cao-zuo/">
        </link>
        <updated>2021-01-23T04:02:19.000Z</updated>
        <content type="html"><![CDATA[<h3 id="文件读写">文件读写</h3>
<pre><code class="language-python"># 文件读写
# r 只读 默认值
# w 只写 内容清空
# a 只写 内容不清空 只能在末尾追加内容
# r+ 读写 末尾追加内容
# w+ 读写 内容会被清空
# a+ 读写 写文件只能追加内容
# 使用with 打开文件后，自动关闭文件
# 不使用with的话就要主动调用f.close()
with open(&quot;result.txt&quot;, 'r') as f:
    data = f.read()
    print(&quot;text: {}&quot;.format(data))

with open(&quot;result.txt&quot;, 'w') as f:
    data = &quot;hello python&quot;
    # 返回写入的字符串长度
    l = f.write(data)
    print(&quot;{}&quot;.format(l))
</code></pre>
<h3 id="获取目录下的所有文件">获取目录下的所有文件</h3>
<pre><code class="language-python"># 获取目录信息
dirs = os.scandir(&quot;../venv&quot;)
for entry in dirs:
    # 判断文件或者文件夹是否存在
    # if entry.is_dir() or entry.is_file():
        print(entry.name)
dirs.close()

entrys = Path(&quot;../venv&quot;)
for entry in entrys.iterdir():
    print(entry.name)
</code></pre>
<h3 id="列出目录下的所有文件">列出目录下的所有文件</h3>
<pre><code class="language-python">basepath = &quot;../venv&quot;
for entry in os.listdir(basepath):
    # 判断是否为文件夹
    if os.path.isdir(os.path.join(basepath, entry)):
        print(entry)
    # 判断是否为文件
    if os.path.isfile(os.path.join(basepath, entry)):
        print(entry)
</code></pre>
<h3 id="获取文件的属性">获取文件的属性</h3>
<pre><code class="language-python"># 获取文件属性
with os.scandir(&quot;../venv&quot;) as entries:
    for entry in entries:
        info = entry.stat()
        print(info.st_mtime)
        print('{} 上次修改时间为 {}'.format(entry.name, timestamp2datetime(info.st_mtime)))
</code></pre>
<h4 id="转换-unix-时间戳为-datetime对象">转换 UNIX 时间戳为 datetime对象</h4>
<pre><code class="language-python">
def timestamp2datetime(timestamp, convert_to_local=True, utc=8, is_remove_ms=True):
    &quot;&quot;&quot;                                                                           
    转换 UNIX 时间戳为 datetime对象                                                       
    :param timestamp: 时间戳                                                         
    :param convert_to_local: 是否转为本地时间                                             
    :param utc: 时区信息，中国为utc+8                                                     
    :param is_remove_ms: 是否去除毫秒                                                   
    :return: datetime 对象                                                          
    &quot;&quot;&quot;
    if is_remove_ms:
        timestamp = int(timestamp)
    dt = datetime.datetime.utcfromtimestamp(timestamp)
    if convert_to_local:
        dt = dt + datetime.timedelta(hours=utc)
    return dt


def convert_date(timestamp, format='%Y-%m-%d %H:%M:%S'):
    dt = timestamp2datetime(timestamp)
    return dt.strftime(format) 
</code></pre>
<h3 id="创建目录">创建目录</h3>
<pre><code class="language-python">os.mkdir(&quot;example_directory&quot;)
</code></pre>
<p>如果该目录已经存在，os.mkdir() 将抛出 FileExistsError 异常。或者，你也可以使用 pathlib 来创建目录:</p>
<pre><code class="language-python">from pathlib import Path

try:
    p = Path('example_directory')
    p.mkdir()
except FileExistsError as e:
    print(e)

# 或者 你可以给 .mkdir() 传入 exist_ok=True 参数来忽略 FileExistsError 异常:
p = Path('example_directory')
p.mkdir(exist_ok=True)
</code></pre>
<h3 id="创建多个目录">创建多个目录</h3>
<p><code>os.makedirs()</code> 和在bash中运行 <code>mkdir -p</code> 类似。例如，要创建一组目录像 <code>2018/10/05</code>，你可以像下面那样操作:</p>
<pre><code class="language-python">import os
os.makedirs('2018/10/05', mode=0o770)
</code></pre>
<p>也可以像下面创建</p>
<pre><code class="language-python">from pathlib import Path

p = Path('2018/10/05')
p.mkdir(parents=True, exist_ok=True)
</code></pre>
<p>运行上述代码会得到像下面的结构：</p>
<pre><code class="language-python">└── 2018
    └── 10
        └── 05
</code></pre>
<h3 id="文件名模式匹配">文件名模式匹配</h3>
<p>使用上述方法之一获取目录中的文件列表后，你可能希望搜索和特定的模式匹配的文件。</p>
<p>下面这些是你可以使用的方法和函数：</p>
<p>endswith() 和 startswith() 字符串方法<br>
fnmatch.fnmatch()<br>
glob.glob()<br>
pathlib.Path.glob()<br>
这些方法和函数是下面要讨论的。本小节的示例将在名为 some_directory 的目录下执行，该目录具有以下的结构：</p>
<pre><code class="language-python">.
├── admin.py
├── data_01_backup.txt
├── data_01.txt
├── data_02_backup.txt
├── data_02.txt
├── data_03_backup.txt
├── data_03.txt
├── sub_dir
│   ├── file1.py
│   └── file2.py
└── tests.py
</code></pre>
<p>如果你正在使用 Bash shell，你可以使用以下的命令创建上述目录结构:</p>
<pre><code class="language-python">mkdir some_directory
cd some_directory
mkdir sub_dir
touch sub_dir/file1.py sub_dir/file2.py
touch data_{01..03}.txt data_{01..03}_backup.txt admin.py tests.py
</code></pre>
<h3 id="使用字符串方法">使用字符串方法</h3>
<p>Python有几个内置 修改和操作字符串 的方法。当在匹配文件名时，其中的两个方法 .startswith() 和 .endswith() 非常有用。要做到这点，首先要获取一个目录列表，然后遍历。</p>
<pre><code class="language-python">import os

for f_name in os.listdir('some_directory'):
    if f_name.endswith('.txt'):
        print(f_name)
</code></pre>
<p>上述代码找到 some_directory 中的所有文件，遍历并使用 .endswith() 来打印所有扩展名为 .txt 的文件名。运行代码在我的电脑上输出如下:</p>
<pre><code class="language-python">data_01.txt
data_01_backup.txt
data_02.txt
data_02_backup.txt
data_03.txt
data_03_backup.txt
</code></pre>
<h3 id="遍历目录和处理文件">遍历目录和处理文件</h3>
<p>一个常见的编程任务是遍历目录树并处理目录树中的文件。让我们来探讨一下如何使用内置的Python函数 os.walk() 来实现这一功能。os.walk() 用于通过从上到下或从下到上遍历树来生成目录树中的文件名。处于本节的目的，我们想操作以下的目录树:</p>
<pre><code class="language-python">├── folder_1
│   ├── file1.py
│   ├── file2.py
│   └── file3.py
├── folder_2
│   ├── file4.py
│   ├── file5.py
│   └── file6.py
├── test1.txt
└── test2.txt
</code></pre>
<p>以下是一个示例，演示如何使用 os.walk() 列出目录树中的所有文件和目录。</p>
<p>os.walk() 默认是从上到下遍历目录:</p>
<p>python import os for dirpath, dirname, files in os.walk('.'): print(f'Found directory: {dirpath}') for file_name in files: print(file_name)</p>
<p>os.walk() 在每个循环中返回三个值：</p>
<p>当前文件夹的名称<br>
当前文件夹中子文件夹的列表<br>
当前文件夹中文件的列表<br>
在每次迭代中，会打印出它找到的子目录和文件的名称：</p>
<pre><code class="language-python">Found directory: .
test1.txt
test2.txt
Found directory: ./folder_1
file1.py
file3.py
file2.py
Found directory: ./folder_2
file4.py
file5.py
file6.py
</code></pre>
<p>要以自下而上的方式遍历目录树，则将 topdown=False 关键字参数传递给 os.walk() ：</p>
<pre><code class="language-python">for dirpath, dirnames, files in os.walk('.', topdown=False):
    print(f'Found directory: {dirpath}')
    for file_name in files:
        print(file_name)
</code></pre>
<p>传递 topdown=False 参数将使 os.walk() 首先打印出它在子目录中找到的文件:</p>
<pre><code class="language-python">Found directory: ./folder_1
file1.py
file3.py
file2.py
Found directory: ./folder_2
file4.py
file5.py
file6.py
Found directory: .
test1.txt
test2.txt
</code></pre>
<p>如你看见的，程序在列出根目录的内容之前列出子目录的内容。 这在在你想要递归删除文件和目录的情况下非常有用。 你将在以下部分中学习如何执行此操作。 默认情况下，os.walk 不会访问通过软连接创建的目录。 可以通过使用 followlinks = True 参数来覆盖默认行为。</p>
<h3 id="创建临时文件和目录">创建临时文件和目录</h3>
<p>Python提供了 tempfile 模块来便捷的创建临时文件和目录。</p>
<p>tempfile 可以在你程序运行时打开并存储临时的数据在文件或目录中。 tempfile 会在你程序停止运行后删除这些临时文件。</p>
<p>现在，让我们看看如何创建一个临时文件:</p>
<pre><code class="language-python">from tempfile import  TemporaryFile

# 创建一个临时文件并为其写入一些数据
fp = TemporaryFile('w+t')
fp.write('Hello World!')
# 回到开始，从文件中读取数据
fp.seek(0)
data = fp.read()
print(data)
# 关闭文件，之后他将会被删除
fp.close()
</code></pre>
<p>第一步是从 tempfile 模块导入 TemporaryFile 。 接下来，使用 TemporaryFile() 方法并传入一个你想打开这个文件的模式来创建一个类似于对象的文件。这将创建并打开一个可用作临时存储区域的文件。</p>
<p>在上面的示例中，模式为 w + t，这使得 tempfile 在写入模式下创建临时文本文件。 没有必要为临时文件提供文件名，因为在脚本运行完毕后它将被销毁。</p>
<p>写入文件后，您可以从中读取并在完成处理后将其关闭。 一旦文件关闭后，将从文件系统中删除。 如果需要命名使用 tempfile 生成的临时文件，请使用 tempfile.NamedTemporaryFile() 。</p>
<p>使用 tempfile 创建的临时文件和目录存储在用于存储临时文件的特殊系统目录中。 Python将在目录列表搜索用户可以在其中创建文件的目录。</p>
<p>在Windows上，目录按顺序为 C:\TEMP，C:\TMP，\TEMP 和 \TMP。 在所有其他平台上，目录按顺序为 / tmp，/var/tmp 和 /usr/tmp 。 如果上述目录中都没有，tempfile 将在当前目录中存储临时文件和目录。</p>
<p>.TemporaryFile() 也是一个上下文管理器，因此它可以与with语句一起使用。 使用上下文管理器会在读取文件后自动关闭和删除文件：</p>
<pre><code class="language-python">with TemporaryFile('w+t') as fp:
    fp.write('Hello universe!')
    fp.seek(0)
    fp.read()
# 临时文件现在已经被关闭和删除
</code></pre>
<p>这将创建一个临时文件并从中读取数据。 一旦读取文件的内容，就会关闭临时文件并从文件系统中删除。</p>
<p>tempfile 也可用于创建临时目录。 让我们看一下如何使用 tempfile.TemporaryDirectory()来做到这一点：</p>
<pre><code class="language-python">import tempfile
import os

tmp = ''
with tempfile.TemporaryDirectory() as tmpdir:
    print('Created temporary directory ', tmpdir)
    tmp = tmpdir
    print(os.path.exists(tmpdir))

print(tmp)
print(os.path.exists(tmp))
</code></pre>
<p>调用 tempfile.TemporaryDirectory() 会在文件系统中创建一个临时目录，并返回一个表示该目录的对象。 在上面的示例中，使用上下文管理器创建目录，目录的名称存储在 tmpdir 变量中。 第三行打印出临时目录的名称，os.path.exists(tmpdir) 来确认目录是否实际在文件系统中创建。</p>
<p>在上下文管理器退出上下文后，临时目录将被删除，并且对 os.path.exists(tmpdir)的调用将返回False，这意味着该目录已成功删除。</p>
<h3 id="删除文件和目录">删除文件和目录</h3>
<p>您可以使用 os，shutil 和 pathlib 模块中的方法删除单个文件，目录和整个目录树。 以下将介绍如何删除你不再需要的文件和目录。</p>
<p>Python中删除文件<br>
要删除单个文件，请使用 pathlib.Path.unlink()，os.remove() 或 os.unlink()。</p>
<p>os.remove() 和 os.unlink() 在语义上是相同的。 要使用 os.remove()删除文件，请执行以下操作：</p>
<pre><code class="language-python">import os

data_file = 'C:\\Users\\vuyisile\\Desktop\\Test\\data.txt'
os.remove(data_file)
</code></pre>
<p>使用 os.unlink() 删除文件与使用 os.remove() 的方式类似：</p>
<pre><code class="language-python">import os

data_file = 'C:\\Users\\vuyisile\\Desktop\\Test\\data.txt'
os.unlink(data_file)
</code></pre>
<p>在文件上调用 .unlink() 或 .remove() 会从文件系统中删除该文件。 如果传递给它们的路径指向目录而不是文件，这两个函数将抛出 OSError 。 为避免这种情况，可以检查你要删除的内容是否是文件，并在确认是文件时执行删除操作，或者可以使用异常处理来处理 OSError ：</p>
<pre><code class="language-python">import os

data_file = 'home/data.txt'
# 如果类型是文件则进行删除
if os.path.is_file(data_file):
    os.remove(data_file)
else:
    print(f'Error: {data_file} not a valid filename')
</code></pre>
<p>os.path.is_file() 检查 data_file 是否实际上是一个文件。 如果是，则通过调用 os.remove() 删除它。 如果 data_file 指向文件夹，则会向控制台输出错误消息。</p>
<p>以下示例说明如何在删除文件时使用异常处理来处理错误：</p>
<pre><code class="language-python">import os

data_file = 'home/data.txt'
# 使用异常处理
try:
    os.remove(data_file)
except OSError as e:
    print(f'Error: {data_file} : {e.strerror}')
</code></pre>
<p>上面的代码尝试在检查其类型之前先删除该文件。 如果 data_file 实际上不是文件，则抛出的 OSError 将在except子句中处理，并向控制台输出错误消息。 打印出的错误消息使用 Python f-strings 格式化。</p>
<p>最后，你还可以使用 pathlib.Path.unlink() 删除文件：</p>
<pre><code class="language-python">from pathlib import Path

data_file = Path('home/data.txt')
try:
    data_file.unlink()
except IsADirectoryError as e:
    print(f'Error: {data_file} : {e.strerror}')

</code></pre>
<p>这将创建一个名为 data_file 的 Path 对象，该对象指向一个文件。 在 data_file 上调用.unlink（）将删除 home / data.txt 。 如果 data_file 指向目录，则引发 IsADirectoryError 。 值得注意的是，上面的Python程序和运行它的用户具有相同的权限。 如果用户没有删除文件的权限，则会引发 PermissionError 。</p>
<h3 id="删除目录">删除目录</h3>
<p>标准库提供了一下函数来删除目录:</p>
<p>os.rmdir()<br>
pathlib.Path.rmdir()<br>
shutil.rmtree()<br>
要删除单个目录或文件夹可以使用 os.rmdir() 或 pathlib.Path.rmdir() 。这两个函数只在你删除空目录的时候有效。如果目录不为空，则会抛出 OSError 。下面演示如何删除一个文件夹:</p>
<pre><code class="language-python">import os

trash_dir = 'my_documents/bad_dir'

try:
    os.rmdir(trash_dir)
except OSError as e:
    print(f'Error: {trash_dir} : {e.strerror}')
</code></pre>
<p>现在，trash_dir 已经通过 os.rmdir() 被删除了。如果目录不为空，则会在屏幕上打印错误信息:</p>
<pre><code class="language-python">Traceback (most recent call last):
  File '&lt;stdin&gt;', line 1, in &lt;module&gt;
OSError: [Errno 39] Directory not empty: 'my_documents/bad_dir'
</code></pre>
<p>同样，你也可使用 pathlib 来删除目录:</p>
<pre><code class="language-python">from pathlib import Path

trash_dir = Path('my_documents/bad_dir')

try:
    trash_dir.rmdir()
except OSError as e:
    print(f'Error: {trash_dir} : {e.strerror}')
</code></pre>
<p>这里创建了一个 Path 对象指向要被删除的目录。如果目录为空，调用 Path 对象的 .rmdir() 方法删除它。</p>
<h3 id="删除完整的目录树">删除完整的目录树</h3>
<p>要删除非空目录和完整的目录树，Python提供了 shutil.rmtree() :</p>
<pre><code class="language-python">import shutil

trash_dir = 'my_documents/bad_dir'

try:
    shutil.rmtree(trash_dir)
except OSError as e:
    print(f'Error: {trash_dir} : {e.strerror}')
</code></pre>
<p>当调用 shutil.rmtree() 时，trash_dir 中的所有内容都将被删除。 在某些情况下，你可能希望以递归方式删除空文件夹。 你可以使用上面讨论的方法之一结合 os.walk() 来完成此操作:</p>
<pre><code class="language-python">import os

for dirpath, dirnames, files in os.walk('.', topdown=False):
    try:
        os.rmdir(dirpath)
    except OSError as ex:
        pass
</code></pre>
<h3 id="从加密的文档提取数据">从加密的文档提取数据</h3>
<p>zipfile 支持提取受密码保护的ZIP。 要提取受密码保护的ZIP文件，请将密码作为参数传递给 .extract() 或.extractall() 方法：</p>
<pre><code class="language-python">&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; with zipfile.ZipFile('secret.zip', 'r') as pwd_zip:
...     # 从加密的文档提取数据
...     pwd_zip.extractall(path='extract_dir', pwd='Quish3@o')
</code></pre>
<p>将以读取模式打开 secret.zip 存档。 密码提供给 .extractall() ，并且压缩文件内容被提取到 extract_dir 。 由于with语句，在完成提取后，存档文件会自动关闭。</p>
<h3 id="创建新的存档文件">创建新的存档文件</h3>
<p>要创建新的ZIP存档，请以写入模式（w）打开 ZipFile 对象并添加要归档的文件：</p>
<pre><code class="language-python">&gt;&gt;&gt; import zipfile

&gt;&gt;&gt; file_list = ['file1.py', 'sub_dir/', 'sub_dir/bar.py', 'sub_dir/foo.py']
&gt;&gt;&gt; with zipfile.ZipFile('new.zip', 'w') as new_zip:
...     for name in file_list:
...         new_zip.write(name)

</code></pre>
<p>在该示例中，new_zip 以写入模式打开，file_list 中的每个文件都添加到存档文件中。 with语句结束后，将关闭 new_zip 。 以写入模式打开ZIP文件会删除压缩文件的内容并创建新存档文件。</p>
<p>要将文件添加到现有的存档文件，请以追加模式打开 ZipFile 对象，然后添加文件：</p>
<pre><code class="language-python">&gt;&gt;&gt; with zipfile.ZipFile('new.zip', 'a') as new_zip:
...     new_zip.write('data.txt')
...     new_zip.write('latin.txt')
</code></pre>
<p>这里打开在上一个示例中以追加模式创建的 new.zip 存档。 在追加模式下打开 ZipFile 对象允许将新文件添加到ZIP文件而不删除其当前内容。 将文件添加到ZIP文件后，with语句将脱离上下文并关闭ZIP文件。</p>
<h3 id="打开tar存档文件">打开TAR存档文件</h3>
<p>TAR文件是像ZIP等未压缩的文件存档。 它们可以使用 gzip，bzip2 和 lzma 压缩方法进行压缩。 TarFile 类允许读取和写入TAR存档。</p>
<p>下面是从存档中读取：</p>
<pre><code class="language-python">import tarfile

with tarfile.open('example.tar', 'r') as tar_file:
    print(tar_file.getnames())
</code></pre>
<p>tarfile 对象像大多数类似文件的对象一样打开。 它们有一个 open() 函数，它采用一种模式来确定文件的打开方式。</p>
<p>使用“r”，“w”或“a”模式分别打开未压缩的TAR文件以进行读取，写入和追加。 要打开压缩的TAR文件，请将模式参数传递给 tarfile.open()，其格式为 filemode [:compression] 。 下表列出了可以打开TAR文件的可能模式：</p>
<p>| 模式 | 行为 | | ----- | ----------------------------- | | r | 以无压缩的读取模式打开存档 | | r:gz | 以gzip压缩的读取模式打开存档 | | r:bz2 | 以bzip2压缩的读取模式打开存档 | | w | 以无压缩的写入模式打开存档 | | w:gz | 以gzip压缩的写入模式打开存档 | | w:xz | 以lzma压缩的写入模式打开存档 | | a | 以无压缩的追加模式打开存档 |</p>
<p>.open() 默认为'r'模式。 要读取未压缩的TAR文件并检索其中的文件名，请使用 .getnames() ：</p>
<pre><code class="language-python">&gt;&gt;&gt; import tarfile

&gt;&gt;&gt; tar = tarfile.open('example.tar', mode='r')
&gt;&gt;&gt; tar.getnames()
['CONTRIBUTING.rst', 'README.md', 'app.py']

</code></pre>
<p>这以列表的方式返回存档中内容的名字。</p>
<p>注意：为了向你展示如何使用不同的tarfile对象方法，示例中的TAR文件在交互式REPL会话中手动打开和关闭。<br>
通过这种方式与TAR文件交互，你可以查看运行每个命令的输出。 通常，你可能希望使用上下文管理器来打开类似文件的对象。<br>
此外可以使用特殊属性访问存档中每个条目的元数据：</p>
<pre><code class="language-python">&gt;&gt;&gt; for entry in tar.getmembers():
...     print(entry.name)
...     print(' Modified:', time.ctime(entry.mtime))
...     print(' Size    :', entry.size, 'bytes')
...     print()
CONTRIBUTING.rst
 Modified: Sat Nov  1 09:09:51 2018
 Size    : 402 bytes

README.md
 Modified: Sat Nov  3 07:29:40 2018
 Size    : 5426 bytes

app.py
 Modified: Sat Nov  3 07:29:13 2018
 Size    : 6218 bytes
</code></pre>
<p>在此示例中，循环遍历 .getmembers() 返回的文件列表，并打印出每个文件的属性。.getmembers() 返回的对象具有可以通过编程方式访问的属性，例如归档中每个文件的名称，大小和上次修改时间。 在读取或写入存档后，必须关闭它以释放系统资源。</p>
<h3 id="从tar存档中提取文件">从TAR存档中提取文件</h3>
<p>在本节中，你将学习如何使用以下方法从TAR存档中提取文件：</p>
<p>.extract()<br>
.extractfile()<br>
.extractall()</p>
<p>要从TAR存档中提取单个文件，请使用 extract() ，传入文件名：</p>
<pre><code class="language-python">&gt;&gt;&gt; tar.extract('README.md')
&gt;&gt;&gt; os.listdir('.')
['README.md', 'example.tar']
</code></pre>
<p>README.md 文件从存档中提取到文件系统。 调用 os.listdir() 确认 README.md 文件已成功提取到当前目录中。 要从存档中解压缩或提取所有内容，请使用 .extractall() ：</p>
<pre><code>&gt;&gt;&gt; tar.extractall(path=&quot;extracted/&quot;)
</code></pre>
<p>.extractall() 有一个可选的 path 参数来指定解压缩文件的去向。 这里，存档被提取到 extracted 目录中。 以下命令显示已成功提取存档：</p>
<pre><code>$ ls
example.tar  extracted  README.md

$ tree
.
├── example.tar
├── extracted
|   ├── app.py
|   ├── CONTRIBUTING.rst
|   └── README.md
└── README.md

1 directory, 5 files

$ ls extracted/
app.py  CONTRIBUTING.rst  README.md
</code></pre>
<p>要提取文件对象以进行读取或写入，请使用 .extractfile() ，它接收 文件名或 TarInfo 对象作为参数。 .extractfile() 返回一个可以读取和使用的类文件对象：</p>
<pre><code class="language-python">&gt;&gt;&gt; f = tar.extractfile('app.py')
&gt;&gt;&gt; f.read()
&gt;&gt;&gt; tar.close()
</code></pre>
<p>打开的存档应在读取或写入后始终关闭。 要关闭存档，请在存档文件句柄上调用 .close() ，或在创建 tarfile对象时使用with语句，以便在完成后自动关闭存档。 这将释放系统资源，并将你对存档所做的任何更改写入文件系统。</p>
<h3 id="创建新的tar存档">创建新的TAR存档</h3>
<p>创建新的TAR存档，你可以这样操作:</p>
<pre><code class="language-python">&gt;&gt;&gt; import tarfile

&gt;&gt;&gt; file_list = ['app.py', 'config.py', 'CONTRIBUTORS.md', 'tests.py']
&gt;&gt;&gt; with tarfile.open('packages.tar', mode='w') as tar:
...     for file in file_list:
...         tar.add(file)

&gt;&gt;&gt; # Read the contents of the newly created archive
&gt;&gt;&gt; with tarfile.open('package.tar', mode='r') as t:
...     for member in t.getmembers():
...         print(member.name)
app.py
config.py
CONTRIBUTORS.md
tests.py

</code></pre>
<p>首先，你要创建要添加到存档的文件列表，这样你就不必手动添加每个文件。</p>
<p>下一行使用with光线文管理器在写入模式下打开名为 packages.tar 的新存档。 以写入模式（'w'）打开存档使你可以将新文件写入存档。 将删除存档中的所有现有文件，并创建新存档。</p>
<p>创建并填充存档后，with上下文管理器会自动关闭它并将其保存到文件系统。 最后三行打开刚刚创建的存档，并打印出其中包含的文件的名称。</p>
<p>要将新文件添加到现有存档，请以追加模式（'a'）打开存档：</p>
<pre><code class="language-python">&gt;&gt;&gt; with tarfile.open('package.tar', mode='a') as tar:
...     tar.add('foo.bar')

&gt;&gt;&gt; with tarfile.open('package.tar', mode='r') as tar:
...     for member in tar.getmembers():
...         print(member.name)
app.py
config.py
CONTRIBUTORS.md
tests.py
foo.bar
</code></pre>
<p>在追加模式下打开存档允许你向其添加新文件而不删除其中已存在的文件。</p>
<h3 id="使用压缩存档">使用压缩存档</h3>
<p>tarfile 可以读取和写入使用 gzip，bzip2 和 lzma 压缩的TAR存档文件。 要读取或写入压缩存档，请使用tarfile.open() ，为压缩类型传递适当的模式。</p>
<p>例如，要读取或写入使用 gzip 压缩的TAR存档的数据，请分别使用 'r:gz' 或 'w:gz' 模式：</p>
<pre><code class="language-python">&gt;&gt;&gt; files = ['app.py', 'config.py', 'tests.py']
&gt;&gt;&gt; with tarfile.open('packages.tar.gz', mode='w:gz') as tar:
...     tar.add('app.py')
...     tar.add('config.py')
...     tar.add('tests.py')

&gt;&gt;&gt; with tarfile.open('packages.tar.gz', mode='r:gz') as t:
...     for member in t.getmembers():
...         print(member.name)
app.py
config.py
tests.py

</code></pre>
<p>'w:gz' 以写模式模式打开 gzip 压缩的存档，'r:gz' 以读模式打开 gzip 压缩的存档。 无法在追加模式下打开压缩存档。 要将文件添加到压缩存档，你必须创建新存档。</p>
<h3 id="一个更简单的方式创建存档">一个更简单的方式创建存档</h3>
<p>Python标准库还支持使用 shutil 模块中的高级方法创建TAR和ZIP存档。 shutil 中的归档实用工具允许你创建，读取和提取ZIP和TAR归档。 这些实用工具依赖于较底层的 tarfile 和 zipfile 模块。</p>
<h4 id="使用-shutilmake_archive-创建存档">使用 shutil.make_archive() 创建存档</h4>
<p>shutil.make_archive() 至少接收两个参数：归档的名称和归档格式。</p>
<p>默认情况下，它将当前目录中的所有文件压缩为 format 参数中指定的归档格式。 你可以传入可选的 root_dir 参数来压缩不同目录中的文件。 .make_archive() 支持 zip ，tar ，bztar 和 gztar 存档格式。</p>
<p>以下是使用 shutil 创建TAR存档的方法：</p>
<pre><code class="language-python">import shutil

# shutil.make_archive(base_name, format, root_dir)
shutil.make_archive('data/backup', 'tar', 'data/')

</code></pre>
<p>这将复制 data / 中的所有内容，并在文件系统中创建名为 backup.tar 的存档并返回其名称。 要提取存档，请调用 .unpack_archive() ：</p>
<pre><code class="language-python">shutil.unpack_archive('backup.tar', 'extract_dir/')

</code></pre>
<p>调用 .unpack_archive() 并传入存档名称和目标目录，将 backup.tar 的内容提取到 extract_dir/ 中。 ZIP存档可以以相同的方式创建和提取。</p>
<h3 id="读取多个文件">读取多个文件</h3>
<p>Python支持通过 fileinput 模块从多个输入流或文件列表中读取数据。 此模块允许你快速轻松地循环遍历一个或多个文本文件的内容。 以下是使用 fileinput 的典型方法：</p>
<pre><code class="language-python">import fileinput
for line in fileinput.input()
    process(line)
</code></pre>
<p>fileinput 默认从传递给 sys.argv 的命令行参数获取其输入。</p>
<h3 id="使用-fileinput-循环遍历多个文件">使用 fileinput 循环遍历多个文件</h3>
<p>让我们使用 fileinput 构建一个普通的UNIX工具 cat 的原始版本。 cat 工具按顺序读取文件，将它们写入标准输出。 当在命令行参数中给出多个文件时，cat 将连接文本文件并在终端中显示结果：</p>
<pre><code class="language-python"># File: fileinput-example.py
import fileinput
import sys

files = fileinput.input()
for line in files:
    if fileinput.isfirstline():
        print(f'\n--- Reading {fileinput.filename()} ---')
    print(' -&gt; ' + line, end='')
print()
</code></pre>
<p>在当前目录中有两个文本文件，运行此命令会产生以下输出：</p>
<pre><code>$ python3 fileinput-example.py bacon.txt cupcake.txt
--- Reading bacon.txt ---
 -&gt; Spicy jalapeno bacon ipsum dolor amet in in aute est qui enim aliquip,
 -&gt; irure cillum drumstick elit.
 -&gt; Doner jowl shank ea exercitation landjaeger incididunt ut porchetta.
 -&gt; Tenderloin bacon aliquip cupidatat chicken chuck quis anim et swine.
 -&gt; Tri-tip doner kevin cillum ham veniam cow hamburger.
 -&gt; Turkey pork loin cupidatat filet mignon capicola brisket cupim ad in.
 -&gt; Ball tip dolor do magna laboris nisi pancetta nostrud doner.

--- Reading cupcake.txt ---
 -&gt; Cupcake ipsum dolor sit amet candy I love cheesecake fruitcake.
 -&gt; Topping muffin cotton candy.
 -&gt; Gummies macaroon jujubes jelly beans marzipan.

</code></pre>
<p>fileinput 允许你检索有关每一行的更多信息，例如它是否是第一行(.isfirstline())，行号(.lineno())和文件名(.filename())。 你可以在 这里 读更多关于它的内容。</p>
<h3 id="总结">总结</h3>
<p>你现在知道如何使用Python对文件和文件组执行最常见的操作。 你已经了解使用不同的内置模块来读取，查找和操作文件。</p>
<p>你现在可以用Python来实现:</p>
<p>获取目录内容和文件属性<br>
创建目录和目录树<br>
使用匹配模式匹配文件名<br>
创建临时文件和目录<br>
移动，重命名，复制和删除文件或目录<br>
从不同类型的存档文件中读取和提取数据<br>
使用 fileinput 同时读取多个文件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ssh连接手机的方式]]></title>
        <id>https://dargonlee.github.io/post/ssh-lian-jie-shou-ji-de-fang-shi/</id>
        <link href="https://dargonlee.github.io/post/ssh-lian-jie-shou-ji-de-fang-shi/">
        </link>
        <updated>2020-07-25T12:38:51.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="通过usb连接iphone">通过USB连接iPhone</h4>
<ul>
<li>用<code>iproxy</code> 转发端口</li>
</ul>
<pre><code class="language-shell">iproxy 2222 22 进行端口转发
</code></pre>
<p>想要支持多个ssh连接的话 需要添加参数 -t<br>
如果加<code>-t</code> 不行的 请使用<code>usbmuxd</code>的1.0.8版本</p>
<p>如果是1.0.8版本的需要执行下面的命令进行端口转发</p>
<pre><code class="language-shell">python tcprelay.py -t 22:2222
</code></pre>
<p>这里的<code>-t</code>就是支持多个ssh连接的参数</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="通过usb连接iphone">通过USB连接iPhone</h4>
<ul>
<li>用<code>iproxy</code> 转发端口</li>
</ul>
<pre><code class="language-shell">iproxy 2222 22 进行端口转发
</code></pre>
<p>想要支持多个ssh连接的话 需要添加参数 -t<br>
如果加<code>-t</code> 不行的 请使用<code>usbmuxd</code>的1.0.8版本</p>
<p>如果是1.0.8版本的需要执行下面的命令进行端口转发</p>
<pre><code class="language-shell">python tcprelay.py -t 22:2222
</code></pre>
<p>这里的<code>-t</code>就是支持多个ssh连接的参数</p>
<!-- more -->
<p>然后连接好USB进行登录手机</p>
<pre><code class="language-shell">ssh -p 2222 root@127.0.0.1
或者
ssh -p 2222 root@localhost
</code></pre>
<blockquote>
<p>上面代码意义在于将iPhone的22端口（ssh端口）映射到Mac本地的2222端口</p>
</blockquote>
<h4 id="使用scp拷贝文件到手机的某个目录">使用scp拷贝文件到手机的某个目录</h4>
<ul>
<li>通过WiFi的方式</li>
</ul>
<pre><code class="language-shell">scp 本地文件路径 roo@192.168.1.2:手机的目录
</code></pre>
<ul>
<li>通过端口转发的方式</li>
</ul>
<pre><code class="language-shell">scp -P 2222 本地文件路径 root@localhost:手机的目录
</code></pre>
<p><em><strong>注意：</strong></em></p>
<blockquote>
<p>执行脚本的方式有三种<br>
分别为<code>sh xx.sh</code> <code>base xx.sh</code> <code>source xx.sh</code><br>
这里的 <code>sh xx.sh</code> <code>base xx.sh</code> 都是系统会开一个子进程去执行命令，执行完之后还是会返回到父进程的执行环境中。</p>
</blockquote>
<p><code>source xx.sh</code> 和 <code>. xx.sh</code> 一样的</p>
<p>比如 脚本内部有个命令 <code>cd xx/yy</code>的一个目录，<br>
用<code>sh xx.sh</code> <code>base xx.sh</code>执行完毕之后 你会发现当前shell执行环境还是之前的，<br>
不会是<code>xx/yy</code>的环境下<br>
但是用 <code>source xx.sh</code>这种方式 执行完毕后 就会进入到<code>xx/yy</code>的目录下</p>
<p>如果想在终端编辑文件 需要在 <code>Cydia</code> 中安装一个vim （https://apt.saurik.com）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cycript语法的使用]]></title>
        <id>https://dargonlee.github.io/post/cycript-yu-fa-de-shi-yong/</id>
        <link href="https://dargonlee.github.io/post/cycript-yu-fa-de-shi-yong/">
        </link>
        <updated>2020-07-25T12:36:58.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>可以用来探索、修改、调试正在运行的Mac/iOS 的APP。</p>
</blockquote>
<ul>
<li>在手机上安装 Cycript 插件</li>
<li>使用的使用需要先用Mac终端连接手机</li>
<li>终端输入 <code>cycript</code> 就进入了调试环境了</li>
<li>cycript -p [进程ID] 或者[com.SpringBoard]或者[可执行文件的名称]</li>
<li>可以用<code>ps</code>指令获取某个应用程序的进程id</li>
<li>退出 control + d</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>可以用来探索、修改、调试正在运行的Mac/iOS 的APP。</p>
</blockquote>
<ul>
<li>在手机上安装 Cycript 插件</li>
<li>使用的使用需要先用Mac终端连接手机</li>
<li>终端输入 <code>cycript</code> 就进入了调试环境了</li>
<li>cycript -p [进程ID] 或者[com.SpringBoard]或者[可执行文件的名称]</li>
<li>可以用<code>ps</code>指令获取某个应用程序的进程id</li>
<li>退出 control + d</li>
</ul>
<!-- more -->
<h4 id="ps-指令-process-status-的缩写">ps 指令 【process status 的缩写】</h4>
<ul>
<li>先在手机上安装 <code>adv-cmds</code> 插件</li>
<li><code>ps -A 列出所有进程</code></li>
<li><code>ps A | grep 关键词</code></li>
</ul>
<h4 id="语法">语法</h4>
<p><code>UIApp</code> = <code>[UIApplication sharedApplication]</code></p>
<p>定义变量</p>
<pre><code class="language-swift"> var xx = UIApp.keyWindow
</code></pre>
<p>用内存地址获取对象</p>
<pre><code># 内存地址
</code></pre>
<p>获取当前程序用到的类</p>
<pre><code class="language-swift">ObjectiveC.classes
</code></pre>
<p>查看对象所有成员变量</p>
<pre><code class="language-swift">*UIApp
或者
*#对象内存地址
</code></pre>
<p>递归打印View的所有子控件</p>
<pre><code class="language-swift">[UIApp.keyWindow recursiveDescription]
想要排版好看点的话
[UIApp.keyWindow recursiveDescription].toString()
</code></pre>
<p>以上两种写法的常用形式</p>
<pre><code class="language-swift">UIApp.keyWindow.recursiveDescription().toString()
</code></pre>
<p>筛选出某中类型的对象</p>
<pre><code class="language-swift">choose(UIViewController)
choose(UITableViewCell)
</code></pre>
<p>拷贝封装好的js文件到iPhone</p>
<pre><code class="language-shell">scp -P 2222 文件在Mac上的路径/MJTool.js root@localhost:/usr/lib/cycript0.9
</code></pre>
<p>如果想要保证自己写的文件和其他的文件不冲突的话</p>
<pre><code>scp -P 2222 文件在Mac上的路径/MJTool.cy root@localhost:/usr/lib/cycript0.9/com/harlans
</code></pre>
<h3 id="封装cy文件">封装<code>cy</code>文件</h3>
<p>新建<code>test.cy</code>文件</p>
<pre><code class="language-swift">(function(exports) {
    MJSum = function (a, b) {
        return a + b;
    };

    exports.minus = function (a, b) {
        return a - b;
    };
    
    exports.age = 18;
    
    MJAppId = [NSBundle mainBundle].bundleIdentifier;
    
    exports.RootVc = function () {
        return UIApp.keyWindow.rootViewController;
    };
    
    exports.DocPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];
    
})(exports);
</code></pre>
<p>然后通过<code>iFunBox</code>拷贝到手机上 <code>/usr/lib/cycript0.9/</code>目录下</p>
<p>使用的时候直接在<code>@import test</code>后，直接输入<code>test.sum(1, 10)</code>就行了(但是这样的调用方式适用于 开头带<code>exports</code>的函数形式,如果开头不带<code>exports</code>就是属于全局的函数了直接调用<code>AppId</code>即可)</p>
<blockquote>
<p>注意如果你的<code>test.cy</code>文件不再cycript0.9这个目录下的话需要导入的时候加上，比如 <code>@import com.mj.test</code> 这样才会生效</p>
</blockquote>
<p><strong><a href="https://github.com/CoderMJLee/mjcript">MJ封装的库</a></strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS脱壳]]></title>
        <id>https://dargonlee.github.io/post/ios-tuo-ke/</id>
        <link href="https://dargonlee.github.io/post/ios-tuo-ke/">
        </link>
        <updated>2020-07-25T12:36:35.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="加壳">加壳</h4>
<blockquote>
<p>利用特殊的算法，对可执行文件的编码方式进行改变（比如压缩、加密），以达到保护程序代码的作用</p>
</blockquote>
<ul>
<li>
<p>加壳前：<br>
就是简单的可执行文件，执行之后把可执行文件装载在内存中</p>
</li>
<li>
<p>加壳后：<br>
可执行文件已经被加密了，不能直接用了。需要先加载到内存中，需要解密之后才能用。</p>
</li>
</ul>
<h4 id="脱壳">脱壳</h4>
<blockquote>
<p>摘掉壳程序，将未加密可执行文件还原出来</p>
</blockquote>
<ul>
<li>硬脱壳（iOS常用）</li>
</ul>
<blockquote>
<p>直接进行一个解密操作，不需要运行APP</p>
</blockquote>
<ul>
<li>动态脱壳</li>
</ul>
<blockquote>
<p>执行要脱壳的APP，将已经解密后的程序，从内存中直接拷贝出来。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h4 id="加壳">加壳</h4>
<blockquote>
<p>利用特殊的算法，对可执行文件的编码方式进行改变（比如压缩、加密），以达到保护程序代码的作用</p>
</blockquote>
<ul>
<li>
<p>加壳前：<br>
就是简单的可执行文件，执行之后把可执行文件装载在内存中</p>
</li>
<li>
<p>加壳后：<br>
可执行文件已经被加密了，不能直接用了。需要先加载到内存中，需要解密之后才能用。</p>
</li>
</ul>
<h4 id="脱壳">脱壳</h4>
<blockquote>
<p>摘掉壳程序，将未加密可执行文件还原出来</p>
</blockquote>
<ul>
<li>硬脱壳（iOS常用）</li>
</ul>
<blockquote>
<p>直接进行一个解密操作，不需要运行APP</p>
</blockquote>
<ul>
<li>动态脱壳</li>
</ul>
<blockquote>
<p>执行要脱壳的APP，将已经解密后的程序，从内存中直接拷贝出来。</p>
</blockquote>
<!-- more -->
<h5 id="ios中脱壳工具">iOS中脱壳工具</h5>
<ul>
<li>Cluth：https://github.com/KJCracks/Cluth</li>
<li>dumpdecrypted: https://github.com/stefanesser/dumpdecrypted</li>
</ul>
<h5 id="判断可执行文件是否加密">判断可执行文件是否加密</h5>
<pre><code class="language-shell">otool -l 文件路径 | grep crpyt 
</code></pre>
<p>如果cryptid 为1 是加密的 0是没有加密的</p>
<h4 id="cluth脱壳">Cluth脱壳</h4>
<blockquote>
<p>下载最新版本：https://github.com/KJCracks/Cluth</p>
</blockquote>
<p>把下载好的文件直接拷贝到手机的这个路径下<code>usr/bin</code></p>
<p>然后在连接手机端的命令窗口上输入：<code>Cluth脱壳</code>就行了，如果报错没有权限的话可以执行下面命令给这个执行文件授权</p>
<pre><code class="language-shell">chmod +x /usr/bin/Cluth
</code></pre>
<ul>
<li>列出手机上安装的应用：<code>Cluth -i</code>（只列出被加密的应用程序）</li>
<li>脱壳：<code>Cluth -d 应用的bundleId</code>（会输出一个脱壳后的ipa文件路径，把ipa文件拷贝到电脑上就行了）</li>
</ul>
<h4 id="dumpdecrypted脱壳">dumpdecrypted脱壳</h4>
<blockquote>
<p>下载最新版本：https://github.com/stefanesser/dumpdecrypted</p>
</blockquote>
<ul>
<li>把下载好的文件 执行<code>make</code>指令编译出<code>dumpdecrypted.dylib</code>动态库</li>
<li>将编译的动态库文件拷贝到<code>var/root</code>目录下</li>
<li>连接手机的终端进入动态库所在的目录</li>
<li>使用环境变量<code>DYLD_INSERT_LIBRARIES</code>将<code>dylib</code>注入到要脱壳的可执行文件中（可执行文件的路径可以先打开APP然后执行<code>ps -A</code> 来查看）</li>
</ul>
<pre><code class="language-shell">root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib 要脱壳的可执行文件路径（/var/Container/Bundle/Application/xxxx/yy.app/yy）
</code></pre>
<p>yy.decrypted 文件就是脱壳后的文件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[逆向常用工具]]></title>
        <id>https://dargonlee.github.io/post/ni-xiang-chang-yong-gong-ju/</id>
        <link href="https://dargonlee.github.io/post/ni-xiang-chang-yong-gong-ju/">
        </link>
        <updated>2020-07-25T12:36:12.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="逆向app思路">逆向APP思路</h4>
<ul>
<li>
<p>界面分析（Cycript、Reveal）</p>
</li>
<li>
<p>代码分析（对Mach-o文件分析）<br>
MachOView、class-dump、Hopper Disassembler、ida等</p>
</li>
<li>
<p>动态调试<br>
对运行的App进行代码调试（debugserver、LLDB）</p>
</li>
<li>
<p>代码编写<br>
注入代码到App中，必要时可能会重签名ipa</p>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h4 id="逆向app思路">逆向APP思路</h4>
<ul>
<li>
<p>界面分析（Cycript、Reveal）</p>
</li>
<li>
<p>代码分析（对Mach-o文件分析）<br>
MachOView、class-dump、Hopper Disassembler、ida等</p>
</li>
<li>
<p>动态调试<br>
对运行的App进行代码调试（debugserver、LLDB）</p>
</li>
<li>
<p>代码编写<br>
注入代码到App中，必要时可能会重签名ipa</p>
</li>
</ul>
<!-- more -->
<h4 id="class-dump的安装">class-dump的安装</h4>
<ul>
<li>先去下载 <code>class-dump</code>的可执行文件</li>
<li>然后把它复制到系统的<code>/usr/local/bin</code>目录下</li>
<li>执行<code>class-dump -H mach-o文件路径 -o 头文件存放路径</code></li>
</ul>
<h4 id="抽取系统框架的可执行文件">抽取系统框架的可执行文件</h4>
<ul>
<li>找到系统的动态库缓存文件 <code>Device/System/Libary/Caches/com.apple.dyld</code></li>
<li>里面会有两个文件一个<code>dyld_shared_cache_arm64</code>的、一个是<code>dyld_shared_cache_armv7s</code> 这里面装的分别是不同架构的系统框架可执行文件</li>
<li>但是文件太大，我们需要通过一个解析器去给解析处理各个framework的可执行文件</li>
<li>去找到<code>dyld</code>的源码<code>https://opensource.apple.com/tarballs/dyld/</code> 找到最新版本的下载下来</li>
<li>找到工程中<code>launch-cache/dsc_extractor.app</code>文件用<code>clang++</code>编译器编译成可执行文件（只要int main函数里面的东西，此函数上面的内容都可以不要）</li>
<li><code>clang++ -o dsc_extractor dsc_extractor.app</code> 会生成<code>dsc_extractor</code>可执行文件</li>
<li><code>./dsc_extractor dyld_shared_cache_armv7s armv7s</code> 回车执行 就会抽取包含在系统共享文件中的系统库可执行文件</li>
</ul>
<h4 id="mach-o的结构">Mach-o的结构</h4>
<ul>
<li><code>file</code>:查看Mach-o文件的结构</li>
</ul>
<pre><code class="language-shell">file 文件的路径
</code></pre>
<ul>
<li><code>otool</code>:查看Mach-o特定部分和段的内容</li>
</ul>
<pre><code class="language-shell">打印Mach-o文件里面链接了哪些库：otool -L 文件地址
打印Mach-o文件头信息：otool -f 文件地址
</code></pre>
<ul>
<li><code>lipo</code>:常用于多架构Mach-o文件的处理</li>
</ul>
<pre><code class="language-shell">查看架构信息：lipo -info 文件路径
导出特定架构：lipo 文件路径 -thin 架构类型 -output 输出文件路径
合并多种架构：lipo 文件路径1 文件路径2 -output 输出文件路径 
</code></pre>
<h4 id="配置reveal环境">配置Reveal环境</h4>
<ul>
<li>先安装<code>Reveal Loader</code> 插件</li>
<li>然后把Reveal的framework里的RevealServer替换到手里<code>Libary/RHReveal/目录下</code></li>
<li>killall SpringBoard 重启</li>
</ul>
<h4 id="theos-安装">theos 安装</h4>
<ul>
<li>安装签名工具<code>brew install ldid</code></li>
<li>修改环境变量</li>
</ul>
<pre><code class="language-shell">vim ~/.zshrc 或者 vim ~/.bash_profile
export THEOS=~/theos
export PATH=$THEOS/bin:$PATH
</code></pre>
<p>执行<code>source .zshrc</code>这样环境变量才会生效或者重启终端</p>
<ul>
<li>下载theos</li>
</ul>
<pre><code class="language-shell">git clone --recursive https://github.com/theos/theos.git $THEOS // --recursive递归下载
</code></pre>
<ul>
<li>新建项目</li>
</ul>
<pre><code class="language-shell">nic.pl
</code></pre>
<h4 id="theos-tweak的实现过程">theos-tweak的实现过程</h4>
<ul>
<li>编写tweak代码</li>
<li>make 编译Tweak代码为动态库（*.dylib）</li>
<li>make package 将dylib文件打包为deb文件</li>
<li>make install 将deb文件传送到手机，通过Cydia安装deb文件</li>
<li>插件将会安装到/Libary/MobileSubstrate/DynamicLibraries文件夹中</li>
<li>*.dylib为编译后的Tweak代码</li>
<li>*.plist存放着需要Hook AppId</li>
<li>当打开app时 Cydia Substrate 会让App加载对应的dylib</li>
<li>修改App内存中的代码逻辑，去执行dylib中的函数代码</li>
</ul>
<blockquote>
<p>所以theos的tweak并不会对app原来的可执行文件进行修改，仅仅是修改了内存中代码逻辑。<br>
如果希望卸载插件，只需要将/Libary/MobileSubstrate/DynamicLibraries中对应的dylib和plist文件删除即可</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS命令行工具开发]]></title>
        <id>https://dargonlee.github.io/post/ios-ming-ling-xing-gong-ju-kai-fa/</id>
        <link href="https://dargonlee.github.io/post/ios-ming-ling-xing-gong-ju-kai-fa/">
        </link>
        <updated>2020-07-25T12:35:47.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="本质">本质</h4>
<ul>
<li>可执行文件</li>
<li>跟App内部的可执行文件差不多</li>
<li>只不过没有UI界面</li>
<li>需要可执行权限</li>
</ul>
<h5 id="新建一个ios项目">新建一个iOS项目</h5>
<ul>
<li>把<code>main.m</code>文件的改为<code>return 0；</code></li>
<li>然后在代码里面写自己代码就可了</li>
<li>写完代码后，真机编译<code>.app</code>文件，取出里面的可执行文件</li>
<li>真机编译的时候记得处理下签名认证</li>
<li>然后拷贝到<code>/usr/bin</code>目录下</li>
<li>授权可执行权限<code>chomd +x /usr/bin/xxx</code></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h4 id="本质">本质</h4>
<ul>
<li>可执行文件</li>
<li>跟App内部的可执行文件差不多</li>
<li>只不过没有UI界面</li>
<li>需要可执行权限</li>
</ul>
<h5 id="新建一个ios项目">新建一个iOS项目</h5>
<ul>
<li>把<code>main.m</code>文件的改为<code>return 0；</code></li>
<li>然后在代码里面写自己代码就可了</li>
<li>写完代码后，真机编译<code>.app</code>文件，取出里面的可执行文件</li>
<li>真机编译的时候记得处理下签名认证</li>
<li>然后拷贝到<code>/usr/bin</code>目录下</li>
<li>授权可执行权限<code>chomd +x /usr/bin/xxx</code></li>
</ul>
<!-- more -->
<pre><code class="language-swift">#import &lt;mach-o/fat.h&gt;
#import &lt;mach-o/loader.h&gt;


if (argv[1] == @&quot;-l&quot;) {
            
}
NSString *path = @&quot;&quot;;// 可执行文件的路径
NSFileHandle *handle = [NSFileHandle fileHandleForReadingAtPath:path];
// 读取最前面的4个字节(magic,number)
int lenght = sizeof(uint32_t);
NSData *magicData = [handle readDataOfLength:lenght];
//魔数用来标识文件类型
uint32_t magicNumber;
[magicData getBytes:&amp;magicNumber length:lenght];
if (magicNumber == FAT_CIGAM || magicNumber == FAT_MAGIC) { // 胖二进制文件
    
}else if (magicNumber == MH_CIGAM || magicNumber == MH_MAGIC) { // 非arm64文件
    
}else if (magicNumber == MH_CIGAM_64 || magicNumber == MH_MAGIC_64) { // arm64文件
    
}
[handle closeFile];
</code></pre>
<h5 id="由于个人签名有效期有限">由于个人签名有效期有限</h5>
<ul>
<li>我们可以换成手动签名的方式</li>
</ul>
<h5 id="签名给可执行文件一定的权限让他可以访问其他app的可执行文件">签名给可执行文件一定的权限，让他可以访问其他App的可执行文件</h5>
<ul>
<li>使用<code>ldid导出某一个可执行文件的权限</code></li>
</ul>
<blockquote>
<p>TestCL为可执行文件</p>
</blockquote>
<pre><code class="language-shell">ldid -e TestCL &gt; TestCL.entitlements
</code></pre>
<ul>
<li>重新签上权限(先修改TestCL.entitlements里面的值)</li>
</ul>
<pre><code class="language-shell">ldid -STestCl.entitlements TestCL
</code></pre>
<blockquote>
<p>把自己写的工具的可执行文件权限提升，先把<code>SpringBoard</code>的可执行文件导出来，然后把它的权限导出来，然后把它的权限签到自己写可执行文件上就行了</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tweak开发手册]]></title>
        <id>https://dargonlee.github.io/post/tweak-kai-fa-shou-ce/</id>
        <link href="https://dargonlee.github.io/post/tweak-kai-fa-shou-ce/">
        </link>
        <updated>2020-07-25T12:35:16.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="tweak怎么多文件开发">tweak怎么多文件开发</h4>
<blockquote>
<p>一般来说我们开发tweak代码都是在<code>Tweak.xm</code>文件里面写代码，但是代码量小的话还好，一旦代码多了的话，代码开发起来就比较费劲。这个时候我们就可以使用多文件进行开发。</p>
</blockquote>
<ul>
<li>可以在<code>Tweak.xm</code>所在的目录下新建一个<code>src</code>文件夹，里面放你写的OC源代码。</li>
<li>然后在<code>Tweak.xm</code>文件是使用的地方<code>#import &quot;Person&quot;</code>导入就可以用了</li>
<li>但是在编译的时候你会发现报错，因为你写的<code>.m</code>文件没有参与编译</li>
<li>所以我们需要在<code>Makefile</code>里面的tweak_wechat_FILES = Tweak.xm指定下要参与编译的<code>.m</code>文件</li>
</ul>
<pre><code>tweak_wechat_FILES = Tweak.xm src/Persom.m // 记住多个文件以空格分割
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h4 id="tweak怎么多文件开发">tweak怎么多文件开发</h4>
<blockquote>
<p>一般来说我们开发tweak代码都是在<code>Tweak.xm</code>文件里面写代码，但是代码量小的话还好，一旦代码多了的话，代码开发起来就比较费劲。这个时候我们就可以使用多文件进行开发。</p>
</blockquote>
<ul>
<li>可以在<code>Tweak.xm</code>所在的目录下新建一个<code>src</code>文件夹，里面放你写的OC源代码。</li>
<li>然后在<code>Tweak.xm</code>文件是使用的地方<code>#import &quot;Person&quot;</code>导入就可以用了</li>
<li>但是在编译的时候你会发现报错，因为你写的<code>.m</code>文件没有参与编译</li>
<li>所以我们需要在<code>Makefile</code>里面的tweak_wechat_FILES = Tweak.xm指定下要参与编译的<code>.m</code>文件</li>
</ul>
<pre><code>tweak_wechat_FILES = Tweak.xm src/Persom.m // 记住多个文件以空格分割
</code></pre>
<!-- more -->
<ul>
<li>这样配置了之后，我们就可以执行<code>make</code> 进行编译了</li>
<li>如果你有一个目录下有很多文件，按上面写法就会很麻烦，还好tweak支持通配符</li>
</ul>
<pre><code>tweak_wechat_FILES = Tweak.xm src/*.m // 记住多个文件以空格分割
</code></pre>
<p><strong>这样就可以把某个文件夹下的多个文件参与编译的，记住tweak不支持文件夹的通配符</strong></p>
<blockquote>
<p>注意如果你新建了很多目录结构，要保证编译的文件能找到，导入的文件也能找到。</p>
</blockquote>
<h4 id="theos-tweak加载资源">theos-tweak加载资源</h4>
<ul>
<li>一般开发的tweak文件中有一个<code>layout</code>文件夹里面对应的什么目录结构，就安装到手机对应的目录结构中</li>
<li>比如本地文件目录结构<code>layout/Libary/PreferenceLoader/Preferences/MJWeChat/xx.png</code></li>
<li>这样手机就会把<code>MJWeChat</code>文件夹中的图片资源或者其他资源复制到手机的<code>Libary/PreferenceLoader/Preferences/</code>目录中</li>
<li>然后在tweak中编写代码加载文件资源的时候需要通过路径取资源文件<code>/Libary/PreferenceLoader/Preferences/MJWeChat/xx.png</code></li>
<li>当然我们的资源也不一定非得放到<code>/Libary/PreferenceLoader/Preferences/</code>文件夹下，也可以放到<code>/Libary/Caches/MJWeChat</code>这个目录下</li>
</ul>
<h4 id="安装release版本">安装<code>release</code>版本</h4>
<pre><code>make package // 为debug版本
make package debug=0 // 为release版本
</code></pre>
<h4 id="logos语法">Logos语法</h4>
<ul>
<li>%hook %end hook一个类的开始和结束</li>
<li>%log 打印方法调用详情 （可以通过Xcode - Window - Devices and Simulators 查看日志）</li>
<li>HBDebugLog: 跟NSLog类似</li>
<li>%new 添加一个新方法</li>
</ul>
<pre><code>@interface xxx
- (void)test;
@end


%hook XMGAdView

%new
- (void)test  
{// 新增的方法需要声明
    
}

- (id)init
{
    [self test];
}

%end
</code></pre>
<ul>
<li>%c(className):生成一个class对象，比如（%c(NSObject)）类似与NSStringFromClass() objc_getClass()</li>
<li>%orig: 函数原来的逻辑</li>
<li>%ctor: 在加载动态库时调用,做一些初始化操作</li>
</ul>
<pre><code>%ctor {
    
}
</code></pre>
<ul>
<li>%dtor: 在程序即将退出时调用，做一些结尾操作</li>
</ul>
<pre><code>%dtor {
    
}
</code></pre>
<ul>
<li>logify.pl: 可以将一个头文件快速转换成包含打印信息的xm文件</li>
</ul>
<pre><code>logify.pl xx.h &gt; xx.xm
</code></pre>
<p><strong>logify.pl使用注意</strong></p>
<ul>
<li><code>logify.pl生成的文件，有很多事编译不过的，需要进行一些处理</code></li>
<li>删除<code>__weak</code></li>
<li>删除<code>inout</code></li>
<li>删除协议，比如<code>&lt;XXTestDelegate&gt;</code></li>
<li>或者声明一下协议信息<code>@protocol XXTestDelegate</code></li>
<li>删除<code>-(void).cxx_destrut{%log; %orig;}</code></li>
<li>删除<code>HBLogDebug(@&quot;=0x%x,(unsigned int)r&quot;)</code></li>
<li>替换类型为void，比如将<code>XXPersion替换为void</code></li>
<li>或者声明一下类信息</li>
</ul>
<pre><code>@interface XXPerson : NSObject
@end
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS 动态调试]]></title>
        <id>https://dargonlee.github.io/post/ios-dong-tai-diao-shi/</id>
        <link href="https://dargonlee.github.io/post/ios-dong-tai-diao-shi/">
        </link>
        <updated>2020-07-25T12:34:45.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="什么是动态调试">什么是动态调试？</h4>
<blockquote>
<p>将程序运行起来，通过下断电、打印等方式。查看参数、返回值、函数调用流程等。</p>
</blockquote>
<h4 id="xcode的动态调试原理">Xcode的动态调试原理</h4>
<ul>
<li>
<p>关于 <code>GCC</code> <code>LLVM</code> <code>GDB</code> <code>LLDB</code></p>
<ul>
<li>Xcode 的编译器发展历程：GCC -&gt; LLVM</li>
<li>Xcode 的调试器发展历程：GDB -&gt; LLDB</li>
</ul>
</li>
<li>
<p>debugserver一开始存放在Mac上的Xcode里面</p>
</li>
<li>
<p>当Xcode识别手机设备的时候，Xcode会自动将debugserver安装到手机上</p>
</li>
<li>
<p>Xcode的调试局限性：一般只能安装通过Xcode安装的APP</p>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h4 id="什么是动态调试">什么是动态调试？</h4>
<blockquote>
<p>将程序运行起来，通过下断电、打印等方式。查看参数、返回值、函数调用流程等。</p>
</blockquote>
<h4 id="xcode的动态调试原理">Xcode的动态调试原理</h4>
<ul>
<li>
<p>关于 <code>GCC</code> <code>LLVM</code> <code>GDB</code> <code>LLDB</code></p>
<ul>
<li>Xcode 的编译器发展历程：GCC -&gt; LLVM</li>
<li>Xcode 的调试器发展历程：GDB -&gt; LLDB</li>
</ul>
</li>
<li>
<p>debugserver一开始存放在Mac上的Xcode里面</p>
</li>
<li>
<p>当Xcode识别手机设备的时候，Xcode会自动将debugserver安装到手机上</p>
</li>
<li>
<p>Xcode的调试局限性：一般只能安装通过Xcode安装的APP</p>
</li>
</ul>
<!-- more -->
<h4 id="动态调试任意app">动态调试任意APP</h4>
<h6 id="debugserver的权限问题">debugserver的权限问题</h6>
<ul>
<li>
<p>默认情况下<code>/Developer/usr/bin/debugserver</code>缺少一定的权限，只能调试通过Xcode安装的APP，无法调试其他APP 比如App Store上的APP</p>
</li>
<li>
<p>如果希望调试其他APP，需要对debugserver进行重新签名，签上2个调试相关的权限</p>
</li>
</ul>
<p><code>get-task-allow</code> 和 <code>task_for_pid-allow</code></p>
<h6 id="如何给debugserver签上权限">如何给debugserver签上权限</h6>
<ul>
<li>iPhone上的<code>/Developer</code>的目录是只读的，无法直接对<code>/Developer/usr/bin/debugserver</code>文件签名，需要先把debugserver文件复制到Mac上</li>
<li>通过ldid命令导出debugserver文件现在的权限</li>
</ul>
<pre><code class="language-shell">ldid -e debugserver &gt; debugserver.entitlements // 会生成一个debugserver.entitlements文件
</code></pre>
<ul>
<li>在<code>debugserver.entitlements</code>文件开始编辑点击加号 添加 <code>get-task-allow</code> 和 <code>task_for_pid-allow</code> 并设置值为YES</li>
<li>编辑好后保存再重新签名</li>
</ul>
<pre><code class="language-shell">ldid -Sdebugserver.entitlements debugserver // 然后debugserver的权限就加上去了
</code></pre>
<ul>
<li><strong>注意</strong>由于iPhone上的<code>/Developer</code>的目录是只读的，所以你签好文件不能直接赋值到手机上</li>
<li>可以直接把它放到<code>usr/bin</code>目录下，可以直接使用</li>
</ul>
<pre><code class="language-shell">chmod +x /usr/bin/debugserver //给执行权限
</code></pre>
<ul>
<li>然后在手机终端就可以直接使用了</li>
</ul>
<h6 id="让debugserver附加到某个app进程中">让debugserver附加到某个APP进程中</h6>
<p>先使用ssh登录到手机root用户然后执行下面命令</p>
<pre><code class="language-shell">debugserver *:端口号 -a 进程
debugserver *:10011 -a WeChat
</code></pre>
<ul>
<li><code>*:端口号</code>：使用iPhone的某个端口启动debugserver服务（只要不是保留端口就行）</li>
<li><code>-a</code>:进程输入APP的进程信息（进程ID或者进程名称）</li>
</ul>
<h6 id="在mac上启动lldb远程连接iphone上的debugserver服务">在Mac上启动LLDB，远程连接iPhone上的debugserver服务</h6>
<ul>
<li>启动LLDB</li>
</ul>
<pre><code class="language-shell">lldb
</code></pre>
<ul>
<li>连接debugserver服务</li>
</ul>
<pre><code class="language-shell">(lldb) process connect connect://手机IP地址:debugserver服务的端口号
(lldb) process connect connect://10.1.125.100:10011
</code></pre>
<ul>
<li>如果是通过端口转发的方式连接手机的话通过下面方式连接<br>
转发端口</li>
</ul>
<pre><code class="language-shell">iproxy 22:2222 10011:9999 // 这样就转发了手机上的两个端口
</code></pre>
<p>然后登录到手机</p>
<pre><code class="language-shell">ssh -p 2222 root@localhost
</code></pre>
<p>转发debugserver端口</p>
<pre><code class="language-shell">debugserver *:10011 -a WeChat
</code></pre>
<p>之后再使用lldb连接debugserver服务器</p>
<pre><code class="language-shell">(lldb) process connect connect://localhost:10011
</code></pre>
<ul>
<li>使用LLDB的<code>c</code>命令让程序先继续运行</li>
</ul>
<pre><code class="language-shell">(lldb)  c
</code></pre>
<p>然后就监听成功了。</p>
<h6 id="通过debugserver启动app">通过debugserver启动APP</h6>
<pre><code class="language-shell">debugserver -x auto*:端口号 APP可执行文件路径
</code></pre>
<h6 id="通过xcode直接调试任意app">通过Xcode直接调试任意App</h6>
<ul>
<li>先安装 <code>AppSync Unified</code> 这个插件【主要作用屏蔽签名】</li>
</ul>
<p>安装好了之后会自动启动，这样没签名的应用也可以安装手机上</p>
<ul>
<li>然后USB连接手机 终端登录手机 <code>ps -A</code>找到要调试的可执行文件名比如<code>AppStore</code></li>
<li>之后打开Xcode -&gt; Debug -&gt; Attach process by PID or Name -&gt; 输入<code>AppStore</code> -&gt; 点击<code>Attach</code></li>
<li>然后打开手机上的<code>AppStore</code>应用 就可以调试了</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用LLDB指令]]></title>
        <id>https://dargonlee.github.io/post/chang-yong-lldb-zhi-ling/</id>
        <link href="https://dargonlee.github.io/post/chang-yong-lldb-zhi-ling/">
        </link>
        <updated>2020-07-25T12:02:12.000Z</updated>
        <summary type="html"><![CDATA[<h5 id="指令格式">指令格式</h5>
<pre><code>&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;]...] &lt;actions&gt; [-options [options value]] [argument[argument]...]
</code></pre>
<ul>
<li><command> 命令</li>
<li><subcommand>子命令</li>
<li><actions>命令操作</li>
<li><options>命令选项</li>
<li><argument> 命令参数</li>
</ul>
<p>比如给<code>test</code>函数设置断点</p>
]]></summary>
        <content type="html"><![CDATA[<h5 id="指令格式">指令格式</h5>
<pre><code>&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;]...] &lt;actions&gt; [-options [options value]] [argument[argument]...]
</code></pre>
<ul>
<li><command> 命令</li>
<li><subcommand>子命令</li>
<li><actions>命令操作</li>
<li><options>命令选项</li>
<li><argument> 命令参数</li>
</ul>
<p>比如给<code>test</code>函数设置断点</p>
<!-- more -->
<pre><code>breakpoint set -n test
</code></pre>
<ul>
<li>breakpoint是<command></li>
<li>set是<actions></li>
<li>-n是<options></li>
<li>test是<argument></li>
</ul>
<h5 id="help指令">help指令</h5>
<blockquote>
<p>查看指令用法</p>
</blockquote>
<p>比如</p>
<pre><code>help breakpoint 
</code></pre>
<pre><code>help breakpoint set
</code></pre>
<h5 id="expression-cmd-options-expr">expression <cmd-options>--<expr></h5>
<blockquote>
<p>执行一个表达式</p>
</blockquote>
<ul>
<li><cmd-options> 命令行选项</li>
<li>-- 命令选项结束符 表示所有的命令选项已经设置完毕 如果没有命令选项，--可以省略</li>
<li><expr> 需要执行的表达式</li>
</ul>
<pre><code>expression self.view.backgroundColor = [UIColor redColor]
</code></pre>
<ul>
<li>expression、expression--和指令print、p、call的效果一样</li>
<li>expression -O --和po指令效果一样</li>
</ul>
<h5 id="thread-backtrace">thread backtrace</h5>
<ul>
<li>打印线程的堆栈信息</li>
<li>和指令bt效果一样</li>
</ul>
<h5 id="thread-return-expr">thread return [<expr>]</h5>
<ul>
<li>让函数直接返回某一个值，不会执行断点后面的代码</li>
</ul>
<h5 id="frame-variable-variable-name">frame variable [<variable-name>]</h5>
<ul>
<li>打印当前栈帧的变量</li>
</ul>
<h5 id="thread-continue-continue-c-程序继续运行">thread continue 、continue、c ：程序继续运行</h5>
<h5 id="thread-step-over-next-n-单步运行-把子函数当做整体一步执行">thread step-over 、next、n ：单步运行、把子函数当做整体一步执行</h5>
<h5 id="thread-step-in-step-s-单步运行-遇到子函数进入到子函数中">thread step-in 、step、s ：单步运行、遇到子函数进入到子函数中</h5>
<h5 id="thread-step-out-finish直接执行完当前函数所有代码-返回到上一个函数">thread step-out 、finish：直接执行完当前函数所有代码、返回到上一个函数</h5>
<h5 id="si-ni和s-n类似">si、ni和s、n类似</h5>
<ul>
<li>s、n是源码级别的</li>
<li>si、ni是汇编指令级别的</li>
</ul>
<h5 id="breakpoint-set-设置断点">breakpoint set 设置断点</h5>
<ul>
<li>breakpoint set -a 函数地址</li>
</ul>
<pre><code>
</code></pre>
<ul>
<li>breakpoint set -n 函数名称</li>
</ul>
<pre><code>breakpoint set -n test

breakpoint set -n  touchBegan:withEvent:

breakpoint set -n &quot;-[ViewController touchBegan:withEvent:]&quot;
</code></pre>
<p><strong>breakpoint set -n test 简写为 br set -n test</strong></p>
<ul>
<li>
<p>breakpoint set -r 正则表达式</p>
</li>
<li>
<p>breakpoint set -s 动态库 -n 函数名</p>
</li>
<li>
<p>breakpoint list 列出所有断点</p>
</li>
<li>
<p>breakpoint disable 断点编号 ： 禁用断点</p>
</li>
<li>
<p>breakpoint enable 断点编号 ： 启用断点</p>
</li>
<li>
<p>breakpoint delete 断点编号 ： 删除断点</p>
</li>
<li>
<p>breakpoint command 断点编号 ： 给断点预先设置需要执行的命令，到触发断点时，就会按顺序执行</p>
</li>
<li>
<p>breakpoint command list 断点编号：查看某个断点设置的命令</p>
</li>
<li>
<p>breakpoint command delete 断点编号：删除某个断点设置的命令</p>
</li>
</ul>
<h5 id="内存断点">内存断点</h5>
<blockquote>
<p>在内存数据发生改变的时候触发 <code>watchpoint set variable 变量</code></p>
</blockquote>
<pre><code>watchpoint set variable self-&gt;age
</code></pre>
<ul>
<li><code>watchpoint set expression 地址</code></li>
</ul>
<pre><code>watchpoint set variable &amp;(self-&gt;_age)
</code></pre>
<ul>
<li>watchpoint list</li>
<li>watchpoint disable 断点编号</li>
<li>watchpoint enable 断点编号</li>
<li>watchpoint delete 断点编号</li>
<li>watchpoint command add 断点编号</li>
<li>watchpoint command list 断点编号</li>
<li>watchpoint command delete 断点编号</li>
</ul>
<h5 id="image-lookup">image lookup</h5>
<ul>
<li>image lookup -t 类型：查找某个类型的信息</li>
<li>image lookup -a 地址：根据内存地址查找在模块中的位置</li>
<li>image lookup -n 符号或者函数名：查找某个符号或者函数的位置</li>
<li>image list 列出所加载模块的信息</li>
<li>image list -o -f 打印出模块的偏移地址、全路径</li>
</ul>
<pre><code> image list -o -f | grep WeChat
</code></pre>
<h5 id="寄存器">寄存器</h5>
<ul>
<li>memory read 读取所有寄存器的值</li>
<li>memory write 寄存器 值  给某个寄存器写入值</li>
<li>po $x0:打印方法调用者</li>
<li>x/s $x1: 打印方法名</li>
<li>po $x2:打印参数（以此类推，x3 x4也可能是参数）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 调试技巧]]></title>
        <id>https://dargonlee.github.io/post/javascript-diao-shi-ji-qiao/</id>
        <link href="https://dargonlee.github.io/post/javascript-diao-shi-ji-qiao/">
        </link>
        <updated>2020-03-16T02:56:06.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>自动断点<br>
有时候在执行 JavaScript 代码的时候，可能来不及设置断点，代码就被执行了，其实可以通过在代码中写上 debugger（代码中第 8 行），让代码执行到 debugger 的位置自动暂停。</li>
</ol>
<pre><code class="language-js">function b() {
    console.log('enter b');
    debugger;
}
</code></pre>
<ol start="2">
<li>打印调用堆栈<br>
可以通过调试面板查看当前代码的调用堆栈，也可以通过 console.trace() 打印函数调用堆栈</li>
</ol>
<pre><code class="language-js">function c() {
    console.log('enter c');
    console.trace();
}
</code></pre>
<ol start="3">
<li>以表格的方式打印对象<br>
下面是一个对象，可以通过 console.table( obj ) 来打印这个对象。</li>
</ol>
<pre><code class="language-js">
let pkg = {
    &quot;name&quot;: &quot;mini_tools&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;description&quot;: &quot;&quot;,
    &quot;main&quot;: &quot;index.js&quot;,
    &quot;dependencies&quot;: {
        &quot;jquery&quot;: &quot;^1.12.4&quot;
    },
    &quot;devDependencies&quot;: {},
    &quot;scripts&quot;: {
        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
    },
    &quot;author&quot;: &quot;&quot;,
    &quot;license&quot;: &quot;ISC&quot;
};

console.table(pkg);
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dargonlee.github.io/post-images/1584327572021.webp" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>