<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dargonlee.github.io</id>
    <title>七里田间的守望者</title>
    <updated>2020-11-30T13:09:43.367Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dargonlee.github.io"/>
    <link rel="self" href="https://dargonlee.github.io/atom.xml"/>
    <subtitle>我不在乎是悲伤的离别还是不痛快的离别，只要是离开一个地方，我总希望离开的时候自己心中有数。</subtitle>
    <logo>https://dargonlee.github.io/images/avatar.png</logo>
    <icon>https://dargonlee.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 七里田间的守望者</rights>
    <entry>
        <title type="html"><![CDATA[ssh连接手机的方式]]></title>
        <id>https://dargonlee.github.io/post/ssh-lian-jie-shou-ji-de-fang-shi/</id>
        <link href="https://dargonlee.github.io/post/ssh-lian-jie-shou-ji-de-fang-shi/">
        </link>
        <updated>2020-07-25T12:38:51.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="通过usb连接iphone">通过USB连接iPhone</h4>
<ul>
<li>用<code>iproxy</code> 转发端口</li>
</ul>
<pre><code class="language-shell">iproxy 2222 22 进行端口转发
</code></pre>
<p>想要支持多个ssh连接的话 需要添加参数 -t<br>
如果加<code>-t</code> 不行的 请使用<code>usbmuxd</code>的1.0.8版本</p>
<p>如果是1.0.8版本的需要执行下面的命令进行端口转发</p>
<pre><code class="language-shell">python tcprelay.py -t 22:2222
</code></pre>
<p>这里的<code>-t</code>就是支持多个ssh连接的参数</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="通过usb连接iphone">通过USB连接iPhone</h4>
<ul>
<li>用<code>iproxy</code> 转发端口</li>
</ul>
<pre><code class="language-shell">iproxy 2222 22 进行端口转发
</code></pre>
<p>想要支持多个ssh连接的话 需要添加参数 -t<br>
如果加<code>-t</code> 不行的 请使用<code>usbmuxd</code>的1.0.8版本</p>
<p>如果是1.0.8版本的需要执行下面的命令进行端口转发</p>
<pre><code class="language-shell">python tcprelay.py -t 22:2222
</code></pre>
<p>这里的<code>-t</code>就是支持多个ssh连接的参数</p>
<!-- more -->
<p>然后连接好USB进行登录手机</p>
<pre><code class="language-shell">ssh -p 2222 root@127.0.0.1
或者
ssh -p 2222 root@localhost
</code></pre>
<blockquote>
<p>上面代码意义在于将iPhone的22端口（ssh端口）映射到Mac本地的2222端口</p>
</blockquote>
<h4 id="使用scp拷贝文件到手机的某个目录">使用scp拷贝文件到手机的某个目录</h4>
<ul>
<li>通过WiFi的方式</li>
</ul>
<pre><code class="language-shell">scp 本地文件路径 roo@192.168.1.2:手机的目录
</code></pre>
<ul>
<li>通过端口转发的方式</li>
</ul>
<pre><code class="language-shell">scp -P 2222 本地文件路径 root@localhost:手机的目录
</code></pre>
<p><em><strong>注意：</strong></em></p>
<blockquote>
<p>执行脚本的方式有三种<br>
分别为<code>sh xx.sh</code> <code>base xx.sh</code> <code>source xx.sh</code><br>
这里的 <code>sh xx.sh</code> <code>base xx.sh</code> 都是系统会开一个子进程去执行命令，执行完之后还是会返回到父进程的执行环境中。</p>
</blockquote>
<p><code>source xx.sh</code> 和 <code>. xx.sh</code> 一样的</p>
<p>比如 脚本内部有个命令 <code>cd xx/yy</code>的一个目录，<br>
用<code>sh xx.sh</code> <code>base xx.sh</code>执行完毕之后 你会发现当前shell执行环境还是之前的，<br>
不会是<code>xx/yy</code>的环境下<br>
但是用 <code>source xx.sh</code>这种方式 执行完毕后 就会进入到<code>xx/yy</code>的目录下</p>
<p>如果想在终端编辑文件 需要在 <code>Cydia</code> 中安装一个vim （https://apt.saurik.com）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cycript语法的使用]]></title>
        <id>https://dargonlee.github.io/post/cycript-yu-fa-de-shi-yong/</id>
        <link href="https://dargonlee.github.io/post/cycript-yu-fa-de-shi-yong/">
        </link>
        <updated>2020-07-25T12:36:58.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>可以用来探索、修改、调试正在运行的Mac/iOS 的APP。</p>
</blockquote>
<ul>
<li>在手机上安装 Cycript 插件</li>
<li>使用的使用需要先用Mac终端连接手机</li>
<li>终端输入 <code>cycript</code> 就进入了调试环境了</li>
<li>cycript -p [进程ID] 或者[com.SpringBoard]或者[可执行文件的名称]</li>
<li>可以用<code>ps</code>指令获取某个应用程序的进程id</li>
<li>退出 control + d</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>可以用来探索、修改、调试正在运行的Mac/iOS 的APP。</p>
</blockquote>
<ul>
<li>在手机上安装 Cycript 插件</li>
<li>使用的使用需要先用Mac终端连接手机</li>
<li>终端输入 <code>cycript</code> 就进入了调试环境了</li>
<li>cycript -p [进程ID] 或者[com.SpringBoard]或者[可执行文件的名称]</li>
<li>可以用<code>ps</code>指令获取某个应用程序的进程id</li>
<li>退出 control + d</li>
</ul>
<!-- more -->
<h4 id="ps-指令-process-status-的缩写">ps 指令 【process status 的缩写】</h4>
<ul>
<li>先在手机上安装 <code>adv-cmds</code> 插件</li>
<li><code>ps -A 列出所有进程</code></li>
<li><code>ps A | grep 关键词</code></li>
</ul>
<h4 id="语法">语法</h4>
<p><code>UIApp</code> = <code>[UIApplication sharedApplication]</code></p>
<p>定义变量</p>
<pre><code class="language-swift"> var xx = UIApp.keyWindow
</code></pre>
<p>用内存地址获取对象</p>
<pre><code># 内存地址
</code></pre>
<p>获取当前程序用到的类</p>
<pre><code class="language-swift">ObjectiveC.classes
</code></pre>
<p>查看对象所有成员变量</p>
<pre><code class="language-swift">*UIApp
或者
*#对象内存地址
</code></pre>
<p>递归打印View的所有子控件</p>
<pre><code class="language-swift">[UIApp.keyWindow recursiveDescription]
想要排版好看点的话
[UIApp.keyWindow recursiveDescription].toString()
</code></pre>
<p>以上两种写法的常用形式</p>
<pre><code class="language-swift">UIApp.keyWindow.recursiveDescription().toString()
</code></pre>
<p>筛选出某中类型的对象</p>
<pre><code class="language-swift">choose(UIViewController)
choose(UITableViewCell)
</code></pre>
<p>拷贝封装好的js文件到iPhone</p>
<pre><code class="language-shell">scp -P 2222 文件在Mac上的路径/MJTool.js root@localhost:/usr/lib/cycript0.9
</code></pre>
<p>如果想要保证自己写的文件和其他的文件不冲突的话</p>
<pre><code>scp -P 2222 文件在Mac上的路径/MJTool.cy root@localhost:/usr/lib/cycript0.9/com/harlans
</code></pre>
<h3 id="封装cy文件">封装<code>cy</code>文件</h3>
<p>新建<code>test.cy</code>文件</p>
<pre><code class="language-swift">(function(exports) {
    MJSum = function (a, b) {
        return a + b;
    };

    exports.minus = function (a, b) {
        return a - b;
    };
    
    exports.age = 18;
    
    MJAppId = [NSBundle mainBundle].bundleIdentifier;
    
    exports.RootVc = function () {
        return UIApp.keyWindow.rootViewController;
    };
    
    exports.DocPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];
    
})(exports);
</code></pre>
<p>然后通过<code>iFunBox</code>拷贝到手机上 <code>/usr/lib/cycript0.9/</code>目录下</p>
<p>使用的时候直接在<code>@import test</code>后，直接输入<code>test.sum(1, 10)</code>就行了(但是这样的调用方式适用于 开头带<code>exports</code>的函数形式,如果开头不带<code>exports</code>就是属于全局的函数了直接调用<code>AppId</code>即可)</p>
<blockquote>
<p>注意如果你的<code>test.cy</code>文件不再cycript0.9这个目录下的话需要导入的时候加上，比如 <code>@import com.mj.test</code> 这样才会生效</p>
</blockquote>
<p><strong><a href="https://github.com/CoderMJLee/mjcript">MJ封装的库</a></strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS脱壳]]></title>
        <id>https://dargonlee.github.io/post/ios-tuo-ke/</id>
        <link href="https://dargonlee.github.io/post/ios-tuo-ke/">
        </link>
        <updated>2020-07-25T12:36:35.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="加壳">加壳</h4>
<blockquote>
<p>利用特殊的算法，对可执行文件的编码方式进行改变（比如压缩、加密），以达到保护程序代码的作用</p>
</blockquote>
<ul>
<li>
<p>加壳前：<br>
就是简单的可执行文件，执行之后把可执行文件装载在内存中</p>
</li>
<li>
<p>加壳后：<br>
可执行文件已经被加密了，不能直接用了。需要先加载到内存中，需要解密之后才能用。</p>
</li>
</ul>
<h4 id="脱壳">脱壳</h4>
<blockquote>
<p>摘掉壳程序，将未加密可执行文件还原出来</p>
</blockquote>
<ul>
<li>硬脱壳（iOS常用）</li>
</ul>
<blockquote>
<p>直接进行一个解密操作，不需要运行APP</p>
</blockquote>
<ul>
<li>动态脱壳</li>
</ul>
<blockquote>
<p>执行要脱壳的APP，将已经解密后的程序，从内存中直接拷贝出来。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h4 id="加壳">加壳</h4>
<blockquote>
<p>利用特殊的算法，对可执行文件的编码方式进行改变（比如压缩、加密），以达到保护程序代码的作用</p>
</blockquote>
<ul>
<li>
<p>加壳前：<br>
就是简单的可执行文件，执行之后把可执行文件装载在内存中</p>
</li>
<li>
<p>加壳后：<br>
可执行文件已经被加密了，不能直接用了。需要先加载到内存中，需要解密之后才能用。</p>
</li>
</ul>
<h4 id="脱壳">脱壳</h4>
<blockquote>
<p>摘掉壳程序，将未加密可执行文件还原出来</p>
</blockquote>
<ul>
<li>硬脱壳（iOS常用）</li>
</ul>
<blockquote>
<p>直接进行一个解密操作，不需要运行APP</p>
</blockquote>
<ul>
<li>动态脱壳</li>
</ul>
<blockquote>
<p>执行要脱壳的APP，将已经解密后的程序，从内存中直接拷贝出来。</p>
</blockquote>
<!-- more -->
<h5 id="ios中脱壳工具">iOS中脱壳工具</h5>
<ul>
<li>Cluth：https://github.com/KJCracks/Cluth</li>
<li>dumpdecrypted: https://github.com/stefanesser/dumpdecrypted</li>
</ul>
<h5 id="判断可执行文件是否加密">判断可执行文件是否加密</h5>
<pre><code class="language-shell">otool -l 文件路径 | grep crpyt 
</code></pre>
<p>如果cryptid 为1 是加密的 0是没有加密的</p>
<h4 id="cluth脱壳">Cluth脱壳</h4>
<blockquote>
<p>下载最新版本：https://github.com/KJCracks/Cluth</p>
</blockquote>
<p>把下载好的文件直接拷贝到手机的这个路径下<code>usr/bin</code></p>
<p>然后在连接手机端的命令窗口上输入：<code>Cluth脱壳</code>就行了，如果报错没有权限的话可以执行下面命令给这个执行文件授权</p>
<pre><code class="language-shell">chmod +x /usr/bin/Cluth
</code></pre>
<ul>
<li>列出手机上安装的应用：<code>Cluth -i</code>（只列出被加密的应用程序）</li>
<li>脱壳：<code>Cluth -d 应用的bundleId</code>（会输出一个脱壳后的ipa文件路径，把ipa文件拷贝到电脑上就行了）</li>
</ul>
<h4 id="dumpdecrypted脱壳">dumpdecrypted脱壳</h4>
<blockquote>
<p>下载最新版本：https://github.com/stefanesser/dumpdecrypted</p>
</blockquote>
<ul>
<li>把下载好的文件 执行<code>make</code>指令编译出<code>dumpdecrypted.dylib</code>动态库</li>
<li>将编译的动态库文件拷贝到<code>var/root</code>目录下</li>
<li>连接手机的终端进入动态库所在的目录</li>
<li>使用环境变量<code>DYLD_INSERT_LIBRARIES</code>将<code>dylib</code>注入到要脱壳的可执行文件中（可执行文件的路径可以先打开APP然后执行<code>ps -A</code> 来查看）</li>
</ul>
<pre><code class="language-shell">root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib 要脱壳的可执行文件路径（/var/Container/Bundle/Application/xxxx/yy.app/yy）
</code></pre>
<p>yy.decrypted 文件就是脱壳后的文件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[逆向常用工具]]></title>
        <id>https://dargonlee.github.io/post/ni-xiang-chang-yong-gong-ju/</id>
        <link href="https://dargonlee.github.io/post/ni-xiang-chang-yong-gong-ju/">
        </link>
        <updated>2020-07-25T12:36:12.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="逆向app思路">逆向APP思路</h4>
<ul>
<li>
<p>界面分析（Cycript、Reveal）</p>
</li>
<li>
<p>代码分析（对Mach-o文件分析）<br>
MachOView、class-dump、Hopper Disassembler、ida等</p>
</li>
<li>
<p>动态调试<br>
对运行的App进行代码调试（debugserver、LLDB）</p>
</li>
<li>
<p>代码编写<br>
注入代码到App中，必要时可能会重签名ipa</p>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h4 id="逆向app思路">逆向APP思路</h4>
<ul>
<li>
<p>界面分析（Cycript、Reveal）</p>
</li>
<li>
<p>代码分析（对Mach-o文件分析）<br>
MachOView、class-dump、Hopper Disassembler、ida等</p>
</li>
<li>
<p>动态调试<br>
对运行的App进行代码调试（debugserver、LLDB）</p>
</li>
<li>
<p>代码编写<br>
注入代码到App中，必要时可能会重签名ipa</p>
</li>
</ul>
<!-- more -->
<h4 id="class-dump的安装">class-dump的安装</h4>
<ul>
<li>先去下载 <code>class-dump</code>的可执行文件</li>
<li>然后把它复制到系统的<code>/usr/local/bin</code>目录下</li>
<li>执行<code>class-dump -H mach-o文件路径 -o 头文件存放路径</code></li>
</ul>
<h4 id="抽取系统框架的可执行文件">抽取系统框架的可执行文件</h4>
<ul>
<li>找到系统的动态库缓存文件 <code>Device/System/Libary/Caches/com.apple.dyld</code></li>
<li>里面会有两个文件一个<code>dyld_shared_cache_arm64</code>的、一个是<code>dyld_shared_cache_armv7s</code> 这里面装的分别是不同架构的系统框架可执行文件</li>
<li>但是文件太大，我们需要通过一个解析器去给解析处理各个framework的可执行文件</li>
<li>去找到<code>dyld</code>的源码<code>https://opensource.apple.com/tarballs/dyld/</code> 找到最新版本的下载下来</li>
<li>找到工程中<code>launch-cache/dsc_extractor.app</code>文件用<code>clang++</code>编译器编译成可执行文件（只要int main函数里面的东西，此函数上面的内容都可以不要）</li>
<li><code>clang++ -o dsc_extractor dsc_extractor.app</code> 会生成<code>dsc_extractor</code>可执行文件</li>
<li><code>./dsc_extractor dyld_shared_cache_armv7s armv7s</code> 回车执行 就会抽取包含在系统共享文件中的系统库可执行文件</li>
</ul>
<h4 id="mach-o的结构">Mach-o的结构</h4>
<ul>
<li><code>file</code>:查看Mach-o文件的结构</li>
</ul>
<pre><code class="language-shell">file 文件的路径
</code></pre>
<ul>
<li><code>otool</code>:查看Mach-o特定部分和段的内容</li>
</ul>
<pre><code class="language-shell">打印Mach-o文件里面链接了哪些库：otool -L 文件地址
打印Mach-o文件头信息：otool -f 文件地址
</code></pre>
<ul>
<li><code>lipo</code>:常用于多架构Mach-o文件的处理</li>
</ul>
<pre><code class="language-shell">查看架构信息：lipo -info 文件路径
导出特定架构：lipo 文件路径 -thin 架构类型 -output 输出文件路径
合并多种架构：lipo 文件路径1 文件路径2 -output 输出文件路径 
</code></pre>
<h4 id="配置reveal环境">配置Reveal环境</h4>
<ul>
<li>先安装<code>Reveal Loader</code> 插件</li>
<li>然后把Reveal的framework里的RevealServer替换到手里<code>Libary/RHReveal/目录下</code></li>
<li>killall SpringBoard 重启</li>
</ul>
<h4 id="theos-安装">theos 安装</h4>
<ul>
<li>安装签名工具<code>brew install ldid</code></li>
<li>修改环境变量</li>
</ul>
<pre><code class="language-shell">vim ~/.zshrc 或者 vim ~/.bash_profile
export THEOS=~/theos
export PATH=$THEOS/bin:$PATH
</code></pre>
<p>执行<code>source .zshrc</code>这样环境变量才会生效或者重启终端</p>
<ul>
<li>下载theos</li>
</ul>
<pre><code class="language-shell">git clone --recursive https://github.com/theos/theos.git $THEOS // --recursive递归下载
</code></pre>
<ul>
<li>新建项目</li>
</ul>
<pre><code class="language-shell">nic.pl
</code></pre>
<h4 id="theos-tweak的实现过程">theos-tweak的实现过程</h4>
<ul>
<li>编写tweak代码</li>
<li>make 编译Tweak代码为动态库（*.dylib）</li>
<li>make package 将dylib文件打包为deb文件</li>
<li>make install 将deb文件传送到手机，通过Cydia安装deb文件</li>
<li>插件将会安装到/Libary/MobileSubstrate/DynamicLibraries文件夹中</li>
<li>*.dylib为编译后的Tweak代码</li>
<li>*.plist存放着需要Hook AppId</li>
<li>当打开app时 Cydia Substrate 会让App加载对应的dylib</li>
<li>修改App内存中的代码逻辑，去执行dylib中的函数代码</li>
</ul>
<blockquote>
<p>所以theos的tweak并不会对app原来的可执行文件进行修改，仅仅是修改了内存中代码逻辑。<br>
如果希望卸载插件，只需要将/Libary/MobileSubstrate/DynamicLibraries中对应的dylib和plist文件删除即可</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS命令行工具开发]]></title>
        <id>https://dargonlee.github.io/post/ios-ming-ling-xing-gong-ju-kai-fa/</id>
        <link href="https://dargonlee.github.io/post/ios-ming-ling-xing-gong-ju-kai-fa/">
        </link>
        <updated>2020-07-25T12:35:47.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="本质">本质</h4>
<ul>
<li>可执行文件</li>
<li>跟App内部的可执行文件差不多</li>
<li>只不过没有UI界面</li>
<li>需要可执行权限</li>
</ul>
<h5 id="新建一个ios项目">新建一个iOS项目</h5>
<ul>
<li>把<code>main.m</code>文件的改为<code>return 0；</code></li>
<li>然后在代码里面写自己代码就可了</li>
<li>写完代码后，真机编译<code>.app</code>文件，取出里面的可执行文件</li>
<li>真机编译的时候记得处理下签名认证</li>
<li>然后拷贝到<code>/usr/bin</code>目录下</li>
<li>授权可执行权限<code>chomd +x /usr/bin/xxx</code></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h4 id="本质">本质</h4>
<ul>
<li>可执行文件</li>
<li>跟App内部的可执行文件差不多</li>
<li>只不过没有UI界面</li>
<li>需要可执行权限</li>
</ul>
<h5 id="新建一个ios项目">新建一个iOS项目</h5>
<ul>
<li>把<code>main.m</code>文件的改为<code>return 0；</code></li>
<li>然后在代码里面写自己代码就可了</li>
<li>写完代码后，真机编译<code>.app</code>文件，取出里面的可执行文件</li>
<li>真机编译的时候记得处理下签名认证</li>
<li>然后拷贝到<code>/usr/bin</code>目录下</li>
<li>授权可执行权限<code>chomd +x /usr/bin/xxx</code></li>
</ul>
<!-- more -->
<pre><code class="language-swift">#import &lt;mach-o/fat.h&gt;
#import &lt;mach-o/loader.h&gt;


if (argv[1] == @&quot;-l&quot;) {
            
}
NSString *path = @&quot;&quot;;// 可执行文件的路径
NSFileHandle *handle = [NSFileHandle fileHandleForReadingAtPath:path];
// 读取最前面的4个字节(magic,number)
int lenght = sizeof(uint32_t);
NSData *magicData = [handle readDataOfLength:lenght];
//魔数用来标识文件类型
uint32_t magicNumber;
[magicData getBytes:&amp;magicNumber length:lenght];
if (magicNumber == FAT_CIGAM || magicNumber == FAT_MAGIC) { // 胖二进制文件
    
}else if (magicNumber == MH_CIGAM || magicNumber == MH_MAGIC) { // 非arm64文件
    
}else if (magicNumber == MH_CIGAM_64 || magicNumber == MH_MAGIC_64) { // arm64文件
    
}
[handle closeFile];
</code></pre>
<h5 id="由于个人签名有效期有限">由于个人签名有效期有限</h5>
<ul>
<li>我们可以换成手动签名的方式</li>
</ul>
<h5 id="签名给可执行文件一定的权限让他可以访问其他app的可执行文件">签名给可执行文件一定的权限，让他可以访问其他App的可执行文件</h5>
<ul>
<li>使用<code>ldid导出某一个可执行文件的权限</code></li>
</ul>
<blockquote>
<p>TestCL为可执行文件</p>
</blockquote>
<pre><code class="language-shell">ldid -e TestCL &gt; TestCL.entitlements
</code></pre>
<ul>
<li>重新签上权限(先修改TestCL.entitlements里面的值)</li>
</ul>
<pre><code class="language-shell">ldid -STestCl.entitlements TestCL
</code></pre>
<blockquote>
<p>把自己写的工具的可执行文件权限提升，先把<code>SpringBoard</code>的可执行文件导出来，然后把它的权限导出来，然后把它的权限签到自己写可执行文件上就行了</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tweak开发手册]]></title>
        <id>https://dargonlee.github.io/post/tweak-kai-fa-shou-ce/</id>
        <link href="https://dargonlee.github.io/post/tweak-kai-fa-shou-ce/">
        </link>
        <updated>2020-07-25T12:35:16.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="tweak怎么多文件开发">tweak怎么多文件开发</h4>
<blockquote>
<p>一般来说我们开发tweak代码都是在<code>Tweak.xm</code>文件里面写代码，但是代码量小的话还好，一旦代码多了的话，代码开发起来就比较费劲。这个时候我们就可以使用多文件进行开发。</p>
</blockquote>
<ul>
<li>可以在<code>Tweak.xm</code>所在的目录下新建一个<code>src</code>文件夹，里面放你写的OC源代码。</li>
<li>然后在<code>Tweak.xm</code>文件是使用的地方<code>#import &quot;Person&quot;</code>导入就可以用了</li>
<li>但是在编译的时候你会发现报错，因为你写的<code>.m</code>文件没有参与编译</li>
<li>所以我们需要在<code>Makefile</code>里面的tweak_wechat_FILES = Tweak.xm指定下要参与编译的<code>.m</code>文件</li>
</ul>
<pre><code>tweak_wechat_FILES = Tweak.xm src/Persom.m // 记住多个文件以空格分割
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h4 id="tweak怎么多文件开发">tweak怎么多文件开发</h4>
<blockquote>
<p>一般来说我们开发tweak代码都是在<code>Tweak.xm</code>文件里面写代码，但是代码量小的话还好，一旦代码多了的话，代码开发起来就比较费劲。这个时候我们就可以使用多文件进行开发。</p>
</blockquote>
<ul>
<li>可以在<code>Tweak.xm</code>所在的目录下新建一个<code>src</code>文件夹，里面放你写的OC源代码。</li>
<li>然后在<code>Tweak.xm</code>文件是使用的地方<code>#import &quot;Person&quot;</code>导入就可以用了</li>
<li>但是在编译的时候你会发现报错，因为你写的<code>.m</code>文件没有参与编译</li>
<li>所以我们需要在<code>Makefile</code>里面的tweak_wechat_FILES = Tweak.xm指定下要参与编译的<code>.m</code>文件</li>
</ul>
<pre><code>tweak_wechat_FILES = Tweak.xm src/Persom.m // 记住多个文件以空格分割
</code></pre>
<!-- more -->
<ul>
<li>这样配置了之后，我们就可以执行<code>make</code> 进行编译了</li>
<li>如果你有一个目录下有很多文件，按上面写法就会很麻烦，还好tweak支持通配符</li>
</ul>
<pre><code>tweak_wechat_FILES = Tweak.xm src/*.m // 记住多个文件以空格分割
</code></pre>
<p><strong>这样就可以把某个文件夹下的多个文件参与编译的，记住tweak不支持文件夹的通配符</strong></p>
<blockquote>
<p>注意如果你新建了很多目录结构，要保证编译的文件能找到，导入的文件也能找到。</p>
</blockquote>
<h4 id="theos-tweak加载资源">theos-tweak加载资源</h4>
<ul>
<li>一般开发的tweak文件中有一个<code>layout</code>文件夹里面对应的什么目录结构，就安装到手机对应的目录结构中</li>
<li>比如本地文件目录结构<code>layout/Libary/PreferenceLoader/Preferences/MJWeChat/xx.png</code></li>
<li>这样手机就会把<code>MJWeChat</code>文件夹中的图片资源或者其他资源复制到手机的<code>Libary/PreferenceLoader/Preferences/</code>目录中</li>
<li>然后在tweak中编写代码加载文件资源的时候需要通过路径取资源文件<code>/Libary/PreferenceLoader/Preferences/MJWeChat/xx.png</code></li>
<li>当然我们的资源也不一定非得放到<code>/Libary/PreferenceLoader/Preferences/</code>文件夹下，也可以放到<code>/Libary/Caches/MJWeChat</code>这个目录下</li>
</ul>
<h4 id="安装release版本">安装<code>release</code>版本</h4>
<pre><code>make package // 为debug版本
make package debug=0 // 为release版本
</code></pre>
<h4 id="logos语法">Logos语法</h4>
<ul>
<li>%hook %end hook一个类的开始和结束</li>
<li>%log 打印方法调用详情 （可以通过Xcode - Window - Devices and Simulators 查看日志）</li>
<li>HBDebugLog: 跟NSLog类似</li>
<li>%new 添加一个新方法</li>
</ul>
<pre><code>@interface xxx
- (void)test;
@end


%hook XMGAdView

%new
- (void)test  
{// 新增的方法需要声明
    
}

- (id)init
{
    [self test];
}

%end
</code></pre>
<ul>
<li>%c(className):生成一个class对象，比如（%c(NSObject)）类似与NSStringFromClass() objc_getClass()</li>
<li>%orig: 函数原来的逻辑</li>
<li>%ctor: 在加载动态库时调用,做一些初始化操作</li>
</ul>
<pre><code>%ctor {
    
}
</code></pre>
<ul>
<li>%dtor: 在程序即将退出时调用，做一些结尾操作</li>
</ul>
<pre><code>%dtor {
    
}
</code></pre>
<ul>
<li>logify.pl: 可以将一个头文件快速转换成包含打印信息的xm文件</li>
</ul>
<pre><code>logify.pl xx.h &gt; xx.xm
</code></pre>
<p><strong>logify.pl使用注意</strong></p>
<ul>
<li><code>logify.pl生成的文件，有很多事编译不过的，需要进行一些处理</code></li>
<li>删除<code>__weak</code></li>
<li>删除<code>inout</code></li>
<li>删除协议，比如<code>&lt;XXTestDelegate&gt;</code></li>
<li>或者声明一下协议信息<code>@protocol XXTestDelegate</code></li>
<li>删除<code>-(void).cxx_destrut{%log; %orig;}</code></li>
<li>删除<code>HBLogDebug(@&quot;=0x%x,(unsigned int)r&quot;)</code></li>
<li>替换类型为void，比如将<code>XXPersion替换为void</code></li>
<li>或者声明一下类信息</li>
</ul>
<pre><code>@interface XXPerson : NSObject
@end
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS 动态调试]]></title>
        <id>https://dargonlee.github.io/post/ios-dong-tai-diao-shi/</id>
        <link href="https://dargonlee.github.io/post/ios-dong-tai-diao-shi/">
        </link>
        <updated>2020-07-25T12:34:45.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="什么是动态调试">什么是动态调试？</h4>
<blockquote>
<p>将程序运行起来，通过下断电、打印等方式。查看参数、返回值、函数调用流程等。</p>
</blockquote>
<h4 id="xcode的动态调试原理">Xcode的动态调试原理</h4>
<ul>
<li>
<p>关于 <code>GCC</code> <code>LLVM</code> <code>GDB</code> <code>LLDB</code></p>
<ul>
<li>Xcode 的编译器发展历程：GCC -&gt; LLVM</li>
<li>Xcode 的调试器发展历程：GDB -&gt; LLDB</li>
</ul>
</li>
<li>
<p>debugserver一开始存放在Mac上的Xcode里面</p>
</li>
<li>
<p>当Xcode识别手机设备的时候，Xcode会自动将debugserver安装到手机上</p>
</li>
<li>
<p>Xcode的调试局限性：一般只能安装通过Xcode安装的APP</p>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h4 id="什么是动态调试">什么是动态调试？</h4>
<blockquote>
<p>将程序运行起来，通过下断电、打印等方式。查看参数、返回值、函数调用流程等。</p>
</blockquote>
<h4 id="xcode的动态调试原理">Xcode的动态调试原理</h4>
<ul>
<li>
<p>关于 <code>GCC</code> <code>LLVM</code> <code>GDB</code> <code>LLDB</code></p>
<ul>
<li>Xcode 的编译器发展历程：GCC -&gt; LLVM</li>
<li>Xcode 的调试器发展历程：GDB -&gt; LLDB</li>
</ul>
</li>
<li>
<p>debugserver一开始存放在Mac上的Xcode里面</p>
</li>
<li>
<p>当Xcode识别手机设备的时候，Xcode会自动将debugserver安装到手机上</p>
</li>
<li>
<p>Xcode的调试局限性：一般只能安装通过Xcode安装的APP</p>
</li>
</ul>
<!-- more -->
<h4 id="动态调试任意app">动态调试任意APP</h4>
<h6 id="debugserver的权限问题">debugserver的权限问题</h6>
<ul>
<li>
<p>默认情况下<code>/Developer/usr/bin/debugserver</code>缺少一定的权限，只能调试通过Xcode安装的APP，无法调试其他APP 比如App Store上的APP</p>
</li>
<li>
<p>如果希望调试其他APP，需要对debugserver进行重新签名，签上2个调试相关的权限</p>
</li>
</ul>
<p><code>get-task-allow</code> 和 <code>task_for_pid-allow</code></p>
<h6 id="如何给debugserver签上权限">如何给debugserver签上权限</h6>
<ul>
<li>iPhone上的<code>/Developer</code>的目录是只读的，无法直接对<code>/Developer/usr/bin/debugserver</code>文件签名，需要先把debugserver文件复制到Mac上</li>
<li>通过ldid命令导出debugserver文件现在的权限</li>
</ul>
<pre><code class="language-shell">ldid -e debugserver &gt; debugserver.entitlements // 会生成一个debugserver.entitlements文件
</code></pre>
<ul>
<li>在<code>debugserver.entitlements</code>文件开始编辑点击加号 添加 <code>get-task-allow</code> 和 <code>task_for_pid-allow</code> 并设置值为YES</li>
<li>编辑好后保存再重新签名</li>
</ul>
<pre><code class="language-shell">ldid -Sdebugserver.entitlements debugserver // 然后debugserver的权限就加上去了
</code></pre>
<ul>
<li><strong>注意</strong>由于iPhone上的<code>/Developer</code>的目录是只读的，所以你签好文件不能直接赋值到手机上</li>
<li>可以直接把它放到<code>usr/bin</code>目录下，可以直接使用</li>
</ul>
<pre><code class="language-shell">chmod +x /usr/bin/debugserver //给执行权限
</code></pre>
<ul>
<li>然后在手机终端就可以直接使用了</li>
</ul>
<h6 id="让debugserver附加到某个app进程中">让debugserver附加到某个APP进程中</h6>
<p>先使用ssh登录到手机root用户然后执行下面命令</p>
<pre><code class="language-shell">debugserver *:端口号 -a 进程
debugserver *:10011 -a WeChat
</code></pre>
<ul>
<li><code>*:端口号</code>：使用iPhone的某个端口启动debugserver服务（只要不是保留端口就行）</li>
<li><code>-a</code>:进程输入APP的进程信息（进程ID或者进程名称）</li>
</ul>
<h6 id="在mac上启动lldb远程连接iphone上的debugserver服务">在Mac上启动LLDB，远程连接iPhone上的debugserver服务</h6>
<ul>
<li>启动LLDB</li>
</ul>
<pre><code class="language-shell">lldb
</code></pre>
<ul>
<li>连接debugserver服务</li>
</ul>
<pre><code class="language-shell">(lldb) process connect connect://手机IP地址:debugserver服务的端口号
(lldb) process connect connect://10.1.125.100:10011
</code></pre>
<ul>
<li>如果是通过端口转发的方式连接手机的话通过下面方式连接<br>
转发端口</li>
</ul>
<pre><code class="language-shell">iproxy 22:2222 10011:9999 // 这样就转发了手机上的两个端口
</code></pre>
<p>然后登录到手机</p>
<pre><code class="language-shell">ssh -p 2222 root@localhost
</code></pre>
<p>转发debugserver端口</p>
<pre><code class="language-shell">debugserver *:10011 -a WeChat
</code></pre>
<p>之后再使用lldb连接debugserver服务器</p>
<pre><code class="language-shell">(lldb) process connect connect://localhost:10011
</code></pre>
<ul>
<li>使用LLDB的<code>c</code>命令让程序先继续运行</li>
</ul>
<pre><code class="language-shell">(lldb)  c
</code></pre>
<p>然后就监听成功了。</p>
<h6 id="通过debugserver启动app">通过debugserver启动APP</h6>
<pre><code class="language-shell">debugserver -x auto*:端口号 APP可执行文件路径
</code></pre>
<h6 id="通过xcode直接调试任意app">通过Xcode直接调试任意App</h6>
<ul>
<li>先安装 <code>AppSync Unified</code> 这个插件【主要作用屏蔽签名】</li>
</ul>
<p>安装好了之后会自动启动，这样没签名的应用也可以安装手机上</p>
<ul>
<li>然后USB连接手机 终端登录手机 <code>ps -A</code>找到要调试的可执行文件名比如<code>AppStore</code></li>
<li>之后打开Xcode -&gt; Debug -&gt; Attach process by PID or Name -&gt; 输入<code>AppStore</code> -&gt; 点击<code>Attach</code></li>
<li>然后打开手机上的<code>AppStore</code>应用 就可以调试了</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用LLDB指令]]></title>
        <id>https://dargonlee.github.io/post/chang-yong-lldb-zhi-ling/</id>
        <link href="https://dargonlee.github.io/post/chang-yong-lldb-zhi-ling/">
        </link>
        <updated>2020-07-25T12:02:12.000Z</updated>
        <summary type="html"><![CDATA[<h5 id="指令格式">指令格式</h5>
<pre><code>&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;]...] &lt;actions&gt; [-options [options value]] [argument[argument]...]
</code></pre>
<ul>
<li><command> 命令</li>
<li><subcommand>子命令</li>
<li><actions>命令操作</li>
<li><options>命令选项</li>
<li><argument> 命令参数</li>
</ul>
<p>比如给<code>test</code>函数设置断点</p>
]]></summary>
        <content type="html"><![CDATA[<h5 id="指令格式">指令格式</h5>
<pre><code>&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;]...] &lt;actions&gt; [-options [options value]] [argument[argument]...]
</code></pre>
<ul>
<li><command> 命令</li>
<li><subcommand>子命令</li>
<li><actions>命令操作</li>
<li><options>命令选项</li>
<li><argument> 命令参数</li>
</ul>
<p>比如给<code>test</code>函数设置断点</p>
<!-- more -->
<pre><code>breakpoint set -n test
</code></pre>
<ul>
<li>breakpoint是<command></li>
<li>set是<actions></li>
<li>-n是<options></li>
<li>test是<argument></li>
</ul>
<h5 id="help指令">help指令</h5>
<blockquote>
<p>查看指令用法</p>
</blockquote>
<p>比如</p>
<pre><code>help breakpoint 
</code></pre>
<pre><code>help breakpoint set
</code></pre>
<h5 id="expression-cmd-options-expr">expression <cmd-options>--<expr></h5>
<blockquote>
<p>执行一个表达式</p>
</blockquote>
<ul>
<li><cmd-options> 命令行选项</li>
<li>-- 命令选项结束符 表示所有的命令选项已经设置完毕 如果没有命令选项，--可以省略</li>
<li><expr> 需要执行的表达式</li>
</ul>
<pre><code>expression self.view.backgroundColor = [UIColor redColor]
</code></pre>
<ul>
<li>expression、expression--和指令print、p、call的效果一样</li>
<li>expression -O --和po指令效果一样</li>
</ul>
<h5 id="thread-backtrace">thread backtrace</h5>
<ul>
<li>打印线程的堆栈信息</li>
<li>和指令bt效果一样</li>
</ul>
<h5 id="thread-return-expr">thread return [<expr>]</h5>
<ul>
<li>让函数直接返回某一个值，不会执行断点后面的代码</li>
</ul>
<h5 id="frame-variable-variable-name">frame variable [<variable-name>]</h5>
<ul>
<li>打印当前栈帧的变量</li>
</ul>
<h5 id="thread-continue-continue-c-程序继续运行">thread continue 、continue、c ：程序继续运行</h5>
<h5 id="thread-step-over-next-n-单步运行-把子函数当做整体一步执行">thread step-over 、next、n ：单步运行、把子函数当做整体一步执行</h5>
<h5 id="thread-step-in-step-s-单步运行-遇到子函数进入到子函数中">thread step-in 、step、s ：单步运行、遇到子函数进入到子函数中</h5>
<h5 id="thread-step-out-finish直接执行完当前函数所有代码-返回到上一个函数">thread step-out 、finish：直接执行完当前函数所有代码、返回到上一个函数</h5>
<h5 id="si-ni和s-n类似">si、ni和s、n类似</h5>
<ul>
<li>s、n是源码级别的</li>
<li>si、ni是汇编指令级别的</li>
</ul>
<h5 id="breakpoint-set-设置断点">breakpoint set 设置断点</h5>
<ul>
<li>breakpoint set -a 函数地址</li>
</ul>
<pre><code>
</code></pre>
<ul>
<li>breakpoint set -n 函数名称</li>
</ul>
<pre><code>breakpoint set -n test

breakpoint set -n  touchBegan:withEvent:

breakpoint set -n &quot;-[ViewController touchBegan:withEvent:]&quot;
</code></pre>
<p><strong>breakpoint set -n test 简写为 br set -n test</strong></p>
<ul>
<li>
<p>breakpoint set -r 正则表达式</p>
</li>
<li>
<p>breakpoint set -s 动态库 -n 函数名</p>
</li>
<li>
<p>breakpoint list 列出所有断点</p>
</li>
<li>
<p>breakpoint disable 断点编号 ： 禁用断点</p>
</li>
<li>
<p>breakpoint enable 断点编号 ： 启用断点</p>
</li>
<li>
<p>breakpoint delete 断点编号 ： 删除断点</p>
</li>
<li>
<p>breakpoint command 断点编号 ： 给断点预先设置需要执行的命令，到触发断点时，就会按顺序执行</p>
</li>
<li>
<p>breakpoint command list 断点编号：查看某个断点设置的命令</p>
</li>
<li>
<p>breakpoint command delete 断点编号：删除某个断点设置的命令</p>
</li>
</ul>
<h5 id="内存断点">内存断点</h5>
<blockquote>
<p>在内存数据发生改变的时候触发 <code>watchpoint set variable 变量</code></p>
</blockquote>
<pre><code>watchpoint set variable self-&gt;age
</code></pre>
<ul>
<li><code>watchpoint set expression 地址</code></li>
</ul>
<pre><code>watchpoint set variable &amp;(self-&gt;_age)
</code></pre>
<ul>
<li>watchpoint list</li>
<li>watchpoint disable 断点编号</li>
<li>watchpoint enable 断点编号</li>
<li>watchpoint delete 断点编号</li>
<li>watchpoint command add 断点编号</li>
<li>watchpoint command list 断点编号</li>
<li>watchpoint command delete 断点编号</li>
</ul>
<h5 id="image-lookup">image lookup</h5>
<ul>
<li>image lookup -t 类型：查找某个类型的信息</li>
<li>image lookup -a 地址：根据内存地址查找在模块中的位置</li>
<li>image lookup -n 符号或者函数名：查找某个符号或者函数的位置</li>
<li>image list 列出所加载模块的信息</li>
<li>image list -o -f 打印出模块的偏移地址、全路径</li>
</ul>
<pre><code> image list -o -f | grep WeChat
</code></pre>
<h5 id="寄存器">寄存器</h5>
<ul>
<li>memory read 读取所有寄存器的值</li>
<li>memory write 寄存器 值  给某个寄存器写入值</li>
<li>po $x0:打印方法调用者</li>
<li>x/s $x1: 打印方法名</li>
<li>po $x2:打印参数（以此类推，x3 x4也可能是参数）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 调试技巧]]></title>
        <id>https://dargonlee.github.io/post/javascript-diao-shi-ji-qiao/</id>
        <link href="https://dargonlee.github.io/post/javascript-diao-shi-ji-qiao/">
        </link>
        <updated>2020-03-16T02:56:06.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>自动断点<br>
有时候在执行 JavaScript 代码的时候，可能来不及设置断点，代码就被执行了，其实可以通过在代码中写上 debugger（代码中第 8 行），让代码执行到 debugger 的位置自动暂停。</li>
</ol>
<pre><code class="language-js">function b() {
    console.log('enter b');
    debugger;
}
</code></pre>
<ol start="2">
<li>打印调用堆栈<br>
可以通过调试面板查看当前代码的调用堆栈，也可以通过 console.trace() 打印函数调用堆栈</li>
</ol>
<pre><code class="language-js">function c() {
    console.log('enter c');
    console.trace();
}
</code></pre>
<ol start="3">
<li>以表格的方式打印对象<br>
下面是一个对象，可以通过 console.table( obj ) 来打印这个对象。</li>
</ol>
<pre><code class="language-js">
let pkg = {
    &quot;name&quot;: &quot;mini_tools&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;description&quot;: &quot;&quot;,
    &quot;main&quot;: &quot;index.js&quot;,
    &quot;dependencies&quot;: {
        &quot;jquery&quot;: &quot;^1.12.4&quot;
    },
    &quot;devDependencies&quot;: {},
    &quot;scripts&quot;: {
        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
    },
    &quot;author&quot;: &quot;&quot;,
    &quot;license&quot;: &quot;ISC&quot;
};

console.table(pkg);
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dargonlee.github.io/post-images/1584327572021.webp" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开启一个 WebServer]]></title>
        <id>https://dargonlee.github.io/post/kai-qi-yi-ge-webserver/</id>
        <link href="https://dargonlee.github.io/post/kai-qi-yi-ge-webserver/">
        </link>
        <updated>2020-03-09T08:17:37.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>在 Mac 上开启一个 WebServer，把写好的页面部署到 WebServer 上并可以通过 「ip+端口」 的形式访问。</p>
</blockquote>
<h3 id="mac-自带的-webserver">mac 自带的 WebServer</h3>
<p>mac 自带了一个 WebServer Apache，可以使用命令来开启关闭 WebServer：</p>
<pre><code class="language-shell">sudo apachectl start //开启
sudo apachectl restart //重启 
sudo apachectl stop //关闭 
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>在 Mac 上开启一个 WebServer，把写好的页面部署到 WebServer 上并可以通过 「ip+端口」 的形式访问。</p>
</blockquote>
<h3 id="mac-自带的-webserver">mac 自带的 WebServer</h3>
<p>mac 自带了一个 WebServer Apache，可以使用命令来开启关闭 WebServer：</p>
<pre><code class="language-shell">sudo apachectl start //开启
sudo apachectl restart //重启 
sudo apachectl stop //关闭 
</code></pre>
<!-- more -->
<p>打开终端窗口，输入 <code>sudo apachectl start</code>，便可以开启 webServer，在浏览器中输入 127.0.0.1 。会打开一个默认的网页：<strong>It works</strong>。</p>
<p>把写好的html内容放到 <code>/Library/WebServer/Documents</code> 这个目录下。<strong>最好html文件以index.html来命名的</strong><br>
然后就可以通过 127.0.0.1 这个 ip 地址来访问具体的页面<br>
在浏览器中输入：<a href="http://127.0.0.1/index.html">http://127.0.0.1/index.html</a> 便可以访问写的html网页。这里的index.html是写好的文件，当然你也可以以其他名字命名，但是在网页访问的时候要写那重新命名的那个名字，<br>
比如：<a href="http://127.0.0.1/test.html">http://127.0.0.1/test.html</a></p>
<h3 id="fis3">FIS3</h3>
<p>安装前需要先安装Node 可以到 Node 官网下载安装 https://nodejs.org/zh-cn/。<br>
安装Node完成后，在终端输入下面命令看是否安装正常</p>
<pre><code class="language-shell">node -v // node的版本
v10.7.0

npm -v // npm 的版本
6.13.7
</code></pre>
<p>安装<br>
<code>npm install -g fis3</code> 如果报错权限问题 试下加<code>sudo</code><br>
如果安装过程中出现问题，可以参考 http://fis.baidu.com/fis3/docs/beginning/install.html 。</p>
<p>安装成功后我们通过 Fis3 来开启一个 WebServer，达到与 mac 的 WebServer  同样的效果。</p>
<ol start="0">
<li>首先<code>cd</code> 到你要部署的文件夹下</li>
<li>然后通过<code>fis3 server start</code> 开启 WebServer</li>
<li>通过 fis3 release 把相关代码部署到 WebServer【通过 <code>fis3 server open</code> 可以打开 WebServer 所在目录】</li>
<li>根据提示在浏览器输入<code>http://127.0.0.1:8080/</code></li>
</ol>
<p>** 大功告成！！！**</p>
]]></content>
    </entry>
</feed>