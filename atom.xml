<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dargonlee.github.io</id>
    <title>七里田间的守望者</title>
    <updated>2020-03-06T03:06:38.695Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dargonlee.github.io"/>
    <link rel="self" href="https://dargonlee.github.io/atom.xml"/>
    <subtitle>我不在乎是悲伤的离别还是不痛快的离别，只要是离开一个地方，我总希望离开的时候自己心中有数。</subtitle>
    <logo>https://dargonlee.github.io/images/avatar.png</logo>
    <icon>https://dargonlee.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 七里田间的守望者</rights>
    <entry>
        <title type="html"><![CDATA[CSS的Tips 第二章]]></title>
        <id>https://dargonlee.github.io/post/css-de-tips-di-er-zhang/</id>
        <link href="https://dargonlee.github.io/post/css-de-tips-di-er-zhang/">
        </link>
        <updated>2020-03-05T06:37:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="显示一行内容">显示一行内容</h3>
<p>单行文字</p>
<pre><code class="language-css">.singal-line {
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}
</code></pre>
<p>text-overflow 属性<br>
<code>ellipsis</code>（省略号）: 以 ... 省略号显示；<br>
<code>clip</code> : 截断显示；</p>
<h3 id="只显示两行内容">只显示两行内容</h3>
<p>显示两行且超出部分以省略号显示，这个需要使用 webkit 的 CSS 扩展属性 -webkit-line-clamp ，它用来控制内容的行数，如果想让这个属性起作用，需要满足：</p>
<ol>
<li>
<p>display 为 -webkit-box 或者 -webkit-inline-box；</p>
</li>
<li>
<p>-webkit-box-orient 的属性值为 vertical；</p>
</li>
</ol>
<pre><code class="language-css">.two-line {
    display: -webkit-box;
    overflow: hidden;
    text-overflow: ellipsis;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
}
</code></pre>
<blockquote>
<p>如果想显示 3 行内容，把 -webkit-line-clamp 改为 -webkit-line-clamp：3；</p>
</blockquote>
<h3 id="animation">animation</h3>
<p>在@keyframes规则中指定CSS样式时，动画将在特定时间逐渐从当前样式更改为新样式。要使动画生效，必须将动画绑定到元素。以下示例将“example”动画绑定到<div>元素。动画将持续4秒，并且会逐渐将<div>元素的背景颜色从“红色”更改为“×××”：</p>
<pre><code class="language-css">/* 动画代码 */
@keyframes example {
  from {background-color: red;}
  to {background-color: yellow;}
}
/* 要将动画应用到的元素 */
div {
  width: 100px;
  height: 100px;
  background-color: red;
  animation-name: example;
  animation-duration: 4s;
}
</code></pre>
<blockquote>
<p>注意：该animation-duration属性定义动画完成所需的时间。如果animation-duration未指定该属性，则不会发生动画，因为默认值为0（0秒）。 在上面的示例中，我们通过使用关键字“from”和“to”&gt;&gt;（表示0％（开始）和100％（完成））指定样式何时更改。也可以使用百分比。通过使用百分比，您可以根据需要添加任意数量的样式更改。当动画完成25％，完成50％时，以及动画100％完成时，以下示例将更改<div>元素的背景颜色：</p>
</blockquote>
<pre><code class="language-css">/* 动画代码 */
@keyframes example {
  0%   {background-color: red;}
  25%  {background-color: yellow;}
  50%  {background-color: blue;}
  100% {background-color: green;}
}
/* 将动画应用到元素 */
div {
  width: 100px;
  height: 100px;
  background-color: red;
  animation-name: example;
  animation-duration: 4s;
}
</code></pre>
<p>以下示例将在动画完成25％，完成50％时再次更改背景颜色和<div>元素的位置，并在动画完成100％时再次更改：</p>
<pre><code class="language-css">/* 动画代码 */
@keyframes example {
  0%   {background-color:red; left:0px; top:0px;}
  25%  {background-color:yellow; left:200px; top:0px;}
  50%  {background-color:blue; left:200px; top:200px;}
  75%  {background-color:green; left:0px; top:200px;}
  100% {background-color:red; left:0px; top:0px;}
}
/* 将动画应用到元素 */
div {
  width: 100px;
  height: 100px;
  position: relative;
  background-color: red;
  animation-name: example;
  animation-duration: 4s;
}
</code></pre>
<p>animation-name: 动画的名字，这个是通过 @keyframes 定义的名字，比如 @keyframes 定义如下，那么 animation-name 就为 move。@keyframes 指定某一帧的动画如何变化，可通过 % 来控制各个阶段的属性值，比如 0% 的时候，元素的 left 和 top 都为 0。</p>
<pre><code class="language-css">@keyframes move {
    0% {
        left: 0;
        top: 0;
    }
    100% {
        left: 0;
        top: 0;
    }
}
</code></pre>
<p>animation-duration：动画的持续时间；</p>
<p>animation-delay：动画开始时的延迟时间；</p>
<p>animation-iteration-count：动画循环次数；</p>
<p>animation-direction：动画的方向，比如 alternate 表示先正向后逆序，nomal 正向，reverse 逆序；</p>
<p>animation-timing-function：动画的时间曲线，它的值有 ease、ease-in、ease-out、ease-in-out、linear；</p>
<p>animation-fill-mode：动画执行后的填充模式，它的值有 forwards、backwards、none、both；</p>
<h3 id="transition">transition</h3>
<p>transition 是过渡动画，修改某些属性的时候不会立刻生效，它会以动画的形式逐渐过渡到要设置的值。比如设置某个 HTML 元素的背景颜色，修改宽度和高度。</p>
<pre><code class="language-css">.move-transition {
    /* transition-property: all; */
    transition-property: background-color, height, width;
    transition-duration: 1.8s, 1.0s, 1.0s;
    transition-delay: 0.1s;
    transition-timing-function: linear;
}
</code></pre>
<p>transition-property: 指需要使用过渡动画的属性，这里设置了背景色，高度和宽度。也可以通过关键字 all 设置所有的属性；<br>
transition-duration: 动画持续的时间，可以单独控制某个属性的时间， transition-duration：1.8s, 1.0s, 1.0s 表示修改 background-color 需要 1.8s, 修改 height 需要 1.0s,  修改 width 需要 1.0s;<br>
transition-delay：动画开始时需要延迟多长时间才开始执行；<br>
transition-timing-function：表示动画执行时的时间函数，不同函数走过的曲线不一样；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS的Tips 第一章]]></title>
        <id>https://dargonlee.github.io/post/css-de-tips/</id>
        <link href="https://dargonlee.github.io/post/css-de-tips/">
        </link>
        <updated>2020-03-04T03:57:18.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="document的操作">document的操作</h3>
<pre><code class="language-css">// 创建一个div元素标签
let div = document.createElement(&quot;div&quot;);
//创建文本节点
let textNode = document.createTextNode(titles[index]);
//添加文本到创建好的div元素中
 div.appendChild(textNode);
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h3 id="document的操作">document的操作</h3>
<pre><code class="language-css">// 创建一个div元素标签
let div = document.createElement(&quot;div&quot;);
//创建文本节点
let textNode = document.createTextNode(titles[index]);
//添加文本到创建好的div元素中
 div.appendChild(textNode);
</code></pre>
<!-- more -->
<h3 id="css选择器">CSS选择器</h3>
<pre><code class="language-css">/* 通用选择器，作用适用于所有的标签 */
* {
    margin: 0;
    padding: 0;
} 

/* 匹配所有使用属性 &quot;lefe&quot; 的元素 */
[lefe] {
    color: green;
}

/*匹配所有使用属性为 &quot;lefe&quot;，且值为 liquid 的元素*/
[lefe='liquid'] {
    background-color: goldenrod;
}

/*匹配所有使用属性为 &quot;lefe&quot;，且值包含 spicy 的元素*/
[lefe~=&quot;spicy&quot;] {
    color: red;
}

/* 伪选择器 */
/* 匹配超链接样式 */
a {
    color: blue;
    font-weight: bold;
}

/* 访问后的状态 */
a:visited {
    color: yellow;
}

/* 鼠标悬停、点击、聚焦时的样式 */
a:hover,
a:active,
a:focus {
    color: darkred;
    text-decoration: none;
}

/* 伪元素（pseudo-elements）选择器，它以“ :: ” 为标识符。
比如修改首字母的样式。在超链接后添加一个向上的弯曲的箭头： */
p::first-letter {
    font-weight: bold;
}

p::first-line {
    font-size: 3em;
}

[href^=http]::after {
    content: '⤴';
}

/* A B {} : A 元素的所有后代元素 B 都会起作用。下面的例子中 div p {}，
它会遍历 div 中所有的子元素 p，只要找到 p 元素就应用对应的 CSS 样式，
故所有的 p 元素都变成了红色； */
div p {
    color: red;
}

/* 只会找到 div 的第一层子节点 p */
div&gt;p {
    color: green;
}

/* div + p { } 只会匹配 div 的下一个兄弟节点 p */
div+p {
    background-color: hotpink;
}

/* div ~ p { } 会匹配 div 的所有兄弟节点 p； */
div~p {
    color: darkgoldenrod;
}

/* A 和 B 元素具有同一规则的 CSS 样式，不同元素使用逗号隔开。 */
div,
p {
    color: red;
}
</code></pre>
<h3 id="border-的使用">border 的使用</h3>
<p>border 是一个简写属性，它由一个或多个属性组成：border-width, border-style, border-color。往往会使用简写的方式，比如：</p>
<pre><code class="language-css">. title {
   border: 1px solid red;
}
</code></pre>
<p>border-width：表示边框的宽度，可以分别设置上下左右边框为不同的宽度，比如 border-bottom-width；</p>
<p>border-style: 表示边框的样式，可以分别设置上下左右边框为不同的样式，比如 border-bottom-style，可以取下面几种值：node、hidden、dotted、dashed、solid 等；</p>
<p>border-color：表示边框的颜色，可以分别设置上下左右边框为不同的颜色。<br>
给标题添加下划线</p>
<pre><code class="language-css">.section-title {
    font-size: 20px;
    padding-bottom: 5px;
    margin-left: 10px;
    color: #258BD6;
    font-weight: 600;
    border-bottom-width: 1px;
    border-bottom-style: solid;
}
</code></pre>
<p>利用border可以做三角箭头</p>
<pre><code class="language-css">.triangle {
    width: 0;
    border: 20px solid;
    border-color: #f30 transparent transparent;
}
</code></pre>
<p>扩大点击区域</p>
<pre><code class="language-css">.icon {
    background-color: antiquewhite;
    width: 15px;
    height: 15px;
    border: 11px solid transparent;
}
</code></pre>
<h3 id="media-屏幕适配">@media 屏幕适配</h3>
<p>整段代码的意思是匹配带有屏幕的设备，且最小尺寸是 700 像素。：</p>
<pre><code class="language-css">@media screen and (min-width: 700px) {
   // css
}
</code></pre>
<p>再来看个例子，这段代码的意思是匹配带有屏幕的设备，且最小尺寸是 700 像素，最大尺寸是 900像素。</p>
<pre><code class="language-css">@media screen and (min-width: 700px) and (max-width: 900px) {
   // css
}
</code></pre>
<p>@media 语法规则是：</p>
<pre><code class="language-css">@media mediaType and|not|only (media feture) {
  // css
}
</code></pre>
<p>例子：</p>
<pre><code class="language-css">//正常显示样式
.top div {
    height: 200px;
    margin-bottom: 5px;
    background: white;
    /* 规定背景图像的尺寸 */
    background-size: 100% 100%;
    /* 如何定位背景图片 */
    background-position: 0 0;
}
// 适配大于700px的屏幕显示样式
@media screen and (min-width: 700px) {
    .top {
        width: 40%;
        margin: 0 30px;
    }
    .top div {
        height: 250px;
    }
}
</code></pre>
<h3 id="display-inline">display-inline</h3>
<p>使用 inline 告诉浏览器这是一个行内元素，布局的时候要按照行内元素的方式布局，比如 span 标签默认的就是这种布局方式。在有足够空间的时候，它不会换行。<strong>不能使用 width 和 height 属性。从图中可知 width 和 height 并没有起作用，margin 只会在水平方向起作用</strong>。</p>
<pre><code class="language-css">.strong {
    color: red;
    border: 1px solid yellow;
    padding: 10px;
    margin: 20px;
    background-color: antiquewhite;
    width: 150px;
    height: 80px;
}

&lt;span class=&quot;strong&quot;&gt;多媒体电子书&lt;/span&gt;，通过公众号的形式呈现内容，
    并与粉丝形成互动，推动读者自我驱动，利用业余时间学习前端，
    迎合大前端的浪潮。
    &lt;/p&gt;
</code></pre>
<h3 id="displayinline-block">display：inline-block</h3>
<p>这种布局方式结合了 inline 和 block 这两种元素的特性，它与块级元素不同的是：元素不会单独占用一行；相同的是：<strong>可以使用 width 和 height，可以通过 padding、margin 和 border 来控制元素的显示位置。说白了就是除了不会单独占一行，其余的与块级元素一致</strong>。</p>
<pre><code class="language-css">.strong {
    display: inline-block;
    color: red;
    border: 1px solid yellow;
    padding: 10px;
    margin: 20px;
    background-color: antiquewhite;
    width: 150px;
    height: 80px;
}
</code></pre>
<h3 id="背景图">背景图</h3>
<pre><code class="language-css">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-css">.box {
    width: 200px;
    height: 200px;
    background-color: antiquewhite;
    background-image: url('./logo_suyan.png');
    background-repeat: no-repeat;
    background-position: center;
    background-size: cover;
}
</code></pre>
<ol>
<li>background-postion: 表示背景图的起始位置；</li>
</ol>
<p>background-postion：top | left | bottom | right，在某个边缘的位置，另一个维度为 50%。比如 top，背景图的起始位置为顶部，在X轴方向为 50%，居中显示；</p>
<p>background-postion：center，居中背景图；</p>
<p>background-postion：25% 75%，设置基于背景区域的开始位置，可以为负值；<strong>第一个值是水平位置，第二个值是垂直。</strong></p>
<ol start="2">
<li>
<p>background-postion-x：背景在 x 轴上的位置；</p>
</li>
<li>
<p>background-postion-y：背景在 y 轴上的位置；</p>
</li>
<li>
<p>background-repeat: 背景的重复方式， no-repat 不重复，repeat 重复，repat-x X轴上重复，还有其它关键字，读者可以自行查看</p>
</li>
</ol>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat">https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat</a></p>
<ol start="5">
<li>background-size: 背景图的大小；<br>
5.1 background-size: cover，缩放背景图以完全覆盖背景区，保持原图的宽高比，可能背景图部分会看不到，填满背景图；<br>
5.2 background-size: contain，缩放背景图以完全显示背景图，保持原图的宽高比，可能背景部分区域空白，尽可能把图显示完整；</li>
</ol>
<p>background-size: 50%，背景图的大小为背景区的百分比；</p>
<p>background-size: 12px，背景图的宽度为 12px，高度按照比例自动缩放；</p>
<p>background-size: 12px 14px，背景图的宽度为 12px，高度14px；</p>
<h3 id="在文字前-后插入一个图标">在文字前、后插入一个图标</h3>
<p>对于「图+文字」这种效果可以利用 ::before 这个伪元素选择器。下面的 CSS 样式中的 content 属性必须有，否则将不会展示。（但是content的值可以为空）</p>
<pre><code class="language-css">&lt;p class=&quot;left&quot;&gt;文字前加图片&lt;/p&gt;
</code></pre>
<p>content为空，添加背景图片方式</p>
<pre><code class="language-css">.left {
    color: black;
    font-size: 15px; // 这里的大小会决定图标的大小
}
.left::before { // before 是在文字前添加图标 after是在文字后面添加文字
    /* content: 'before'; */
    content: '';
    display: inline-block;
    vertical-align: middle;
    background-image: url('./images/hert.png');
    background-repeat: no-repeat;
    background-position: center;
    background-size: cover;
    margin-right: 4px;
    width: 30px;
    height: 30px;
}
</code></pre>
<p>content不为空直接使用图标</p>
<pre><code class="language-css">
.left {
    color: black;
    font-size: 15px;
}
.left::after {
    content: '→';
    display: inline-block;
    color: red; // 这里的颜色就是图标的颜色
    margin-left: 5px;
}
</code></pre>
<p>除了上面的两个伪元素外，还有其它的伪元素，比如：</p>
<pre><code class="language-css">::first-letter 表示对首字母进行操作
</code></pre>
<pre><code class="language-css">::first-line 对首行内容进行操作
</code></pre>
<h3 id="position属性">position属性</h3>
<blockquote>
<p>CSS position属性用于指定一个元素在文档中的定位方式。top、right、bottom、left 属性则决定了该元素的最终位置。</p>
</blockquote>
<ul>
<li>
<p>position: static<br>
该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top、right、bottom、left 属性无效。</p>
</li>
<li>
<p>position: relative【相对定位】<br>
相对定位是相对于元素自身的正常位置的偏移，并不会脱离正常流，会在原位置上留下空白。</p>
</li>
</ul>
<pre><code class="language-css">.pos_top{
    position: relative;
    top:20px;
}
.pos_left{
    position: relative;
    left:50px;
}
</code></pre>
<ul>
<li>position: absolute【绝对定位】<br>
生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。<br>
绝对定位的元素相对于于最近的非static祖先元素定位，如果这样的祖先不存在，那么它的位置是相对于<html>的；绝对定位的元素脱离了正常流。</li>
</ul>
<pre><code class="language-css">.first{
    width:400px;
    height:400px;
    background-color: green;
    position: relative;
}
.second{
    width:100px;
    height:100px;
    background-color: red;
    position: absolute;
    top:50%;
    left
</code></pre>
<ul>
<li>position:fixed【固定定位】<br>
固定定位是指元素的位置相对于浏览器窗口是固定的，即使窗口是滚动的它也不会滚动，固定定位脱离了正常流，所以它有可能和其他元素发生重叠。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flex布局入门]]></title>
        <id>https://dargonlee.github.io/post/flex-bu-ju-ru-men/</id>
        <link href="https://dargonlee.github.io/post/flex-bu-ju-ru-men/">
        </link>
        <updated>2020-02-20T11:16:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="flex基本概念">Flex基本概念</h3>
<p>在 flex 容器中默认存在两条轴，水平主轴(main axis) 和垂直的交叉轴(cross axis)，这是默认的设置，当然你可以通过修改使垂直方向变为主轴，水平方向变为交叉轴，这个我们后面再说。</p>
<p>在容器中的每个单元块被称之为 flex item，每个项目占据的主轴空间为 (main size), 占据的交叉轴的空间为 (cross size)。</p>
<p>这里需要强调，不能先入为主认为宽度就是 main size，高度就是 cross size，这个还要取决于你主轴的方向，如果你垂直方向是主轴，那么项目的高度就是 main size。</p>
<h3 id="flex容器">Flex容器</h3>
<p>首先，实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。</p>
<pre><code class="language-css">.container {
    display: flex | inline-flex;       //可以有两种取值
}
</code></pre>
<blockquote>
<p>分别生成一个块状或行内的 flex 容器盒子。简单说来，如果你使用块元素如 div，你就可以使用 flex，而如果你使用行内元素，你可以使用 inline-flex。</p>
</blockquote>
<p><strong>需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。</strong><br>
有下面六种属性可以设置在容器上，它们分别是：</p>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<h4 id="1-flex-direction-决定主轴的方向即项目的排列方向">1. flex-direction: 决定主轴的方向(即项目的排列方向)</h4>
<pre><code class="language-css">.container {
    flex-direction: row | row-reverse | column | column-reverse;
}
</code></pre>
<p>默认值：row，主轴为水平方向，起点在左端。<br>
<img src="https://dargonlee.github.io/post-images/1582197694806.jpg" alt="" loading="lazy"></p>
<p>row-reverse：主轴为水平方向，起点在右端<br>
<img src="https://dargonlee.github.io/post-images/1582197734826.jpg" alt="" loading="lazy"></p>
<p>column：主轴为垂直方向，起点在上沿<br>
<img src="https://dargonlee.github.io/post-images/1582197778557.jpg" alt="" loading="lazy"></p>
<p>column-reverse：主轴为垂直方向，起点在下沿<br>
<img src="https://dargonlee.github.io/post-images/1582197811839.jpg" alt="" loading="lazy"></p>
<h4 id="2flex-wrap-决定容器内项目是否可换行">2.flex-wrap: 决定容器内项目是否可换行</h4>
<p>默认情况下，项目都排在主轴线上，使用 flex-wrap 可实现项目的换行。</p>
<pre><code class="language-css">.container {
    flex-wrap: nowrap | wrap | wrap-reverse;
}
</code></pre>
<p>默认值：nowrap 不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行。<br>
<img src="https://dargonlee.github.io/post-images/1582197901240.jpg" alt="" loading="lazy"></p>
<p>wrap：项目主轴总尺寸超出容器时换行，第一行在上方<br>
<img src="https://dargonlee.github.io/post-images/1582197926276.jpg" alt="" loading="lazy"></p>
<p>wrap-reverse：换行，第一行在下方<br>
<img src="https://dargonlee.github.io/post-images/1582197952784.jpg" alt="" loading="lazy"></p>
<h4 id="3flex-flow-flex-direction-和-flex-wrap-的简写形式">3.flex-flow: flex-direction 和 flex-wrap 的简写形式</h4>
<pre><code class="language-css">.container {
    flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;
}
</code></pre>
<p>默认值为: row nowrap，感觉没什么卵用，老老实实分开写就好了。这样就不用记住这个属性了。</p>
<h4 id="4-justify-content定义了项目在主轴的对齐方式">4. justify-content：定义了项目在主轴的对齐方式。</h4>
<pre><code class="language-css">.container {
    justify-content: flex-start | flex-end | center | space-between | space-around;
}
</code></pre>
<p><strong>建立在主轴为水平方向时测试，即 flex-direction: row</strong></p>
<p>默认值: flex-start 左对齐<br>
<img src="https://dargonlee.github.io/post-images/1582198060131.jpg" alt="" loading="lazy"></p>
<p>flex-end：右对齐<br>
<img src="https://dargonlee.github.io/post-images/1582198085474.jpg" alt="" loading="lazy"></p>
<p>center：居中<br>
<img src="https://dargonlee.github.io/post-images/1582198111291.jpg" alt="" loading="lazy"></p>
<p>space-between：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙。<br>
<img src="https://dargonlee.github.io/post-images/1582198138167.jpg" alt="" loading="lazy"></p>
<p>space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。<br>
<img src="https://dargonlee.github.io/post-images/1582198162824.jpg" alt="" loading="lazy"></p>
<h4 id="5-align-items-定义了项目在交叉轴上的对齐方式">5. align-items: 定义了项目在交叉轴上的对齐方式</h4>
<pre><code class="language-css">.container {
    align-items: flex-start | flex-end | center | baseline | stretch;
}
</code></pre>
<p><strong>建立在主轴为水平方向时测试，即 flex-direction: row</strong></p>
<p>默认值为 stretch 即如果项目未设置高度或者设为 auto，将占满整个容器的高度。<br>
<img src="https://dargonlee.github.io/post-images/1582198224547.jpg" alt="" loading="lazy"><br>
假设容器高度设置为 100px，而项目都没有设置高度的情况下，则项目的高度也为 100px。</p>
<p>flex-start：交叉轴的起点对齐<br>
<img src="https://dargonlee.github.io/post-images/1582198284299.jpg" alt="" loading="lazy"><br>
假设容器高度设置为 100px，而项目分别为 20px, 40px, 60px, 80px, 100px, 则如上图显示。</p>
<p>flex-end：交叉轴的终点对齐<br>
<img src="https://dargonlee.github.io/post-images/1582198317437.jpg" alt="" loading="lazy"></p>
<p>center：交叉轴的中点对齐<br>
<img src="https://dargonlee.github.io/post-images/1582198350798.jpg" alt="" loading="lazy"></p>
<p>baseline: 项目的第一行文字的基线对齐<br>
<img src="https://dargonlee.github.io/post-images/1582198377647.jpg" alt="" loading="lazy"></p>
<h4 id="6-align-content-定义了多根轴线的对齐方式如果项目只有一根轴线那么该属性将不起作用">6. align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用</h4>
<pre><code class="language-css">.container {
    align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
</code></pre>
<p>这个这样理解：</p>
<p>当你 flex-wrap 设置为 nowrap 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。</p>
<p>当你 flex-wrap 设置为 wrap 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。</p>
<p>建立在主轴为水平方向时测试，即 flex-direction: row, flex-wrap: wrap</p>
<p>默认值为 stretch，看下面的图就很好理解了<br>
<img src="https://dargonlee.github.io/post-images/1582198454881.jpg" alt="" loading="lazy"><br>
从图可以看出又三条轴线(因为容器宽度有限)，当值为 stretch 时会三条轴线平分容器的垂直方向上的空间。</p>
<p>值得注意的是，虽然在每条轴线上项目的默认值也为 stretch，但是由于我每个项目我都设置了高度，所以它并没有撑开整个容器。如果项目不设置高度的话就会变成下面这样：<br>
<img src="https://dargonlee.github.io/post-images/1582198492875.jpg" alt="" loading="lazy"></p>
<p>这个我在前面也有提到(align-items)，这里重点还是理解三条轴线会平分垂直轴上的空间。</p>
<p>flex-start：轴线全部在交叉轴上的起点对齐<br>
<img src="https://dargonlee.github.io/post-images/1582198520321.jpg" alt="" loading="lazy"></p>
<p>flex-end：轴线全部在交叉轴上的终点对齐<br>
<img src="https://dargonlee.github.io/post-images/1582198543212.jpg" alt="" loading="lazy"></p>
<p>center：轴线全部在交叉轴上的中间对齐<br>
<img src="https://dargonlee.github.io/post-images/1582198574863.jpg" alt="" loading="lazy"></p>
<p>space-between：轴线两端对齐，之间的间隔相等，即剩余空间等分成间隙。<br>
<img src="https://dargonlee.github.io/post-images/1582198604298.jpg" alt="" loading="lazy"></p>
<p>space-around：每个轴线两侧的间隔相等，所以轴线之间的间隔比轴线与边缘的间隔大一倍。<br>
<img src="https://dargonlee.github.io/post-images/1582198682468.jpg" alt="" loading="lazy"></p>
<p>到这里关于容器上的所有属性都讲完了，接下来就来讲讲关于在 flex item 上的属性。</p>
<h3 id="flex-项目属性">Flex 项目属性</h3>
<p>有六种属性可运用在 item 项目上：</p>
<ul>
<li>order</li>
<li>flex-basis</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex</li>
<li>align-self</li>
</ul>
<h4 id="1-order-定义项目在容器中的排列顺序数值越小排列越靠前默认值为-0">1. order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0</h4>
<pre><code class="language-css">.item {
    order: &lt;integer&gt;;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dargonlee.github.io/post-images/1582271774683.jpg" alt="" loading="lazy"></figure>
<p>在 HTML 结构中，虽然 -2，-1 的 item 排在后面，但是由于分别设置了 order，使之能够排到最前面。</p>
<h4 id="2-flex-basis-定义了在分配多余空间之前项目占据的主轴空间浏览器根据这个属性计算主轴是否有多余空间">2. flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间</h4>
<pre><code class="language-css">.item {
    flex-basis: &lt;length&gt; | auto;
}
</code></pre>
<p>默认值：auto，即项目本来的大小, 这时候 item 的宽高取决于 width 或 height 的值。</p>
<p><strong>当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。</strong></p>
<ul>
<li>当 flex-basis 值为 0 % 时，是把该项目视为零尺寸的，故即使声明该尺寸为 140px，也并没有什么用。</li>
<li>当 flex-basis 值为 auto 时，则跟根据尺寸的设定值(假如为 100px)，则这 100px 不会纳入剩余空间。</li>
</ul>
<h4 id="3-flex-grow-定义项目的放大比例">3. flex-grow: 定义项目的放大比例</h4>
<pre><code class="language-css">.item {
    flex-grow: &lt;number&gt;;
}
</code></pre>
<p>默认值为 0，即如果存在剩余空间，也不放大<br>
<img src="https://dargonlee.github.io/post-images/1582271906732.jpg" alt="" loading="lazy"></p>
<p>当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。<br>
如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话)</p>
<p>如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p>
<p>当然如果当所有项目以 flex-basis 的值排列完后发现空间不够了，且 flex-wrap：nowrap 时，此时 flex-grow 则不起作用了，这时候就需要接下来的这个属性。</p>
<h4 id="4-flex-shrink-定义了项目的缩小比例">4. flex-shrink: 定义了项目的缩小比例</h4>
<pre><code class="language-css">.item {
    flex-shrink: &lt;number&gt;;
}
</code></pre>
<p>默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。<br>
<img src="https://dargonlee.github.io/post-images/1582271987455.jpg" alt="" loading="lazy"><br>
这里可以看出，虽然每个项目都设置了宽度为 50px，但是由于自身容器宽度只有 200px，这时候每个项目会被同比例进行缩小，因为默认值为 1。<br>
同理可得：</p>
<p>如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。</p>
<p>如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</p>
<h4 id="5-flex-flex-grow-flex-shrink-和-flex-basis的简写">5. flex: flex-grow, flex-shrink 和 flex-basis的简写</h4>
<pre><code class="language-css">.item{
    flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]
}
</code></pre>
<p>flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值是 0 1 auto。</p>
<p>有关快捷值：auto (1 1 auto) 和 none (0 0 auto)</p>
<p>关于 flex 取值，还有许多特殊的情况，可以按以下来进行划分：</p>
<ul>
<li>当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的：</li>
</ul>
<pre><code class="language-css">.item {flex: 1;}
.item {
    flex-grow: 1;
    flex-shrink: 1;
    flex-basis: 0%;
}
</code></pre>
<ul>
<li>当 flex 取值为 0 时，对应的三个值分别为 0 1 0%</li>
</ul>
<pre><code class="language-css">.item {flex: 0;}
.item {
    flex-grow: 0;
    flex-shrink: 1;
    flex-basis: 0%;
}
</code></pre>
<ul>
<li>当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）</li>
</ul>
<pre><code class="language-css">.item-1 {flex: 0%;}
.item-1 {
    flex-grow: 1;
    flex-shrink: 1;
    flex-basis: 0%;
}

.item-2 {flex: 24px;}
.item-2 {
    flex-grow: 1;
    flex-shrink: 1;
    flex-basis: 24px;
}
</code></pre>
<ul>
<li>当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：</li>
</ul>
<pre><code class="language-css">.item {flex: 2 3;}
.item {
    flex-grow: 2;
    flex-shrink: 3;
    flex-basis: 0%;
}
</code></pre>
<ul>
<li>当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的：</li>
</ul>
<pre><code class="language-css">.item {flex: 11 32px;}
.item {
    flex-grow: 11;
    flex-shrink: 1;
    flex-basis: 32px;
}
</code></pre>
<p>建议优先使用这个属性，而不是单独写三个分离的属性。</p>
<p>grow 和 shrink 是一对双胞胎，grow 表示伸张因子，shrink 表示是收缩因子。</p>
<p>grow 在 flex 容器下的子元素的宽度和比容器和小的时候起作用。 grow 定义了子元素的尺寸增长因子，容器中除去子元素之和剩下的尺寸会按照各个子元素的 grow 值进行平分加大各个子元素上。</p>
<h4 id="flex-wrap-与子项的-flex-shrink-flex-grow-之间的关系">flex-wrap 与子项的 flex-shrink、flex-grow 之间的关系</h4>
<p>1.当 flex-wrap 为 wrap | wrap-reverse，且子项宽度和不及父容器宽度时，flex-grow 会起作用，子项会根据 flex-grow 设定的值放大（为0的项不放大）<br>
2.当 flex-wrap 为 wrap | wrap-reverse，且子项宽度和超过父容器宽度时，首先一定会换行，换行后，每一行的右端都可能会有剩余空间（最后一行包含的子项可能比前几行少，所以剩余空间可能会更大），这时 flex-grow 会起作用，若当前行所有子项的 flex-grow 都为0，则剩余空间保留，若当前行存在一个子项的 flex-grow 不为0，则剩余空间会被 flex-grow 不为0的子项占据<br>
3.当 flex-wrap 为 nowrap，且子项宽度和不及父容器宽度时，flex-grow 会起作用，子项会根据 flex-grow 设定的值放大（为0的项不放大）<br>
4.当 flex-wrap 为 nowrap，且子项宽度和超过父容器宽度时，flex-shrink 会起作用，子项会根据 flex-shrink 设定的值进行缩小（为0的项不缩小）。但这里有一个较为特殊情况，就是当这一行所有子项 flex-shrink 都为0时，也就是说所有的子项都不能缩小，就会出现讨厌的横向滚动条<br>
5.总结上面四点，可以看出不管在什么情况下，在同一时间，flex-shrink 和 flex-grow 只有一个能起作用，这其中的道理细想起来也很浅显：空间足够时，flex-grow 就有发挥的余地，而空间不足时，flex-shrink 就能起作用。当然，flex-wrap 的值为 wrap | wrap-reverse 时，表明可以换行，既然可以换行，一般情况下空间就总是足够的，flex-shrink 当然就不会起作用</p>
<h4 id="6-align-self-允许单个项目有与其他项目不一样的对齐方式">6. align-self: 允许单个项目有与其他项目不一样的对齐方式</h4>
<p>单个项目覆盖 align-items 定义的属性</p>
<p>默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p>
<pre><code class="language-css">.item {
     align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
</code></pre>
<p>这个跟 align-items 属性时一样的，只不过 align-self 是对单个项目生效的，而 align-items 则是对容器下的所有项目生效的。<br>
<img src="https://dargonlee.github.io/post-images/1582272279703.jpg" alt="" loading="lazy"></p>
<p>容器 align-items 设置为 flex-start，而第三</p>
<blockquote>
<p>最后 这篇文章写的flex布局也不错<br>
https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/?shrink=1</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dart语法入门]]></title>
        <id>https://dargonlee.github.io/post/dart-yu-fa-ru-men/</id>
        <link href="https://dargonlee.github.io/post/dart-yu-fa-ru-men/">
        </link>
        <updated>2020-02-18T11:51:21.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>跟Java等很多语言不同的是，Dart没有public protected private等关键字，如果某个变量以下划线 _ 开头，代表这个变量在库中是私有的。Dart中变量可以以字母或下划线开头，后面跟着任意组合的字符或数字</p>
</blockquote>
<p>比如下面代码</p>
<pre><code class="language-dart">main() {
   String _name = '';//private变量
   String name = ''//public变量
}
</code></pre>
<h3 id="变量">变量</h3>
<h4 id="变量的定义">变量的定义</h4>
<pre><code class="language-dart">main() {
    var a = 1;
    int b = 10; 
    String s = &quot;hello&quot;;
    dynamic c = 0.5;
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>跟Java等很多语言不同的是，Dart没有public protected private等关键字，如果某个变量以下划线 _ 开头，代表这个变量在库中是私有的。Dart中变量可以以字母或下划线开头，后面跟着任意组合的字符或数字</p>
</blockquote>
<p>比如下面代码</p>
<pre><code class="language-dart">main() {
   String _name = '';//private变量
   String name = ''//public变量
}
</code></pre>
<h3 id="变量">变量</h3>
<h4 id="变量的定义">变量的定义</h4>
<pre><code class="language-dart">main() {
    var a = 1;
    int b = 10; 
    String s = &quot;hello&quot;;
    dynamic c = 0.5;
}
</code></pre>
<!-- more -->
<blockquote>
<p>你可以自己定义你数据类型比如<code>String</code>  <code>int</code> 当然也可以用<code>var</code>  <code>dynamic</code>定义变量，dart会自动推断其数据类型。</p>
</blockquote>
<h4 id="final和const">final和const</h4>
<p>如果你定义一个变量后就不想改变其值的话，使用<code>final</code>和<code>const</code>去定义。不要使用<code>var</code>或者其他类型去定义。</p>
<p>用<code>final</code>定义的变量只能赋值一次，用<code>const</code>定义的变量是一个编译时的常量。</p>
<p>（可以理解为：final修饰的变量是不可改变的，而const修饰的表示一个常量。）</p>
<blockquote>
<p><em>注意：实例变量可以是final的但不能是const的</em></p>
</blockquote>
<pre><code class="language-objectivec">var count = 10;final Num = count;// final 只能赋值一次const Num1 = 10;// const赋值必须是编译时常量
</code></pre>
<h4 id="final和const的区别">final和const的区别</h4>
<ul>
<li>
<p><code>final</code>定义的变量只能初始化一次，二次赋值就会报错，赋的值可以是常量也可以不是常量。</p>
</li>
<li>
<p><code>final</code>是懒加载初始化，即程序运行也不一定初始化，只有真正用到的时候才会初始化。</p>
</li>
</ul>
<h3 id="dart的内建数据类型">Dart的内建数据类型</h3>
<p>有如下几种内建的数据类型</p>
<ul>
<li>
<p><code>numbers</code></p>
</li>
<li>
<p><code>strings</code></p>
</li>
<li>
<p><code>booleans</code></p>
</li>
<li>
<p><code>lists</code></p>
</li>
<li>
<p><code>maps</code></p>
</li>
<li>
<p><code>runes</code>UTF-32字符集的字符 符号文字</p>
</li>
<li>
<p><code>symbols</code></p>
</li>
</ul>
<p>下面用一段代码来演示以上各类数据类型：</p>
<pre><code class="language-dart">// numbers
var a = 0;
int b = 1;
double c = 0.1;

// strings
var s1 = 'hello';
String s2 = 'world';

// booleans
var real = true;
bool isReal = false;

// lists
var array = [1, 2, 3, 4, 5];
List&lt;String&gt; array1 = ['hello','world','!!!'];
List&lt;dynamic&gt; array = [1, true, 'haha', 1.0];
# 这里的 `dynamic` 是泛型

// maps
var map = new Map();
map['name'] = 'zhangsan';
map['age'] = 10;
Map m = new Map();
m['a'] = 'a';

// chars
var clapping = '\u{1f44f}';
print(clapping); // 打印的是拍手emoji的表情


// Symbol对象表示在Dart程序中声明的运算符或标识符(不常用)
print(#s == new Symbol(&quot;s&quot;)); // true

</code></pre>
<h3 id="函数">函数</h3>
<h4 id="函数的一般声明形式">函数的一般声明形式</h4>
<pre><code class="language-dart">int add(int a, int b) {  return a + b;}
</code></pre>
<p><code>int</code>为返回值类型，<code>add</code>为函数名称， <code>()</code>里面的为参数</p>
<h4 id="函数的返回值">函数的返回值</h4>
<p>Dart是一个面向对象的编程语言，所以即使函数也是一个对象，也有一种类型<code>Function</code>，这就意味着可以赋值给某个变量或者当作参数传给另一个函数。</p>
<p>虽然Dart推荐给函数加上返回值，但是不加也能正常工作。另外你可以用<code>=&gt;</code>代替return语法，例如下面的例子</p>
<pre><code class="language-dart">// 带返回值
int add(int a, int b) {
    return a + b;    
}

// 不带返回值
add2(int a, int b) {
    return a + b;    
}
// 不带返回值的官方写法（一般都用上面的写法）
void add3(int a, int b) {
    return a + b;    
}

// 简写形式
add3(int a, int b) =&gt; a + b;

main() {
  print(add(1, 2)); // 3
  print(add2(2, 3)); // 5
  print(add3(1, 2)); // 3
}
</code></pre>
<p>所有的函数都有返回值，如果没有指定return语句，那么该函数的返回值为null。</p>
<h4 id="命名参数">命名参数</h4>
<pre><code class="language-dart">// 写法一
sayHello({String name}) {
    print(&quot;my name is $name&quot;);    
}

// 写法二
sayHello1({name: String}) { // 不建议使用
    print(&quot;my name is $name&quot;);
}

// 写法三
sayHello2(String name) {
    print(&quot;my name is $name&quot;);  
}

// 写发四
sayHello3({String name, @required String ids}) {
    print(&quot;my name is $name and $ids&quot;);
}

main() {
  // 打印 my name is zhangsan
  sayHello(name: 'zhangsan');

  // 打印 my name is wangwu
  sayHello1(name: 'wangwu');
}
</code></pre>
<p>从上可以看出函数参数的形式有三种，<code>写法三</code>和<code>写法一二</code>不同，因为它没有带大括号，这里说明下，<code>写法三</code>的形式为必需参数，而<code>写发一二</code>参数是可选的，即你不传参数也是可以调用成功的。如果你想在<code>写法一二</code>声明必选参数，需要在声明的参数前面加上<code>@required</code>关键字。例<code>写法四</code></p>
<h4 id="位置参数">位置参数</h4>
<p>使用中括号<code>[]</code>括起来的参数是函数的位置参数，代表该参数可传可不传，位置参数只能放在函数的参数列表的最后面，如下代码所示：</p>
<pre><code class="language-dart">sayHello(String name, int age, [String body]) { 
// 位置参数可以有多个，比如[String a, int b]
  StringBuffer sb = new StringBuffer();
  sb.write(&quot;hello, this is $name and I am $age years old&quot;);
  if (hobby != null) {
    sb.write(&quot;, my hobby is $hobby&quot;);
  }
  print(sb.toString());    
}

main() {
  // hello, this is zhangsan and I am 20 years old
  sayHello(&quot;zhangsan&quot;, 20);
  // hello, this is zhangsan and I am 20 years old, my hobby is play football
  sayHello(&quot;zhangsan&quot;, 20, &quot;play football&quot;);
}
</code></pre>
<h4 id="参数默认值">参数默认值</h4>
<p>你可以为命名参数或者位置参数设置默认值，如下代码所示</p>
<pre><code class="language-dart">// 命名参数的默认值
int add({int a, int b = 3}) { // 不能写成：int add({a: int, b: int = 3})
  return a + b;
}

// 位置参数的默认值
int sum(int a, int b, [int c = 3]) {
  return a + b + c;
}
</code></pre>
<h4 id="main函数">main()函数</h4>
<p>不论在Dart还是Flutter中，必须都需要一个顶层的main()函数，它是整个应用的入口函数，main()函数的返回值是void，还有一个可选的参数，参数类型是List<String>。</p>
<h4 id="函数作为一类对象">函数作为一类对象</h4>
<p>你可以将一个函数作为参数传给另一个函数，比如下面的代码：</p>
<pre><code class="language-dart">printNum(int a) {
    print(&quot;$a&quot;);    
}
main() {
  //  依次打印：
  //  1
  //  2
  //  3
  var arr = [1, 2, 3];
  arr.forEach(printNum);
}
</code></pre>
<p>你也可以将一个函数赋值给某个变量，比如下面的代码：</p>
<pre><code class="language-dart">printNum(int a) {
  print(&quot;$a&quot;);
}

main() {
    var f1 = printNum;
    Function f2 = printNum;
    var f3 = (int a) =&gt; print(&quot;a = $a&quot;);
    f1(1);
    f2(2);
    f3(6);
}
</code></pre>
<h4 id="匿名函数">匿名函数</h4>
<p>大多数函数都是有名称的，比如main() printName()等，但是你也可以写匿名函数，如果你对Java比较熟悉，那下面的Dart代码你肯定也不会陌生：</p>
<pre><code class="language-dart">test(Function callback) {
    callback(&quot;hello&quot;);    
}

main() {
  test((param) {
    // 打印hello
    print(param);
  });
}
</code></pre>
<p>匿名函数类似于Java中的接口，往往在某个函数的参数为函数时使用到。</p>
<h4 id="运算符">运算符</h4>
<pre><code class="language-dart">main() {
  // 与Java相同的运算符操作

  int a = 1;
  ++a;
  a++;
  var b = 1;
  print(a == b);  // false
  print(a * b); // 3
  bool real = false;
  real ? print('real') : print('not real'); // not real
  print(real &amp;&amp; a == b); // false
  print(real || a == 3); // true
  print(a != 2); // true
  print(a &lt;= b); // false
  var c = 9;
  c += 10;
  print(&quot;c = $c&quot;); // c = 19
  print(1&lt;&lt;2); // 4

  // 与Java不太一样的运算符操作

  // is运算符用于判断一个变量是不是某个类型的数据
  // is!则是判断变量不是某个类型的数据
  var s = &quot;hello&quot;;
  print(s is String); // true
  var num = 6;
  print(num is! String); // true

  // ~/才是取整运算符，如果使用/则是除法运算，不取整
  int k = 1;
  int j = 2;
  print(k / j); // 0.5
  print(k ~/ j); // 0

  // as运算符类似于Java中的cast操作，将一个对象强制类型转换
  (emp as Person).teach();

  // ??=运算符 如果 ??= 运算符前面的变量为null，则赋值，否则不赋值
  var param1 = &quot;hello&quot;, param2 = null;
  param1 ??= &quot;world&quot;;
  param2 ??= &quot;world&quot;;
  print(&quot;param1 = $param1&quot;); // param1 = hello
  print(&quot;param2 = $param2&quot;); // param2 = world
  
  // ?.运算符
  var str1 = &quot;hello world&quot;;
  var str2 = null;
  print(str1?.length); // 11
  print(str2?.length); // null 
  print(str2.length); // 报错
}
</code></pre>
<h4 id="运算符级联操作">…运算符（级联操作）</h4>
<pre><code class="language-dart">class Person {
  eat() {
    print(&quot;I am eating...&quot;);
  }

  sleep() {
    print(&quot;I am sleeping...&quot;);
  }

  study() {
    print(&quot;I am studying...&quot;);
  }
}

main() {
  // 依次打印
  //  I am eating...
  //  I am sleeping...
  //  I am studying...
  new Person()..eat()
      ..sleep()
      ..study();
}
</code></pre>
<p>可以看到，使用…调用某个对象的方法（或者成员变量）时，返回值是这个对象本身，所以你可以接着使用…调用这个对象的其他方法.</p>
<h4 id="控制流程">控制流程</h4>
<pre><code class="language-dart">main() {
  // if else语句
  int score = 80;
  if (score &lt; 60) {
    print(&quot;so bad!&quot;);
  } else if (score &gt;= 60 &amp;&amp; score &lt; 80) {
    print(&quot;just so so!&quot;);
  } else if (score &gt;= 80) {
    print(&quot;good job!&quot;);
  }

  // switch语句
  String a = &quot;hello&quot;;
  // case语句中的数据类型必须是跟switch中的类型一致
  switch (a) {
    case &quot;hello&quot;:
      print(&quot;haha&quot;);
      break;
    case &quot;world&quot;:
      print(&quot;heihei&quot;);
      break;
    default:
      print(&quot;WTF&quot;);
  }

  // for语句
  List&lt;String&gt; list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
  for (int i = 0; i &lt; list.length; i++) {
    print(list[i]);
  }
  for (var i in list) {
    print(i);
  }
  // 这里的箭头函数参数必须用圆括号扩起来
  list.forEach((item) =&gt; print(item));

  // while语句
  int start = 1;
  int sum = 0;
  while (start &lt;= 100) {
    sum += start;
    start++;
  }
  print(sum);

  // try catch语句
  try {
    print(1 ~/ 0);
  } catch (e) {
    // IntegerDivisionByZeroException
    print(e);
  }
  try {
    1 ~/ 0;
  } on IntegerDivisionByZeroException { // 捕获指定类型的异常
    print(&quot;error&quot;); // 打印出error
  } finally {
    print(&quot;over&quot;); // 打印出over
  }
}
</code></pre>
<h3 id="类class">类（Class）</h3>
<h4 id="类的定义与构造方法">类的定义与构造方法</h4>
<p>Dart中的类没有访问控制，所以你不需要用private, protected, public等修饰成员变量或成员函数，一个简单的类如下代码所示：</p>
<pre><code class="language-dart">class Person {
    String name;
    int age;
    String gender;
    // 构造函数
    Person(this.name, this.age, this.gender);
    // public方法
    sayHello() {
      print(&quot;hello, this is $name, I am $age years old, I am a $gender&quot;); 
    }
    // private方法
     _sayHello() {
       print(&quot;&quot;);
     }
}
</code></pre>
<p>上面的构造函数等同于下面的写法</p>
<pre><code class="language-dart">Person(String name, int age, String gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
}
</code></pre>
<p>要调用Person类的成员变量或成员方法，可以用下面的代码：</p>
<pre><code class="language-dart">var p = new Person(&quot;zhangsan&quot;, 20, &quot;male&quot;);
p.sayHello(); // hello, this is zhangsan, I am 20 years old, I am a male
p.age = 50;
p.gender = &quot;female&quot;;
p.sayHello();
</code></pre>
<p>类除了有跟类名相同的构造方法外，还可以添加命名的构造方法，如下代码所示</p>
<pre><code class="language-dart">class Point {
    num x, y;
    Point(this.x, this.y);
    //类的命名构造方法
    Point.origin() {
        x = 0;
        y = 0;
    }
}

main() {
    // 调用Point类的命名构造方法origin()
    var 
}
</code></pre>
<p>Dart中使用extends关键字做类的继承，如果一个类只有命名的构造方法，在继承时需要注意，如下代码：</p>
<pre><code class="language-dart">class Human {
    String name;
    Human.fromJson(Map data) {
        print(&quot;Human's fromJson constructor&quot;);
    }
}

class Man extend Human {
    Man.fromJson(Map data) : super.fromJson(data) {
        print(&quot;Man's fromJson constructor&quot;);
    }
}
</code></pre>
<p>由于Human类没有默认构造方法，只有一个命名构造方法fromJson，所以在Man类继承Human类时，需要调用父类的fromJson方法做初始化，而且必须使用Man.fromJson(Map data) : super.fromJson(data)这种写法，而不是像Java那样将super写到花括号中。</p>
<p>有时候你仅仅只是在某个类的构造方法中，调用这个类的另一个构造方法，你可以这么写：</p>
<pre><code class="language-dart">class Point {
  num x, y;
  Point(this.x, this.y);
  // 命名构造方法调用了默认的构造方法
  Point.alongXAxis(num x) : this(x, 0);
}
</code></pre>
<h4 id="类的成员方法">类的成员方法</h4>
<p>一个类的成员方法是一个函数，为这个类提供某些行为。上面的代码中已经有了一些类的成员方法的定义，这些定义方式跟Java很类似，你可以为某个类的成员变量提供getter/setter方法，如下代码：</p>
<pre><code class="language-dart">class Rectangle {
  num left, top, width, height;
    // 构造方法传入left, top, width, height几个参数
  Rectangle(this.left, this.top, this.width, this.height);
  // right, bottom两个成员变量提供getter/setter方法
  num get right =&gt; left + width;
  set right(num value) =&gt; left = value - width;
  
  num get bottom =&gt; top + height;
  set bottom(num value) =&gt; top = value - height;
}
</code></pre>
<h4 id="抽象类和抽象方法">抽象类和抽象方法</h4>
<p>使用abstract修饰一个类，则这个类是抽象类，抽象类中可以有抽象方法和非抽象方法，抽象方法没有方法体，需要子类去实现，如下代码：</p>
<pre><code class="language-dart">abstract class Doer {
  // 抽象方法，没有方法体，需要子类去实现
  void doSomething();
  // 普通的方法
  void greet() {
    print(&quot;hello world!&quot;);
  }
}

class EffectiveDoer extends Doer {
  // 实现了父类的抽象方法
  void doSomething() {
    print(&quot;I'm doing something...&quot;);
  }
}
</code></pre>
<h4 id="枚举类">枚举类</h4>
<p>使用enum关键字定义一个枚举类，这个语法跟Java类似，如下代码：</p>
<pre><code class="language-dart">enum Color { red, green, blue }
</code></pre>
<p>要获取枚举中所有值的列表，请使用enum的values 常量。</p>
<pre><code class="language-dart">List colors = Color.values;assert(colors[2] == Color.blue);
</code></pre>
<p>您可以在switch语句中使用enum，如果switch的case不处理enum的所有值，将会报一个警告消息:</p>
<pre><code class="language-dart">var aColor = Color.blue;

switch (aColor) {
  case Color.red:
    print('Red as roses!');
    break;
  case Color.green:
    print('Green as grass!');
    break;
  default: // Without this, you see a WARNING.
    print(aColor); // 'Color.blue'
}
</code></pre>
<h4 id="mixins">mixins</h4>
<p>mixins是一个重复使用类中代码的方式，比如下面的代码：</p>
<pre><code class="language-dart">class A {
  a() {
    print(&quot;A's a()&quot;);
  }
}

class B {
  b() {
    print(&quot;B's b()&quot;);
  }
}

// 使用with关键字，表示类C是由类A和类B混合而构成
class C = A with B;

main() {
  C c = new C();
  c.a(); // A's a()
  c.b(); // B's b()
}
</code></pre>
<h4 id="静态成员变量和静态成员方法">静态成员变量和静态成员方法</h4>
<pre><code class="language-dart">// 类的静态成员变量和静态成员方法
class Cons {
  static const name = &quot;zhangsan&quot;;
  static sayHello() {
    print(&quot;hello, this is ${Cons.name}&quot;);
  }
}

main() {
  Cons.sayHello(); // hello, this is zhangsan
  print(Cons.name); // zhangsan
}
</code></pre>
<h4 id="dart库libraries">Dart库（Libraries）</h4>
<p>Dart目前已经有很多的库提供给开发者，许多功能不需要开发者自己去实现，只需要导入对应的包即可，使用import语句来导入某个包，比如下面的代码</p>
<pre><code class="language-dart">import 'dart:html';
</code></pre>
<p>如果你想导入自己写的某个代码文件，使用相对路径即可，例如当前有一个demo.dart文件，跟该文件同级目录下有个util.dart文件，文件代码如下：</p>
<pre><code class="language-dart">// util.dart文件内容

int add(int a, int b) {
  return a + b;
}
</code></pre>
<p>在demo.dart文件中如果要引用util.dart文件，使用下面的方式导入：</p>
<pre><code class="language-dart">// demo.dart

import './util.dart';

main() {
  print(add(1, 2));
}
</code></pre>
<p>你可以使用as关键字为导入的某个包设置一个前缀，或者说别名，比如下面的代码：</p>
<pre><code class="language-dart">import 'package:lib1/lib1.dart';
import 'package:lib2/lib2.dart' as lib2;

// Uses Element from lib1.
Element element1 = Element();

// Uses Element from lib2.
lib2.Element element2 = lib2.Element();
</code></pre>
<p>你也可以在导入包时使用show hide关键字来导入某个包中的部分功能，比如下面的代码：</p>
<pre><code class="language-dart">// 只导入foo
import 'package:lib1/lib1.dart' show foo;

// 导入除了foo的所有其他部分
import 'package:lib2/lib2.dart' hide foo;
</code></pre>
<p>导入包时使用deferred as可以让这个包懒加载，懒加载的包只会在该包被使用时得到加载，而不是一开始就加载，比如下面的代码：</p>
<pre><code class="language-dart">import 'package:greetings/hello.dart' deferred as hello;
</code></pre>
<h4 id="异步">异步</h4>
<p>Dart提供了类似ES7中的async await等异步操作，这种异步操作在Flutter开发中会经常遇到，比如网络或其他IO操作，文件选择等都需要用到异步的知识。<br>
async和await往往是成对出现的，如果一个方法中有耗时的操作，你需要将这个方法设置成async，并给其中的耗时操作加上await关键字，如果这个方法有返回值，你需要将返回值塞到Future中并返回，如下代码所示：</p>
<pre><code class="language-dart">Future checkVersion() async {
  var version = await lookUpVersion();
  // Do something with version
}
</code></pre>
<p>下面的代码使用Dart从网络获取数据并打印出来：</p>
<pre><code class="language-dart">import 'dart:async';
import 'package:http/http.dart' as http;

Future&lt;String&gt; getNetData() async{
  http.Response res = await http.get(&quot;http://www.baidu.com&quot;);
  return res.body;
}

main() {
  getNetData().then((str) {
    print(str);
  });
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS开发将一个工程添加到另一个工程中]]></title>
        <id>https://dargonlee.github.io/post/ios-kai-fa-jiang-yi-ge-gong-cheng-tian-jia-dao-ling-yi-ge-gong-cheng-zhong/</id>
        <link href="https://dargonlee.github.io/post/ios-kai-fa-jiang-yi-ge-gong-cheng-tian-jia-dao-ling-yi-ge-gong-cheng-zhong/">
        </link>
        <updated>2019-11-16T06:38:45.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>一个项目引用另一个项目这里列举两种情况</p>
<ul>
<li>一个 Single View App 项目要引用另一个Single View App 项目</li>
<li>一个 Single View App 项目要引用 动态库的项目（Cocoa Touch Framework）</li>
</ul>
</blockquote>
<h4 id="先说第一种情况的做法">先说第一种情况的做法</h4>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>一个项目引用另一个项目这里列举两种情况</p>
<ul>
<li>一个 Single View App 项目要引用另一个Single View App 项目</li>
<li>一个 Single View App 项目要引用 动态库的项目（Cocoa Touch Framework）</li>
</ul>
</blockquote>
<h4 id="先说第一种情况的做法">先说第一种情况的做法</h4>
<!-- more -->
<ul>
<li>先在一个文件夹下 新建两个 Single View App 项目 一个为demo1 另一个为demo2</li>
</ul>
<blockquote>
<p>注意 现在的需求是 <code>demo1 要引用 demo2</code></p>
</blockquote>
<ul>
<li>
<p>然后在demo1项目中新建一个Group 命名为 <code>Frameworks</code> 创建完成如下图<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-a9bd6106264a07eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100047@2x.png" loading="lazy"></p>
</li>
<li>
<p>然后 <code>show in finder</code> <code>Frameworks</code> 把<code>demo2</code> 拖进去 完成后如下图<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-03744768dbf8acda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100400@2x.png" loading="lazy"></p>
</li>
<li>
<p>最后 进入到 <code>Frameworks</code>里面的 <code>demo2</code>找到 <code>demo2.xcodeproj</code> 然后把  <code>demo2.xcodeproj</code>  拖动到 <code>demo1</code>的<code>Frameworks</code>文件夹里面 操作完成如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-20a3f6a7cdbf069b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100707@2x.png" loading="lazy"></p>
</li>
<li>
<p>下面开始操作<code>demo2</code>了</p>
</li>
<li>
<p>选中 <code>Frameworks</code>里面的 <code>demo2.xcodeproj</code> 添加一个 Target 操作如图所示</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/646265-64fdf9f64b75e438.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100943@2x.png" loading="lazy"></figure>
<p><em><strong>创建动态库</strong></em></p>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/646265-e06cc019ed28e160.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100959@2x.png" loading="lazy"></figure>
<blockquote>
<p>我这里命名的target 为<code>xxx</code> 你可以按需求命名 因为到时候在 <code>demo1</code>中导入头文件的时候 就是这个名字</p>
</blockquote>
<ul>
<li>在 <code>demo2</code>中创建一个 <code>Person</code>类 （这个类就是一会我们要在<code>demo1</code>中使用的） 操作完成如下图<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-11a7c5c634e49ff6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-101342@2x.png" loading="lazy"></li>
</ul>
<blockquote>
<p>注意要想在 <code>demo1</code>使用的文件添加到 <code>xxx</code> 的target当中去 如下图所示 如果又想给<code>demo1</code>用又想自己用 那就两个target都勾选</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://upload-images.jianshu.io/upload_images/646265-14c3ab67d01a6f1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<ul>
<li>然后选中 刚才创建的那个 <code>xxx</code>target 进行如下图操作所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-e4097bda92932e75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-101451@2x.png" loading="lazy"></li>
</ul>
<blockquote>
<p>上图操作为 把<code>Project</code> 中的 <code>Person.h</code> 拖动到 <code>Public</code>中</p>
</blockquote>
<ul>
<li>
<p>然后选中 <code>demo1</code>进行如下图操作<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-6199f3ebc95efdd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-102412@2x.png" loading="lazy"></p>
</li>
<li>
<p>然后继续设置 <code>demo1</code>  在 <code>Build Settings</code>中设置<code>Header Search Paths</code> 的路径为 <code>${SRCROOT}/Frameworks/demo2</code> 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-1003fdf2f8b79706.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-102551@2x.png" loading="lazy"></p>
</li>
<li>
<p>至此 一个项目引入另一个项目的功能就完成了 在 <code>demo1</code>中 就可以快乐的使用 <code>demo2</code>的文件了 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-ae52f9c5f13fe3e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-102917@2x.png" loading="lazy"></p>
</li>
</ul>
<h1 id="下面是-single-view-app-项目要引用-动态库的项目cocoa-touch-framework">下面是 Single View App 项目要引用 动态库的项目（Cocoa Touch Framework）</h1>
<blockquote>
<p>思路跟上面差不多</p>
</blockquote>
<p>这里以 <code>Demo1</code> 为例子 以下图所示 操作<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-e31ad3c0f0dec7a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<p>然后按照下图选择创建动态库<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-e06cc019ed28e160.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100959@2x.png" loading="lazy"><br>
然后创建好的动态库如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-d103b7200d550368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<p>我在动态库里面 新建了 一个<code>Person</code>文件，并声明了一个属性和一个方法<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-e7048f8d3422fd79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<p>切记箭头指向的地方 如果在 <code>UUPerson</code> 中打钩就是只在<code>UUPerson</code>动态库中用。<br>
然后在 动态库的头文件中，配置要暴露出去的头文件 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-2e912de99b775b57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<p>接着就要配置外界能访问的头文件了 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-167dac6407dbb774.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<blockquote>
<p>把要对外的 <code>.h</code>文件都拖动到 Public的里面去</p>
</blockquote>
<p>然后就可以在当前项目中使用了 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-5035cf57f5cfad11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决定时器的循环引用]]></title>
        <id>https://dargonlee.github.io/post/jie-jue-ding-shi-qi-de-xun-huan-yin-yong/</id>
        <link href="https://dargonlee.github.io/post/jie-jue-ding-shi-qi-de-xun-huan-yin-yong/">
        </link>
        <updated>2019-11-15T02:40:51.000Z</updated>
        <summary type="html"><![CDATA[<p>一般使用定时器的方法，在控制器返回上级的时候。定时器都不会停止，会导致循环引用，控制器的<code>delloc</code>方法不会调用。<br>
以下两种方式就是为了解决，定时器在控制器返回上级的时候解决循环引用的问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一般使用定时器的方法，在控制器返回上级的时候。定时器都不会停止，会导致循环引用，控制器的<code>delloc</code>方法不会调用。<br>
以下两种方式就是为了解决，定时器在控制器返回上级的时候解决循环引用的问题。</p>
<!-- more --> 
<h5 id="在控制器中使用定时器常规的方法">在控制器中使用定时器常规的方法</h5>
<pre><code class="language-objectivec">@interface ViewController ()

@property (nonatomic,strong) NSTimer *timer;

@property (nonatomic,strong) CADisplayLink *link;

@end
</code></pre>
<pre><code class="language-objectivec">
- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    // Timer的使用
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTest) userInfo:nil repeats:YES];
    
    // CADisplayLink的使用
    self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(timerTest)];
    [self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
}

- (void)timerTest
{
    NSLog(@&quot;%s&quot;, __func__);
}
</code></pre>
<p>以上这种写法就是常规的写法，就是在一个控制器push到当前这个控制器的时候开启定时器。<br>
但是这种写法有问题，会产生循环引用问题，从而导致内存泄露。<br>
<code>ViewController</code> 引用 <code>timer定时器</code> <code>timer</code>的<code>target</code>又引用<code>ViewController</code> 而且三者都是使用 <code>storng</code>引用 这样在 <code>ViewController</code>返回上级的时候，不会调用<code>delloc</code>方法 从而导致循环引用。</p>
<h4 id="解决方法的思路">解决方法的思路：</h4>
<p>我们知道引起循环引用的问题是 <code>ViewController</code> <code>timer</code> <code>timer的target</code> 三者都是强引用导致的 我们只要在这个三个中间一个地方给设置<code>weak</code>引用 就不会产生循环引用了。<br>
思路就是 -&gt; 设置<code>timer</code>的<code>target</code>的时候不要直接设置 <code>ViewController</code> 而是设置一个 自定义的对象 比如 <code>TimerTarget</code> 然后由这个对象对控制器<code>弱引用</code>，本来由控制器的直接调用的定时方法，现在由 <code>TimerTarget</code> 对象对控制器进行转发。从而达到解决循环引用的问题。<br>
代码如下：</p>
<pre><code class="language-objectivec">
- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    
    self.link = [CADisplayLink displayLinkWithTarget:[TimerTarget proxyWithTarget:self] selector:@selector(timerTest)];
    
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[TimerTarget proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];
}

- (void)timerTest
{
    NSLog(@&quot;%s&quot;, __func__);
}
</code></pre>
<p><code>TimerTarget对象的方法实现</code></p>
<pre><code class="language-objc">@interface TimerTarget : NSObject

@property (nonatomic, weak) id target;
// 接收一个可以相应 定时器的对象
+ (instancetype)proxyWithTarget:(id)target;

@end


+ (instancetype)proxyWithTarget:(id)target
{
    TimerTarget *targets = [[TimerTarget alloc]init];
    targets.target = target;//然后对外部的对象进行弱引用
    return targets;
}
// 在定时器给当前对象发送方法的时候 会走当前对象的消息转发机制 
// 然后可以在这个方法里面对弱应用的对象去响应要调用的方法
- (id)forwardingTargetForSelector:(SEL)aSelector
{
    return self.target;
}
</code></pre>
<blockquote>
<p>上面的方法可以解决问题，但是这样效率不够高。因为在 <code>TimerTarget</code> 在做消息转发之前，会对父类方法查找和方法缓存中去找方法。这样效率不高。</p>
</blockquote>
<p>下面介绍一个苹果提供专门进行消息转发的类叫<code>NSProxy</code> 上面的解决方法我们是继承<code>NSObject</code> 下面我们可以直接继承这个类<br>
代码如下：</p>
<pre><code class="language-objectivec">@interface TimerProxy : NSProxy

@property (nonatomic, weak) id target;

+ (instancetype)proxyWithTarget:(id)target;

@end



+ (instancetype)proxyWithTarget:(id)target
{
    // NSProxy 不需要init方法
    TimerProxy *targets = [TimerProxy alloc];
    targets.target = target;
    return targets;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel
{
    return [self.target methodSignatureForSelector:sel];
}

- (void)forwardInvocation:(NSInvocation *)invocation
{
    [invocation invokeWithTarget:self.target];
}
</code></pre>
<p>这样的话 在定时的方法来的时候可以直接进行转发，而不会再去父类找了。</p>
<h4 id="补充">补充</h4>
<pre><code class="language-objectivec">__weak typeof(self) weakSelf = self;
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
        [weakSelf timerTest];
    }];
</code></pre>
<p>这种block的方法也可以解决循环引用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NSLayoutAnchor实践]]></title>
        <id>https://dargonlee.github.io/post/nslayoutanchor-shi-jian/</id>
        <link href="https://dargonlee.github.io/post/nslayoutanchor-shi-jian/">
        </link>
        <updated>2019-11-14T06:37:44.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>iOS如果项目中不用xib或者storyboard的话，给view做约束一般都是用第三方库<code>Masonry</code>，为什么不用系统提供的AutoLayout呢？<code>因为代码太多不好用</code></p>
</blockquote>
<ul>
<li>今天给大家介绍一个苹果iOS9后更新的一个布局的好用的类 <code>NSLayoutAnchor</code></li>
</ul>
<h4 id="分别用-nslayoutconstraint-nslayoutanchor-和-masonry来进行如下图所示的布局">分别用 <code>NSLayoutConstraint</code> <code>NSLayoutAnchor</code> 和 <code>Masonry</code>来进行如下图所示的布局</h4>
<blockquote>
<p>在进行布局的时候，我会分别讲解下系统 <code>NSLayoutConstraint</code> <code>NSLayoutAnchor</code>两种布局的方法使用和参数说明<br>
至于<code>Masonry</code>的使用 我就不做多介绍了（官方介绍的很清楚，网上资料也不少）</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>iOS如果项目中不用xib或者storyboard的话，给view做约束一般都是用第三方库<code>Masonry</code>，为什么不用系统提供的AutoLayout呢？<code>因为代码太多不好用</code></p>
</blockquote>
<ul>
<li>今天给大家介绍一个苹果iOS9后更新的一个布局的好用的类 <code>NSLayoutAnchor</code></li>
</ul>
<h4 id="分别用-nslayoutconstraint-nslayoutanchor-和-masonry来进行如下图所示的布局">分别用 <code>NSLayoutConstraint</code> <code>NSLayoutAnchor</code> 和 <code>Masonry</code>来进行如下图所示的布局</h4>
<blockquote>
<p>在进行布局的时候，我会分别讲解下系统 <code>NSLayoutConstraint</code> <code>NSLayoutAnchor</code>两种布局的方法使用和参数说明<br>
至于<code>Masonry</code>的使用 我就不做多介绍了（官方介绍的很清楚，网上资料也不少）</p>
</blockquote>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/646265-8b480a3ee6085ef6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190509-105625@2x.png" loading="lazy"></figure>
<h3 id="第一种-nslayoutconstraint">第一种 <code>NSLayoutConstraint</code></h3>
<pre><code class="language-objectivec"># NSLayoutConstraint 的核心布局方法
[NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];

</code></pre>
<p>上面代码的白话文就是<br>
<code>红色view 的 centerX 等于 self.view 的 centerX 1.0倍 加 0</code><br>
如果还不是很明白的话 看下图就一目了然了</p>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/646265-b155f2e0c3eaa558.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190509-110720@2x.png" loading="lazy"></figure>
<h4 id="接下来我们来讲一下初始化方法中各个参数的意义">接下来我们来讲一下初始化方法中各个参数的意义：</h4>
<pre><code class="language-objectivec">item:        要布局的view

attribute: 是一个NSLayoutAttribute枚举，可以看到他的枚举值有 left、right、bottom、top 等

relatedBy:  是一个NSLayoutRelation枚举，他的枚举值有 lessThanOrEqual（小于等于）、equal（等于）、greaterThanOrEqual（大于等于）， 指定 view1和接下来那个参数 view2两个视图之
间的约束关系的

toItem:     第一个view的参照view 你要参照哪个view 这个就是哪个view（本例中的是self.view控制器view）

attribute:  和第二个参数一样，是来表示第一个视图对第二个视图的
参考位置 ，上下左右 还是 center等

multiplier: 是来计算两个视图之间约束的倍数关系

constant:  是来计算两个视图之间约束的倍数关系的基础上再加一些常量

</code></pre>
<h4 id="下面看约束代码">下面看约束代码</h4>
<pre><code class="language-objectivec">// 布局redView
    NSLayoutConstraint *centerX = [NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];
    NSLayoutConstraint *top = [NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeTopMargin multiplier:1.0 constant:10];
    
    NSLayoutConstraint *width = [NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:200];
    NSLayoutConstraint *heith = [NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:200];
    
    //可以单个添加约束
    [self.view addConstraint:centerX];
    [self.view addConstraint:top];
    
    //也可以添加约束多个约束
    [self.redView addConstraints:@[width, heith]];
    
    
    
    // 布局blueView
    NSLayoutConstraint *centerX1 = [NSLayoutConstraint constraintWithItem:self.blueView attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.redView attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];
    NSLayoutConstraint *top1 = [NSLayoutConstraint constraintWithItem:self.blueView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self.redView attribute:NSLayoutAttributeBottom multiplier:1.0 constant:20];
    
    NSLayoutConstraint *width1 = [NSLayoutConstraint constraintWithItem:self.blueView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:self.redView attribute:NSLayoutAttributeWidth multiplier:1.5 constant:0];
    NSLayoutConstraint *heith1 = [NSLayoutConstraint constraintWithItem:self.blueView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:self.redView attribute:NSLayoutAttributeWidth multiplier:1.5 constant:0];
    
    //iOS8 以后 NSLayoutConstraint 的类方法 也可以把约束添加到视图上，而且省掉了判断添加到那个视图上的问题，避免了上面例子中因为视图添加错误而导致的崩溃
    [NSLayoutConstraint activateConstraints:@[centerX1,top1, width1, heith1]];
</code></pre>
<h5 id="nslayoutconstraint添加约束注意事项"><code>NSLayoutConstraint</code>添加约束注意事项</h5>
<p>1.如果两个视图（也就是参数 item 和 toItem）是父子关系，设置子控件的约束，约束添加到父控件上<br>
2.如果两个视图（也就是参数 item 和 toItem）是兄弟关系，设置两兄弟的约束，约束会添加到第一个共同的父控件上<br>
3.如果两个视图（也就是参数 item 和 toItem）是同一个视图，约束会添加到自己上(一般给自己添加约束toItem为nil attribute为NSLayoutAttributeNotAnAttribute)<br>
4.要给添加约束的view要设置<code>translatesAutoresizingMaskIntoConstraints</code>为NO 否则约束不生效</p>
<pre><code class="language-objectivec">    UIView *redView = [[UIView alloc]init];
    redView.backgroundColor = [UIColor redColor];
    // 要禁止 autoresize 意思就是遵循autoLayout抛弃原有设置的高度宽度等
    // 使用autolayout的视图必须要设置该属性
    redView.translatesAutoresizingMaskIntoConstraints = NO;
</code></pre>
<h3 id="第二种-nslayoutanchor-ios9以后">第二种 <code>NSLayoutAnchor</code> ios9以后</h3>
<pre><code class="language-objectivec">- (NSLayoutConstraint *)constraintEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;
- (NSLayoutConstraint *)constraintGreaterThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;
- (NSLayoutConstraint *)constraintLessThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;

/* These methods return an inactive constraint of the form thisAnchor = otherAnchor + constant.
 */
- (NSLayoutConstraint *)constraintEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c;
- (NSLayoutConstraint *)constraintGreaterThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c;
- (NSLayoutConstraint *)constraintLessThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c;

</code></pre>
<h4 id="接下来我们来讲一下使用方法">接下来我们来讲一下使用方法</h4>
<p>比如要给redView设置一个约束，如下</p>
<pre><code class="language-objectivec">[self.redView.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor];
</code></pre>
<p>上面代码的意思为 <code>红色的view的centerX和self.view的centerX相等</code></p>
<h4 id="下面看使用nslayoutanchor写的约束代码">下面看使用<code>NSLayoutAnchor</code>写的约束代码</h4>
<pre><code class="language-objectivec">    [self.redView.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor].active = YES;
    [self.redView.topAnchor constraintEqualToAnchor:self.view.safeAreaLayoutGuide.topAnchor constant:20].active = YES;
    [self.redView.widthAnchor constraintEqualToConstant:200].active = YES;
    [self.redView.heightAnchor constraintEqualToConstant:200].active = YES;
    
    [self.blueView.centerXAnchor constraintEqualToAnchor:self.redView.centerXAnchor].active = YES;
    [self.blueView.topAnchor constraintEqualToAnchor:self.redView.bottomAnchor constant:20].active = YES;
    [self.blueView.widthAnchor constraintEqualToAnchor:self.redView.widthAnchor multiplier:1.5].active = YES;
    [self.blueView.heightAnchor constraintEqualToAnchor:self.redView.heightAnchor multiplier:1.5].active = YES;
</code></pre>
<h5 id="nslayoutanchor添加约束注意事项"><code>NSLayoutAnchor</code>添加约束注意事项</h5>
<p>1.要给添加约束的view要设置<code>translatesAutoresizingMaskIntoConstraints</code>为NO 否则约束不生效 <code>自定义view的时候也要给子view设置此属性，总之你要给哪个view设置Layout就要给哪个view设置此属性为NO</code><br>
2.<code>active</code>要设置为YES 这个是控制约束是否真正添加的开关 设置为NO的时候 约束失效</p>
<h3 id="第三种-masonry">第三种 <code>Masonry</code></h3>
<h4 id="直接上代码了">直接上代码了</h4>
<pre><code class="language-objectivec">    [self.redView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.top.equalTo(self.view.mas_topMargin).with.offset(20);
        make.centerX.equalTo(self.view.mas_centerX);
        make.width.height.equalTo(@200);
    }];
    
    [self.blueView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.top.equalTo(self.redView.mas_bottom).offset(20);
        make.centerX.equalTo(self.redView.mas_centerX);
        make.width.height.equalTo(self.redView).multipliedBy(1.5);
    }];
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter 常用布局]]></title>
        <id>https://dargonlee.github.io/post/flutter-chang-yong-bu-ju/</id>
        <link href="https://dargonlee.github.io/post/flutter-chang-yong-bu-ju/">
        </link>
        <updated>2019-09-17T06:33:37.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="行布局-在x轴上">行布局 （在X轴上）</h4>
<blockquote>
<p>Row.mainAxisAlignment 主轴排列方式</p>
</blockquote>
<pre><code class="language-objectivec">Row(
  mainAxisAlignment: MainAxisAlignment.spaceAround,  // 改变这个值 可以更改排列方式 如下图
  mainAxisSize: MainAxisSize.max,
  children: [
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
], )
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/646265-2fc1ab8a4b7f57a4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="row.jpg" loading="lazy"></figure>
]]></summary>
        <content type="html"><![CDATA[<h4 id="行布局-在x轴上">行布局 （在X轴上）</h4>
<blockquote>
<p>Row.mainAxisAlignment 主轴排列方式</p>
</blockquote>
<pre><code class="language-objectivec">Row(
  mainAxisAlignment: MainAxisAlignment.spaceAround,  // 改变这个值 可以更改排列方式 如下图
  mainAxisSize: MainAxisSize.max,
  children: [
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
], )
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/646265-2fc1ab8a4b7f57a4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="row.jpg" loading="lazy"></figure>
<!-- more -->
<blockquote>
<p>Row.crossAxisAlignment 纵轴排列方式</p>
</blockquote>
<pre><code class="language-objectivec">Row(
  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
  crossAxisAlignment: CrossAxisAlignment.start,  // 改变这个值 可以更改排列方式 如下图
  children: [
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 100.0),
    Icon(Icons.stars, size: 50.0),
], )
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/646265-90a2530f54792a81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="列布局在y轴上">列布局（在Y轴上）</h4>
<blockquote>
<p>Column.mainAxisAlignment 列布局 主轴排列方式</p>
</blockquote>
<pre><code class="language-objectivec">Column(
  mainAxisAlignment: MainAxisAlignment.start, // 改变这个值 可以更改排列方式 如下图
  mainAxisSize: MainAxisSize.max,
  children: [
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
], )
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://upload-images.jianshu.io/upload_images/646265-ef8cbc570e2abf84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<blockquote>
<p>Column.mainAxisAlignment 列布局 纵轴排列方式</p>
</blockquote>
<pre><code class="language-objectivec">Column(
  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
  crossAxisAlignment: CrossAxisAlignment.start, // 改变这个值 可以更改排列方式 如下图
  children: [
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 100.0),
    Icon(Icons.stars, size: 50.0),
], )
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://upload-images.jianshu.io/upload_images/646265-d03f1a32a2a66c41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="stack布局允许子widget堆叠可以叠加布局view也就是在-z-轴上">Stack布局（允许子widget堆叠，可以叠加布局View，也就是在 Z 轴上）</h4>
<blockquote>
<p>Stack.alignment</p>
</blockquote>
<pre><code class="language-objectivec">Stack(
  alignment: AlignmentDirectional.topStart, //改变这个值 可以更改排列方式 如下面两张图
  children:[
    SizedBox(
      width: 300.0,
      height: 300.0,
      child: Container(color: Colors.green),
), SizedBox(
      width: 200.0,
      height: 200.0,
      child: Container(color: Colors.yellow),
), SizedBox(
      width: 100.0,
      height: 100.0,
      child: Container(color: Colors.red),
), ],
)
```objectivec
![image.png](https://upload-images.jianshu.io/upload_images/646265-6ea3906a2a13098f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/646265-9e0c8ba13561b3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### Positioned布局
&gt; Stack允许子widget堆叠，而Positioned可以给子widget定位 `根据Stack的四个角`
```objectivec
Stack(
  children: [
    SizedBox(
      width: 300.0,
      height: 300.0,
      child: Container(color: Colors.green),
    ),
    Positioned( // 这里的位置都是相对于 上面的SizeBox的位置的
      left: 20.0, 
      top: 20.0,
      width: 100.0,
      height: 100.0,
      child: Container(color: Colors.indigo),
    ),
    Positioned( // 这里的位置都是相对于 上面的SizeBox的位置的
      bottom: 20.0,
      right: 20.0,
      width: 100.0,
      height: 100.0,
      child: Container(color: Colors.black87),
), ],
)
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://upload-images.jianshu.io/upload_images/646265-32432b7a3de5aa7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="expanded布局">Expanded布局</h4>
<blockquote>
<p>Expanded组件可以使Row、Column、Flex等子组件在其主轴方向上展开并填充可用空间(例如，Row在水平方向，Column在垂直方向)。如果多个子组件展开，可用空间会被其flex factor(表示扩展的速度、比例)分割。</p>
</blockquote>
<pre><code class="language-objectivec">Row(
      crossAxisAlignment: CrossAxisAlignment.stretch,
          children: &lt;Widget&gt;[
            Expanded(
              flex: 1, //组件占据剩余空间的比例
              child: Container(
                color: Colors.yellow,
                child: Center(child: Text('flex: 1'),),
              ),
            ),
            Expanded(
              flex: 2,
              child: Container(
                color: Colors.orange,
                child: Center(child: Text('flex: 2'),),
              ),
            ),
            Expanded(
              flex: 3,
              child: Container(
                color: Colors.cyan,
                child: Center(child: Text('flex: 3'),),
              ),
            )
          ],
        ),
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://upload-images.jianshu.io/upload_images/646265-072a28dbc18077cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="expanded-padding-sizedbox">Expanded + Padding + SizedBox</h4>
<blockquote>
<p>如何用 <code>padding</code> 和 <code>SizeBox</code> 给内容之间添加间隙</p>
</blockquote>
<pre><code class="language-objectivec">Container(
        height: 200.0,
        color: Colors.yellow,
        padding: EdgeInsets.all(16.0),
        child: Row(
          children: &lt;Widget&gt;[
            Expanded(
              flex: 1,
              child: Container(
                color: Colors.green,
                child: Center(child: Text('flex: 1'),),
              ),
            ),
            SizedBox(width: 40.0,),
            Expanded(
              flex: 2,
              child: Container(
                color: Colors.orange,
                child: Center(child: Text('flex: 2'),),
              ),
            )
          ],
        ),
      ),
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://upload-images.jianshu.io/upload_images/646265-105875d9a122bce3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git的常用命令]]></title>
        <id>https://dargonlee.github.io/post/git-de-chang-yong-ming-ling/</id>
        <link href="https://dargonlee.github.io/post/git-de-chang-yong-ming-ling/">
        </link>
        <updated>2019-08-12T05:38:57.000Z</updated>
        <summary type="html"><![CDATA[<pre><code class="language-bash"># 显示当前的Git配置
$ git config --list

# 查看仓库配置
git config --local -l 

# 查看用户配置
git config --global -l 

# 查看系统配置
git config --system -l </code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code class="language-bash"># 显示当前的Git配置
$ git config --list

# 查看仓库配置
git config --local -l 

# 查看用户配置
git config --global -l 

# 查看系统配置
git config --system -l 

&lt;!-- more --&gt;

# 编辑Git配置文件

git config --local -e 编辑仓库级别配置文件
git config --global -e 编辑用户级别配置文件
git config --system -e 编辑系统级别配置文件

# 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;
</code></pre>
<p>推送操作 切记直接使用 <code>git push</code></p>
<pre><code class="language-bash">git push origin HEAD:refs/for/develop  
</code></pre>
<p>创建并切换到dev分支（本地分支）</p>
<pre><code class="language-bash">git checkout -b dev
</code></pre>
<p>删除本地dev分支(本地)</p>
<pre><code class="language-bash">git branch -d dev
</code></pre>
<p>分支合并</p>
<pre><code class="language-scheme">git checkout master
git merge dev
</code></pre>
<p>推送本地分支到远程</p>
<pre><code class="language-bash">git push -u origin develop
</code></pre>
<p>查看分支：</p>
<pre><code class="language-bash">git branch
</code></pre>
<p>创建分支：</p>
<pre><code class="language-bash">git branch 
</code></pre>
<p>切换分支：</p>
<pre><code class="language-bash">git checkout `或者`git switch `
</code></pre>
<p>删除远程分支：</p>
<pre><code class="language-bash"> git push origin --delete 
</code></pre>
<p>打tag</p>
<pre><code class="language-bash">git tag 
</code></pre>
<p>删除本地tag</p>
<pre><code class="language-bash">git tag -d 
</code></pre>
<p>删除远程tag</p>
<pre><code class="language-bash">git push origin --delete tag 
</code></pre>
<p>推送到哪个分支</p>
<pre><code class="language-bash">git push origin HEAD:refs/for/branch
</code></pre>
<p>回退相关操作</p>
<pre><code class="language-bash">git reset --hard HEAD^ // 回退pull操作

git reset --mixed HEAD^ // 回退commit 只退一步

git reset --hard 139dcfaa558e3276b30b6b2e5cbbb9c00bbdca96 // 回退到某一个版本
git reset --soft HEAD^//该命令会将工作去的文件回退到目标版本，但是不会改变暂存区的状态。

--hard 会清空工作目录和暂存区的改动,而 --soft则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区
</code></pre>
<p>执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</p>
<pre><code class="language-bash">git stash save &quot;save message&quot; :
</code></pre>
<p>查看stash了哪些存储</p>
<pre><code class="language-bash">git stash list
</code></pre>
<p>显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}</p>
<pre><code class="language-scheme">git stash show
</code></pre>
<p>显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p</p>
<pre><code class="language-bash">git stash show -p
</code></pre>
<p>应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1}</p>
<pre><code class="language-bash">git stash apply
</code></pre>
<p>命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}</p>
<pre><code class="language-bash">git stash pop
</code></pre>
<p>从列表中删除这个存储</p>
<pre><code class="language-bash">git stash drop stash@{$num} ：丢弃stash@{$num}存储
</code></pre>
<p>删除所有缓存的stash</p>
<pre><code class="language-bash">git stash clear
</code></pre>
<p>代码提交</p>
<pre><code class="language-bash"># 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
</code></pre>
<p>分支</p>
<pre><code class="language-bash"># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre>
<p>查看信息</p>
<pre><code class="language-bash"># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
</code></pre>
<p>远程同步</p>
<pre><code class="language-bash"># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
</code></pre>
<p>撤销</p>
<pre><code class="language-bash"># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
</code></pre>
<p>撤销本地提交</p>
<blockquote>
<p>HEAD^的意思是上一个版本，也可以写成HEAD~1<br>
如果你进行了2次commit，想都撤回，可以使用HEAD~2</p>
</blockquote>
<p>至于这几个参数：</p>
<pre><code class="language-bash">--mixed 
意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作
这个为默认参数,git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的
</code></pre>
<pre><code class="language-bash">--soft  
不删除工作空间改动代码，撤销commit，不撤销git add . 
</code></pre>
<pre><code class="language-bash">--hard
删除工作空间改动代码，撤销commit，撤销git add . 
注意完成这个操作后，就恢复到了上一次的commit状态。
</code></pre>
<pre><code class="language-bash">顺便说一下，如果commit注释写错了，只是想改一下注释，只需要：
git commit --amend
此时会进入默认vim编辑器，修改注释完毕后保存就好了
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS布局]]></title>
        <id>https://dargonlee.github.io/post/css-bu-ju/</id>
        <link href="https://dargonlee.github.io/post/css-bu-ju/">
        </link>
        <updated>2019-07-09T05:36:06.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="position">position</h1>
<blockquote>
<p>为了制作更多复杂的布局，我们需要讨论下<code>position</code>属性。它有一大堆的值，名字还都特抽象，别提有多难记了。让我们先一个个的过一遍，不过你最好还是把这页放到书签里。</p>
</blockquote>
<ul>
<li><code>static</code>元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分；行内元素则会创建一个或多个行框，置于其父元素中。</li>
</ul>
<pre><code class="language-css">.static {
    position: static;
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="position">position</h1>
<blockquote>
<p>为了制作更多复杂的布局，我们需要讨论下<code>position</code>属性。它有一大堆的值，名字还都特抽象，别提有多难记了。让我们先一个个的过一遍，不过你最好还是把这页放到书签里。</p>
</blockquote>
<ul>
<li><code>static</code>元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分；行内元素则会创建一个或多个行框，置于其父元素中。</li>
</ul>
<pre><code class="language-css">.static {
    position: static;
}
</code></pre>
<!--more-->
<p><code>static</code>是默认值。任意<code>position: static;</code>的元素不会被特殊的定位。一个 static 元素表示它<em>不会被“positioned”</em>，一个 position 属性被设置为其他值的元素表示它<em>会被“positioned”</em>。</p>
<ul>
<li><code>relative</code>元素框相对于之前正常文档流中的位置发生偏移，并且原先的位置仍然被占据。发生偏移的时候，可能会覆盖其他元素。</li>
</ul>
<pre><code class="language-css">.relative1 {
  position: relative;
}

.relative2 {
  position: relative;
  top: -20px;
  left: 20px;
  background-color: white;
  width: 500px;
}
</code></pre>
<blockquote>
<p>relative1 的表现和static一样，除非你添加了一些额外的属性</p>
<p>在一个相对定位（position属性的值为relative）的元素上设置<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙</p>
</blockquote>
<p><code>absolute</code>元素框不再占有文档流位置，并且相对于包含块进行偏移(所谓的包含块就是最近一级外层元素position不为static的元素)</p>
<p><code>absolute</code>与<code>fixed</code>的表现类似，但是它不是相对于视窗而是相对于<em>最近的“positioned”祖先元素</em>。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。记住一个“positioned”元素是指 position 值不是<code>static</code>的元素。</p>
<pre><code class="language-css">.relative { // 父元素
  position: relative; 
  width: 600px;
  height: 400px;
}
.absolute { // 子元素
  position: absolute;
  top: 120px;
  right: 0;
  width: 300px;
  height: 200px;
}
</code></pre>
<blockquote>
<p>子元素是相对定位的。如果它的父元素是<code>position: static;</code>，子元素会跳过父元素直接相对于body元素定位。</p>
<p>换句话说就是 子元素要想使用  `absolute 进行绝对定位 那么它相对的那个元素postition必须relative，如果父元素没有relative的话 子元素会相对本身最近的一个有relative属性的元素进行定位</p>
</blockquote>
<p><code>fixed</code>元素框不再占有文档流位置，并且相对于视窗进行定位</p>
<pre><code class="language-css">&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;
.footer {
  position: fixed;
  bottom: 0;
  left: 0;
  height: 70px;
  background-color: white;
  width: 100%;
}
</code></pre>
<p><code>sticky</code>(这是css3新增的属性值)粘性定位，官方的介绍比较简单，或许你不能理解。其实，它就相当于relative和fixed混合。最初会被当作是relative，相对于原来的位置进行偏移；一旦超过一定阈值之后，会被当成fixed定位，相对于视口进行定位</p>
<blockquote>
<p>相对于body定位并且是悬浮的</p>
</blockquote>
<ul>
<li><code>floate</code></li>
</ul>
<blockquote>
<p>另一个布局中常用的CSS属性是<code>float</code>。Float 可用于实现文字环绕图片</p>
</blockquote>
<pre><code class="language-css">img {
  float: right;
  margin: 0 0 1em 1em;
}
</code></pre>
<ul>
<li><code>clear</code></li>
</ul>
<blockquote>
<p><code>clear</code>属性被用于控制浮动。比较下面两个例子：</p>
</blockquote>
<pre><code class="language-html">&lt;div class=&quot;box&quot;&gt;...&lt;/div&gt;
&lt;section&gt;...&lt;/section&gt;
</code></pre>
<pre><code class="language-css">.box {
  float: left;
  width: 200px;
  height: 100px;
  margin: 1em;
}
在这个例子中， section 元素实际上是在 div 之后的（译注：DOM结构上）。然而 div 元素是浮动到左边的，于是 section 中的文字就围绕了 div ，并且 section 元素包围了整个元素。如果我们想让 section 显示在浮动元素之后呢？
</code></pre>
<pre><code class="language-css">.box {
  float: left;
  width: 200px;
  height: 100px;
  margin: 1em;
}
.after-box {
  clear: left;
}
使用 clear 我们就可以将这个段落移动到浮动元素 div 下面。你需要用 left 值才能清除元素的向左浮动。你还可以用 right 或 both 来清除向右浮动或同时清除向左向右浮动。
</code></pre>
<p>清除浮动</p>
<pre><code class="language-css">img {
  float: right;
}

.clearfix { //清除浮动
  overflow: auto;
}
</code></pre>
]]></content>
    </entry>
</feed>