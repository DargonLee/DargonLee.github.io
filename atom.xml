<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dargonlee.github.io</id>
    <title>七里田间的守望者</title>
    <updated>2020-02-19T01:54:16.933Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dargonlee.github.io"/>
    <link rel="self" href="https://dargonlee.github.io/atom.xml"/>
    <subtitle>我不在乎是悲伤的离别还是不痛快的离别，只要是离开一个地方，我总希望离开的时候自己心中有数。</subtitle>
    <logo>https://dargonlee.github.io/images/avatar.png</logo>
    <icon>https://dargonlee.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 七里田间的守望者</rights>
    <entry>
        <title type="html"><![CDATA[Dart语法入门]]></title>
        <id>https://dargonlee.github.io/post/dart-yu-fa-ru-men/</id>
        <link href="https://dargonlee.github.io/post/dart-yu-fa-ru-men/">
        </link>
        <updated>2020-02-18T11:51:21.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>跟Java等很多语言不同的是，Dart没有public protected private等关键字，如果某个变量以下划线 _ 开头，代表这个变量在库中是私有的。Dart中变量可以以字母或下划线开头，后面跟着任意组合的字符或数字</p>
</blockquote>
<p>比如下面代码</p>
<pre><code class="language-dart">main() {   String _name = '';//private变量   String name = ''//public变量}
</code></pre>
<h3 id="变量">变量</h3>
<h4 id="变量的定义">变量的定义</h4>
<pre><code class="language-dart">main() {    var a = 1;    int b = 10;     String s = &quot;hello&quot;;    dynamic c = 0.5;}
</code></pre>
<blockquote>
<p>你可以自己定义你数据类型比如<code>String</code>  <code>int</code> 当然也可以用<code>var</code>  <code>dynamic</code>定义变量，dart会自动推断其数据类型。</p>
</blockquote>
<h4 id="final和const">final和const</h4>
<p>如果你定义一个变量后就不想改变其值的话，使用<code>final</code>和<code>const</code>去定义。不要使用<code>var</code>或者其他类型去定义。</p>
<p>用<code>final</code>定义的变量只能赋值一次，用<code>const</code>定义的变量是一个编译时的常量。</p>
<p>（可以理解为：final修饰的变量是不可改变的，而const修饰的表示一个常量。）</p>
<blockquote>
<p><em>注意：实例变量可以是final的但不能是const的</em></p>
</blockquote>
<pre><code class="language-dart">var count = 10;final Num = count;// final 只能赋值一次const Num1 = 10;// const赋值必须是编译时常量
</code></pre>
<h4 id="final和const的区别">final和const的区别</h4>
<ul>
<li>
<p><code>final</code>定义的变量只能初始化一次，二次赋值就会报错，赋的值可以是常量也可以不是常量。</p>
</li>
<li>
<p><code>final</code>是懒加载初始化，即程序运行也不一定初始化，只有真正用到的时候才会初始化。</p>
</li>
</ul>
<h3 id="dart的内建数据类型">Dart的内建数据类型</h3>
<p>有如下几种内建的数据类型</p>
<ul>
<li>
<p><code>numbers</code></p>
</li>
<li>
<p><code>strings</code></p>
</li>
<li>
<p><code>booleans</code></p>
</li>
<li>
<p><code>lists</code></p>
</li>
<li>
<p><code>maps</code></p>
</li>
<li>
<p><code>runes</code>UTF-32字符集的字符 符号文字</p>
</li>
<li>
<p><code>symbols</code></p>
</li>
</ul>
<p>下面用一段代码来演示以上各类数据类型：</p>
<pre><code class="language-dart">// numbersvar a = 0;int b = 1;double c = 0.1;// stringsvar s1 = 'hello';String s2 = 'world';// booleansvar real = true;bool isReal = false;// listsvar array = [1, 2, 3, 4, 5];List array1 = ['hello','world','!!!'];List array = [1, true, 'haha', 1.0];# 这里的 `dynamic` 是泛型// mapsvar map = new Map();map['name'] = 'zhangsan';map['age'] = 10;Map m = new Map();m['a'] = 'a';// charsvar clapping = '\u{1f44f}';print(clapping); // 打印的是拍手emoji的表情// Symbol对象表示在Dart程序中声明的运算符或标识符(不常用)print(#s == new Symbol(&quot;s&quot;)); // true

</code></pre>
<h3 id="函数">函数</h3>
<h4 id="函数的一般声明形式">函数的一般声明形式</h4>
<pre><code class="language-dart">int add(int a, int b) {  return a + b;}
</code></pre>
<p><code>int</code>为返回值类型，<code>add</code>为函数名称， <code>()</code>里面的为参数</p>
<h4 id="函数的返回值">函数的返回值</h4>
<p>Dart是一个面向对象的编程语言，所以即使函数也是一个对象，也有一种类型<code>Function</code>，这就意味着可以赋值给某个变量或者当作参数传给另一个函数。</p>
<p>虽然Dart推荐给函数加上返回值，但是不加也能正常工作。另外你可以用<code>=&gt;</code>代替return语法，例如下面的例子</p>
<pre><code class="language-dart">// 带返回值int add(int a, int b) {    return a + b;    }// 不带返回值add2(int a, int b) {    return a + b;    }// 不带返回值的官方写法（一般都用上面的写法）void add3(int a, int b) {    return a + b;    }// 简写形式add3(int a, int b) =&gt; a + b;main() {  print(add(1, 2)); // 3  print(add2(2, 3)); // 5  print(add3(1, 2)); // 3}
</code></pre>
<p>所有的函数都有返回值，如果没有指定return语句，那么该函数的返回值为null。</p>
<h4 id="命名参数">命名参数</h4>
<pre><code class="language-dart">// 写法一sayHello({String name}) {    print(&quot;my name is $name&quot;);    }// 写法二sayHello1({name: String}) { // 不建议使用    print(&quot;my name is $name&quot;);}// 写法三sayHello2(String name) {    print(&quot;my name is $name&quot;);  }// 写发四sayHello3({String name, @required String ids}) {    print(&quot;my name is $name and $ids&quot;);}main() {  // 打印 my name is zhangsan  sayHello(name: 'zhangsan');  // 打印 my name is wangwu  sayHello1(name: 'wangwu');}
</code></pre>
<p>从上可以看出函数参数的形式有三种，<code>写法三</code>和<code>写法一二</code>不同，因为它没有带大括号，这里说明下，<code>写法三</code>的形式为必需参数，而<code>写发一二</code>参数是可选的，即你不传参数也是可以调用成功的。如果你想在<code>写法一二</code>声明必选参数，需要在声明的参数前面加上<code>@required</code>关键字。例<code>写法四</code></p>
<h4 id="位置参数">位置参数</h4>
<p>使用中括号<code>[]</code>括起来的参数是函数的位置参数，代表该参数可传可不传，位置参数只能放在函数的参数列表的最后面，如下代码所示：</p>
<pre><code class="language-dart">sayHello(String name, int age, [String body]) { // 位置参数可以有多个，比如[String a, int b]  StringBuffer sb = new StringBuffer();  sb.write(&quot;hello, this is $name and I am $age years old&quot;);  if (hobby != null) {    sb.write(&quot;, my hobby is $hobby&quot;);  }  print(sb.toString());    }main() {  // hello, this is zhangsan and I am 20 years old  sayHello(&quot;zhangsan&quot;, 20);  // hello, this is zhangsan and I am 20 years old, my hobby is play football  sayHello(&quot;zhangsan&quot;, 20, &quot;play football&quot;);}
</code></pre>
<h4 id="参数默认值">参数默认值</h4>
<p>你可以为命名参数或者位置参数设置默认值，如下代码所示</p>
<pre><code class="language-dart">// 命名参数的默认值int add({int a, int b = 3}) { // 不能写成：int add({a: int, b: int = 3})  return a + b;}// 位置参数的默认值int sum(int a, int b, [int c = 3]) {  return a + b + c;}
</code></pre>
<h4 id="main函数">main()函数</h4>
<p>不论在Dart还是Flutter中，必须都需要一个顶层的main()函数，它是整个应用的入口函数，main()函数的返回值是void，还有一个可选的参数，参数类型是List<String>。</p>
<h4 id="函数作为一类对象">函数作为一类对象</h4>
<p>你可以将一个函数作为参数传给另一个函数，比如下面的代码：</p>
<pre><code class="language-dart">printNum(int a) {    print(&quot;$a&quot;);    }main() {  //  依次打印：  //  1  //  2  //  3  var arr = [1, 2, 3];  arr.forEach(printNum);}
</code></pre>
<p>你也可以将一个函数赋值给某个变量，比如下面的代码：</p>
<pre><code class="language-dart">printNum(int a) {  print(&quot;$a&quot;);}main() {    var f1 = printNum;    Function f2 = printNum;    var f3 = (int a) =&gt; print(&quot;a = $a&quot;);    f1(1);    f2(2);    f3(6);}
</code></pre>
<h4 id="匿名函数">匿名函数</h4>
<p>大多数函数都是有名称的，比如main() printName()等，但是你也可以写匿名函数，如果你对Java比较熟悉，那下面的Dart代码你肯定也不会陌生：</p>
<pre><code class="language-dart">test(Function callback) {    callback(&quot;hello&quot;);    }main() {  test((param) {    // 打印hello    print(param);  });}
</code></pre>
<p>匿名函数类似于Java中的接口，往往在某个函数的参数为函数时使用到。</p>
<h4 id="运算符">运算符</h4>
<pre><code class="language-dart">main() {  // 与Java相同的运算符操作  int a = 1;  ++a;  a++;  var b = 1;  print(a == b);  // false  print(a * b); // 3  bool real = false;  real ? print('real') : print('not real'); // not real  print(real &amp;&amp; a == b); // false  print(real || a == 3); // true  print(a != 2); // true  print(a &lt;= b); // false  var c = 9;  c += 10;  print(&quot;c = $c&quot;); // c = 19  print(1&lt;&lt;2); // 4  // 与Java不太一样的运算符操作  // is运算符用于判断一个变量是不是某个类型的数据  // is!则是判断变量不是某个类型的数据  var s = &quot;hello&quot;;  print(s is String); // true  var num = 6;  print(num is! String); // true  // ~/才是取整运算符，如果使用/则是除法运算，不取整  int k = 1;  int j = 2;  print(k / j); // 0.5  print(k ~/ j); // 0  // as运算符类似于Java中的cast操作，将一个对象强制类型转换  (emp as Person).teach();  // ??=运算符 如果 ??= 运算符前面的变量为null，则赋值，否则不赋值  var param1 = &quot;hello&quot;, param2 = null;  param1 ??= &quot;world&quot;;  param2 ??= &quot;world&quot;;  print(&quot;param1 = $param1&quot;); // param1 = hello  print(&quot;param2 = $param2&quot;); // param2 = world    // ?.运算符  var str1 = &quot;hello world&quot;;  var str2 = null;  print(str1?.length); // 11  print(str2?.length); // null   print(str2.length); // 报错}
</code></pre>
<h4 id="运算符级联操作">…运算符（级联操作）</h4>
<pre><code class="language-dart">class Person {  eat() {    print(&quot;I am eating...&quot;);  }  sleep() {    print(&quot;I am sleeping...&quot;);  }  study() {    print(&quot;I am studying...&quot;);  }}main() {  // 依次打印  //  I am eating...  //  I am sleeping...  //  I am studying...  new Person()..eat()      ..sleep()      ..study();}
</code></pre>
<p>可以看到，使用…调用某个对象的方法（或者成员变量）时，返回值是这个对象本身，所以你可以接着使用…调用这个对象的其他方法.</p>
<h4 id="控制流程">控制流程</h4>
<pre><code class="language-dart">main() {  // if else语句  int score = 80;  if (score &lt; 60) {    print(&quot;so bad!&quot;);  } else if (score &gt;= 60 &amp;&amp; score &lt; 80) {    print(&quot;just so so!&quot;);  } else if (score &gt;= 80) {    print(&quot;good job!&quot;);  }  // switch语句  String a = &quot;hello&quot;;  // case语句中的数据类型必须是跟switch中的类型一致  switch (a) {    case &quot;hello&quot;:      print(&quot;haha&quot;);      break;    case &quot;world&quot;:      print(&quot;heihei&quot;);      break;    default:      print(&quot;WTF&quot;);  }  // for语句  List list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];  for (int i = 0; i &lt; list.length; i++) {    print(list[i]);  }  for (var i in list) {    print(i);  }  // 这里的箭头函数参数必须用圆括号扩起来  list.forEach((item) =&gt; print(item));  // while语句  int start = 1;  int sum = 0;  while (start &lt;= 100) {    sum += start;    start++;  }  print(sum);  // try catch语句  try {    print(1 ~/ 0);  } catch (e) {    // IntegerDivisionByZeroException    print(e);  }  try {    1 ~/ 0;  } on IntegerDivisionByZeroException { // 捕获指定类型的异常    print(&quot;error&quot;); // 打印出error  } finally {    print(&quot;over&quot;); // 打印出over  }}
</code></pre>
<h3 id="类class">类（Class）</h3>
<h4 id="类的定义与构造方法">类的定义与构造方法</h4>
<p>Dart中的类没有访问控制，所以你不需要用private, protected, public等修饰成员变量或成员函数，一个简单的类如下代码所示：</p>
<pre><code class="language-dart">class Person {    String name;    int age;    String gender;    // 构造函数    Person(this.name, this.age, this.gender);    // public方法    sayHello() {      print(&quot;hello, this is $name, I am $age years old, I am a $gender&quot;);     }    // private方法     _sayHello() {       print(&quot;&quot;);     }}
</code></pre>
<p>上面的构造函数等同于下面的写法</p>
<pre><code class="language-dart">Person(String name, int age, String gender) {    this.name = name;    this.age = age;    this.gender = gender;}
</code></pre>
<p>要调用Person类的成员变量或成员方法，可以用下面的代码：</p>
<pre><code class="language-dart">var p = new Person(&quot;zhangsan&quot;, 20, &quot;male&quot;);p.sayHello(); // hello, this is zhangsan, I am 20 years old, I am a malep.age = 50;p.gender = &quot;female&quot;;p.sayHello();
</code></pre>
<p>类除了有跟类名相同的构造方法外，还可以添加命名的构造方法，如下代码所示</p>
<pre><code class="language-dart">class Point {    num x, y;    Point(this.x, this.y);    //类的命名构造方法    Point.origin() {        x = 0;        y = 0;    }}main() {    // 调用Point类的命名构造方法origin()    var }
</code></pre>
<p>Dart中使用extends关键字做类的继承，如果一个类只有命名的构造方法，在继承时需要注意，如下代码：</p>
<pre><code class="language-dart">class Human {    String name;    Human.fromJson(Map data) {        print(&quot;Human's fromJson constructor&quot;);    }}class Man extend Human {    Man.fromJson(Map data) : super.fromJson(data) {        print(&quot;Man's fromJson constructor&quot;);    }}
</code></pre>
<p>由于Human类没有默认构造方法，只有一个命名构造方法fromJson，所以在Man类继承Human类时，需要调用父类的fromJson方法做初始化，而且必须使用Man.fromJson(Map data) : super.fromJson(data)这种写法，而不是像Java那样将super写到花括号中。</p>
<p>有时候你仅仅只是在某个类的构造方法中，调用这个类的另一个构造方法，你可以这么写：</p>
<pre><code class="language-dart">class Point {  num x, y;  Point(this.x, this.y);  // 命名构造方法调用了默认的构造方法  Point.alongXAxis(num x) : this(x, 0);}
</code></pre>
<h4 id="类的成员方法">类的成员方法</h4>
<p>一个类的成员方法是一个函数，为这个类提供某些行为。上面的代码中已经有了一些类的成员方法的定义，这些定义方式跟Java很类似，你可以为某个类的成员变量提供getter/setter方法，如下代码：</p>
<pre><code class="language-dart">class Rectangle {  num left, top, width, height;    // 构造方法传入left, top, width, height几个参数  Rectangle(this.left, this.top, this.width, this.height);  // right, bottom两个成员变量提供getter/setter方法  num get right =&gt; left + width;  set right(num value) =&gt; left = value - width;    num get bottom =&gt; top + height;  set bottom(num value) =&gt; top = value - height;}
</code></pre>
<h4 id="抽象类和抽象方法">抽象类和抽象方法</h4>
<p>使用abstract修饰一个类，则这个类是抽象类，抽象类中可以有抽象方法和非抽象方法，抽象方法没有方法体，需要子类去实现，如下代码：</p>
<pre><code class="language-dart">abstract class Doer {  // 抽象方法，没有方法体，需要子类去实现  void doSomething();  // 普通的方法  void greet() {    print(&quot;hello world!&quot;);  }}class EffectiveDoer extends Doer {  // 实现了父类的抽象方法  void doSomething() {    print(&quot;I'm doing something...&quot;);  }}
</code></pre>
<h4 id="枚举类">枚举类</h4>
<p>使用enum关键字定义一个枚举类，这个语法跟Java类似，如下代码：</p>
<pre><code class="language-dart">enum Color { red, green, blue }
</code></pre>
<p>要获取枚举中所有值的列表，请使用enum的values 常量。</p>
<pre><code class="language-dart">List colors = Color.values;assert(colors[2] == Color.blue);
</code></pre>
<p>您可以在switch语句中使用enum，如果switch的case不处理enum的所有值，将会报一个警告消息:</p>
<pre><code class="language-dart">var aColor = Color.blue;switch (aColor) {  case Color.red:    print('Red as roses!');    break;  case Color.green:    print('Green as grass!');    break;  default: // Without this, you see a WARNING.    print(aColor); // 'Color.blue'}
</code></pre>
<h4 id="mixins">mixins</h4>
<p>mixins是一个重复使用类中代码的方式，比如下面的代码：</p>
<pre><code class="language-dart">class A {  a() {    print(&quot;A's a()&quot;);  }}class B {  b() {    print(&quot;B's b()&quot;);  }}// 使用with关键字，表示类C是由类A和类B混合而构成class C = A with B;main() {  C c = new C();  c.a(); // A's a()  c.b(); // B's b()}
</code></pre>
<h4 id="静态成员变量和静态成员方法">静态成员变量和静态成员方法</h4>
<pre><code class="language-dart">// 类的静态成员变量和静态成员方法class Cons {  static const name = &quot;zhangsan&quot;;  static sayHello() {    print(&quot;hello, this is ${Cons.name}&quot;);  }}main() {  Cons.sayHello(); // hello, this is zhangsan  print(Cons.name); // zhangsan}
</code></pre>
<h4 id="dart库libraries">Dart库（Libraries）</h4>
<p>Dart目前已经有很多的库提供给开发者，许多功能不需要开发者自己去实现，只需要导入对应的包即可，使用import语句来导入某个包，比如下面的代码</p>
<pre><code class="language-dart">import 'dart:html';
</code></pre>
<p>如果你想导入自己写的某个代码文件，使用相对路径即可，例如当前有一个demo.dart文件，跟该文件同级目录下有个util.dart文件，文件代码如下：</p>
<pre><code class="language-dart">// util.dart文件内容int add(int a, int b) {  return a + b;}
</code></pre>
<p>在demo.dart文件中如果要引用util.dart文件，使用下面的方式导入：</p>
<pre><code class="language-dart">// demo.dartimport './util.dart';main() {  print(add(1, 2));}
</code></pre>
<p>你可以使用as关键字为导入的某个包设置一个前缀，或者说别名，比如下面的代码：</p>
<pre><code class="language-dart">import 'package:lib1/lib1.dart';import 'package:lib2/lib2.dart' as lib2;// Uses Element from lib1.Element element1 = Element();// Uses Element from lib2.lib2.Element element2 = lib2.Element();
</code></pre>
<p>你也可以在导入包时使用show hide关键字来导入某个包中的部分功能，比如下面的代码：</p>
<pre><code class="language-dart">// 只导入fooimport 'package:lib1/lib1.dart' show foo;// 导入除了foo的所有其他部分import 'package:lib2/lib2.dart' hide foo;
</code></pre>
<p>导入包时使用deferred as可以让这个包懒加载，懒加载的包只会在该包被使用时得到加载，而不是一开始就加载，比如下面的代码：</p>
<pre><code class="language-dart">import 'package:greetings/hello.dart' deferred as hello;
</code></pre>
<h4 id="异步">异步</h4>
<p>Dart提供了类似ES7中的async await等异步操作，这种异步操作在Flutter开发中会经常遇到，比如网络或其他IO操作，文件选择等都需要用到异步的知识。<br>
async和await往往是成对出现的，如果一个方法中有耗时的操作，你需要将这个方法设置成async，并给其中的耗时操作加上await关键字，如果这个方法有返回值，你需要将返回值塞到Future中并返回，如下代码所示：</p>
<pre><code class="language-dart">Future checkVersion() async {  var version = await lookUpVersion();  // Do something with version}
</code></pre>
<p>下面的代码使用Dart从网络获取数据并打印出来：</p>
<pre><code class="language-dart">import 'dart:async';import 'package:http/http.dart' as http;Future getNetData() async{  http.Response res = await http.get(&quot;http://www.baidu.com&quot;);  return res.body;}main() {  getNetData().then((str) {    print(str);  });}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS开发将一个工程添加到另一个工程中]]></title>
        <id>https://dargonlee.github.io/post/ios-kai-fa-jiang-yi-ge-gong-cheng-tian-jia-dao-ling-yi-ge-gong-cheng-zhong/</id>
        <link href="https://dargonlee.github.io/post/ios-kai-fa-jiang-yi-ge-gong-cheng-tian-jia-dao-ling-yi-ge-gong-cheng-zhong/">
        </link>
        <updated>2019-11-16T06:38:45.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>一个项目引用另一个项目这里列举两种情况</p>
<ul>
<li>一个 Single View App 项目要引用另一个Single View App 项目</li>
<li>一个 Single View App 项目要引用 动态库的项目（Cocoa Touch Framework）</li>
</ul>
</blockquote>
<h4 id="先说第一种情况的做法">先说第一种情况的做法</h4>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>一个项目引用另一个项目这里列举两种情况</p>
<ul>
<li>一个 Single View App 项目要引用另一个Single View App 项目</li>
<li>一个 Single View App 项目要引用 动态库的项目（Cocoa Touch Framework）</li>
</ul>
</blockquote>
<h4 id="先说第一种情况的做法">先说第一种情况的做法</h4>
<!-- more -->
<ul>
<li>先在一个文件夹下 新建两个 Single View App 项目 一个为demo1 另一个为demo2</li>
</ul>
<blockquote>
<p>注意 现在的需求是 <code>demo1 要引用 demo2</code></p>
</blockquote>
<ul>
<li>
<p>然后在demo1项目中新建一个Group 命名为 <code>Frameworks</code> 创建完成如下图<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-a9bd6106264a07eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100047@2x.png" loading="lazy"></p>
</li>
<li>
<p>然后 <code>show in finder</code> <code>Frameworks</code> 把<code>demo2</code> 拖进去 完成后如下图<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-03744768dbf8acda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100400@2x.png" loading="lazy"></p>
</li>
<li>
<p>最后 进入到 <code>Frameworks</code>里面的 <code>demo2</code>找到 <code>demo2.xcodeproj</code> 然后把  <code>demo2.xcodeproj</code>  拖动到 <code>demo1</code>的<code>Frameworks</code>文件夹里面 操作完成如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-20a3f6a7cdbf069b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100707@2x.png" loading="lazy"></p>
</li>
<li>
<p>下面开始操作<code>demo2</code>了</p>
</li>
<li>
<p>选中 <code>Frameworks</code>里面的 <code>demo2.xcodeproj</code> 添加一个 Target 操作如图所示</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/646265-64fdf9f64b75e438.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100943@2x.png" loading="lazy"></figure>
<p><em><strong>创建动态库</strong></em></p>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/646265-e06cc019ed28e160.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100959@2x.png" loading="lazy"></figure>
<blockquote>
<p>我这里命名的target 为<code>xxx</code> 你可以按需求命名 因为到时候在 <code>demo1</code>中导入头文件的时候 就是这个名字</p>
</blockquote>
<ul>
<li>在 <code>demo2</code>中创建一个 <code>Person</code>类 （这个类就是一会我们要在<code>demo1</code>中使用的） 操作完成如下图<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-11a7c5c634e49ff6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-101342@2x.png" loading="lazy"></li>
</ul>
<blockquote>
<p>注意要想在 <code>demo1</code>使用的文件添加到 <code>xxx</code> 的target当中去 如下图所示 如果又想给<code>demo1</code>用又想自己用 那就两个target都勾选</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://upload-images.jianshu.io/upload_images/646265-14c3ab67d01a6f1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<ul>
<li>然后选中 刚才创建的那个 <code>xxx</code>target 进行如下图操作所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-e4097bda92932e75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-101451@2x.png" loading="lazy"></li>
</ul>
<blockquote>
<p>上图操作为 把<code>Project</code> 中的 <code>Person.h</code> 拖动到 <code>Public</code>中</p>
</blockquote>
<ul>
<li>
<p>然后选中 <code>demo1</code>进行如下图操作<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-6199f3ebc95efdd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-102412@2x.png" loading="lazy"></p>
</li>
<li>
<p>然后继续设置 <code>demo1</code>  在 <code>Build Settings</code>中设置<code>Header Search Paths</code> 的路径为 <code>${SRCROOT}/Frameworks/demo2</code> 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-1003fdf2f8b79706.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-102551@2x.png" loading="lazy"></p>
</li>
<li>
<p>至此 一个项目引入另一个项目的功能就完成了 在 <code>demo1</code>中 就可以快乐的使用 <code>demo2</code>的文件了 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-ae52f9c5f13fe3e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-102917@2x.png" loading="lazy"></p>
</li>
</ul>
<h1 id="下面是-single-view-app-项目要引用-动态库的项目cocoa-touch-framework">下面是 Single View App 项目要引用 动态库的项目（Cocoa Touch Framework）</h1>
<blockquote>
<p>思路跟上面差不多</p>
</blockquote>
<p>这里以 <code>Demo1</code> 为例子 以下图所示 操作<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-e31ad3c0f0dec7a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<p>然后按照下图选择创建动态库<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-e06cc019ed28e160.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190510-100959@2x.png" loading="lazy"><br>
然后创建好的动态库如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-d103b7200d550368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<p>我在动态库里面 新建了 一个<code>Person</code>文件，并声明了一个属性和一个方法<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-e7048f8d3422fd79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<p>切记箭头指向的地方 如果在 <code>UUPerson</code> 中打钩就是只在<code>UUPerson</code>动态库中用。<br>
然后在 动态库的头文件中，配置要暴露出去的头文件 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-2e912de99b775b57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<p>接着就要配置外界能访问的头文件了 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-167dac6407dbb774.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
<blockquote>
<p>把要对外的 <code>.h</code>文件都拖动到 Public的里面去</p>
</blockquote>
<p>然后就可以在当前项目中使用了 如下图所示<br>
<img src="https://upload-images.jianshu.io/upload_images/646265-5035cf57f5cfad11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决定时器的循环引用]]></title>
        <id>https://dargonlee.github.io/post/jie-jue-ding-shi-qi-de-xun-huan-yin-yong/</id>
        <link href="https://dargonlee.github.io/post/jie-jue-ding-shi-qi-de-xun-huan-yin-yong/">
        </link>
        <updated>2019-11-15T02:40:51.000Z</updated>
        <summary type="html"><![CDATA[<p>一般使用定时器的方法，在控制器返回上级的时候。定时器都不会停止，会导致循环引用，控制器的<code>delloc</code>方法不会调用。<br>
以下两种方式就是为了解决，定时器在控制器返回上级的时候解决循环引用的问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一般使用定时器的方法，在控制器返回上级的时候。定时器都不会停止，会导致循环引用，控制器的<code>delloc</code>方法不会调用。<br>
以下两种方式就是为了解决，定时器在控制器返回上级的时候解决循环引用的问题。</p>
<!-- more --> 
<h5 id="在控制器中使用定时器常规的方法">在控制器中使用定时器常规的方法</h5>
<pre><code class="language-objectivec">@interface ViewController ()

@property (nonatomic,strong) NSTimer *timer;

@property (nonatomic,strong) CADisplayLink *link;

@end
</code></pre>
<pre><code class="language-objectivec">
- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    // Timer的使用
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTest) userInfo:nil repeats:YES];
    
    // CADisplayLink的使用
    self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(timerTest)];
    [self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
}

- (void)timerTest
{
    NSLog(@&quot;%s&quot;, __func__);
}
</code></pre>
<p>以上这种写法就是常规的写法，就是在一个控制器push到当前这个控制器的时候开启定时器。<br>
但是这种写法有问题，会产生循环引用问题，从而导致内存泄露。<br>
<code>ViewController</code> 引用 <code>timer定时器</code> <code>timer</code>的<code>target</code>又引用<code>ViewController</code> 而且三者都是使用 <code>storng</code>引用 这样在 <code>ViewController</code>返回上级的时候，不会调用<code>delloc</code>方法 从而导致循环引用。</p>
<h4 id="解决方法的思路">解决方法的思路：</h4>
<p>我们知道引起循环引用的问题是 <code>ViewController</code> <code>timer</code> <code>timer的target</code> 三者都是强引用导致的 我们只要在这个三个中间一个地方给设置<code>weak</code>引用 就不会产生循环引用了。<br>
思路就是 -&gt; 设置<code>timer</code>的<code>target</code>的时候不要直接设置 <code>ViewController</code> 而是设置一个 自定义的对象 比如 <code>TimerTarget</code> 然后由这个对象对控制器<code>弱引用</code>，本来由控制器的直接调用的定时方法，现在由 <code>TimerTarget</code> 对象对控制器进行转发。从而达到解决循环引用的问题。<br>
代码如下：</p>
<pre><code class="language-objectivec">
- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    
    self.link = [CADisplayLink displayLinkWithTarget:[TimerTarget proxyWithTarget:self] selector:@selector(timerTest)];
    
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[TimerTarget proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];
}

- (void)timerTest
{
    NSLog(@&quot;%s&quot;, __func__);
}
</code></pre>
<p><code>TimerTarget对象的方法实现</code></p>
<pre><code class="language-objc">@interface TimerTarget : NSObject

@property (nonatomic, weak) id target;
// 接收一个可以相应 定时器的对象
+ (instancetype)proxyWithTarget:(id)target;

@end


+ (instancetype)proxyWithTarget:(id)target
{
    TimerTarget *targets = [[TimerTarget alloc]init];
    targets.target = target;//然后对外部的对象进行弱引用
    return targets;
}
// 在定时器给当前对象发送方法的时候 会走当前对象的消息转发机制 
// 然后可以在这个方法里面对弱应用的对象去响应要调用的方法
- (id)forwardingTargetForSelector:(SEL)aSelector
{
    return self.target;
}
</code></pre>
<blockquote>
<p>上面的方法可以解决问题，但是这样效率不够高。因为在 <code>TimerTarget</code> 在做消息转发之前，会对父类方法查找和方法缓存中去找方法。这样效率不高。</p>
</blockquote>
<p>下面介绍一个苹果提供专门进行消息转发的类叫<code>NSProxy</code> 上面的解决方法我们是继承<code>NSObject</code> 下面我们可以直接继承这个类<br>
代码如下：</p>
<pre><code class="language-objectivec">@interface TimerProxy : NSProxy

@property (nonatomic, weak) id target;

+ (instancetype)proxyWithTarget:(id)target;

@end



+ (instancetype)proxyWithTarget:(id)target
{
    // NSProxy 不需要init方法
    TimerProxy *targets = [TimerProxy alloc];
    targets.target = target;
    return targets;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel
{
    return [self.target methodSignatureForSelector:sel];
}

- (void)forwardInvocation:(NSInvocation *)invocation
{
    [invocation invokeWithTarget:self.target];
}
</code></pre>
<p>这样的话 在定时的方法来的时候可以直接进行转发，而不会再去父类找了。</p>
<h4 id="补充">补充</h4>
<pre><code class="language-objectivec">__weak typeof(self) weakSelf = self;
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
        [weakSelf timerTest];
    }];
</code></pre>
<p>这种block的方法也可以解决循环引用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NSLayoutAnchor实践]]></title>
        <id>https://dargonlee.github.io/post/nslayoutanchor-shi-jian/</id>
        <link href="https://dargonlee.github.io/post/nslayoutanchor-shi-jian/">
        </link>
        <updated>2019-11-14T06:37:44.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>iOS如果项目中不用xib或者storyboard的话，给view做约束一般都是用第三方库<code>Masonry</code>，为什么不用系统提供的AutoLayout呢？<code>因为代码太多不好用</code></p>
</blockquote>
<ul>
<li>今天给大家介绍一个苹果iOS9后更新的一个布局的好用的类 <code>NSLayoutAnchor</code></li>
</ul>
<h4 id="分别用-nslayoutconstraint-nslayoutanchor-和-masonry来进行如下图所示的布局">分别用 <code>NSLayoutConstraint</code> <code>NSLayoutAnchor</code> 和 <code>Masonry</code>来进行如下图所示的布局</h4>
<blockquote>
<p>在进行布局的时候，我会分别讲解下系统 <code>NSLayoutConstraint</code> <code>NSLayoutAnchor</code>两种布局的方法使用和参数说明<br>
至于<code>Masonry</code>的使用 我就不做多介绍了（官方介绍的很清楚，网上资料也不少）</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>iOS如果项目中不用xib或者storyboard的话，给view做约束一般都是用第三方库<code>Masonry</code>，为什么不用系统提供的AutoLayout呢？<code>因为代码太多不好用</code></p>
</blockquote>
<ul>
<li>今天给大家介绍一个苹果iOS9后更新的一个布局的好用的类 <code>NSLayoutAnchor</code></li>
</ul>
<h4 id="分别用-nslayoutconstraint-nslayoutanchor-和-masonry来进行如下图所示的布局">分别用 <code>NSLayoutConstraint</code> <code>NSLayoutAnchor</code> 和 <code>Masonry</code>来进行如下图所示的布局</h4>
<blockquote>
<p>在进行布局的时候，我会分别讲解下系统 <code>NSLayoutConstraint</code> <code>NSLayoutAnchor</code>两种布局的方法使用和参数说明<br>
至于<code>Masonry</code>的使用 我就不做多介绍了（官方介绍的很清楚，网上资料也不少）</p>
</blockquote>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/646265-8b480a3ee6085ef6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190509-105625@2x.png" loading="lazy"></figure>
<h3 id="第一种-nslayoutconstraint">第一种 <code>NSLayoutConstraint</code></h3>
<pre><code class="language-objectivec"># NSLayoutConstraint 的核心布局方法
[NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];

</code></pre>
<p>上面代码的白话文就是<br>
<code>红色view 的 centerX 等于 self.view 的 centerX 1.0倍 加 0</code><br>
如果还不是很明白的话 看下图就一目了然了</p>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/646265-b155f2e0c3eaa558.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20190509-110720@2x.png" loading="lazy"></figure>
<h4 id="接下来我们来讲一下初始化方法中各个参数的意义">接下来我们来讲一下初始化方法中各个参数的意义：</h4>
<pre><code class="language-objectivec">item:        要布局的view

attribute: 是一个NSLayoutAttribute枚举，可以看到他的枚举值有 left、right、bottom、top 等

relatedBy:  是一个NSLayoutRelation枚举，他的枚举值有 lessThanOrEqual（小于等于）、equal（等于）、greaterThanOrEqual（大于等于）， 指定 view1和接下来那个参数 view2两个视图之
间的约束关系的

toItem:     第一个view的参照view 你要参照哪个view 这个就是哪个view（本例中的是self.view控制器view）

attribute:  和第二个参数一样，是来表示第一个视图对第二个视图的
参考位置 ，上下左右 还是 center等

multiplier: 是来计算两个视图之间约束的倍数关系

constant:  是来计算两个视图之间约束的倍数关系的基础上再加一些常量

</code></pre>
<h4 id="下面看约束代码">下面看约束代码</h4>
<pre><code class="language-objectivec">// 布局redView
    NSLayoutConstraint *centerX = [NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];
    NSLayoutConstraint *top = [NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeTopMargin multiplier:1.0 constant:10];
    
    NSLayoutConstraint *width = [NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:200];
    NSLayoutConstraint *heith = [NSLayoutConstraint constraintWithItem:self.redView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:200];
    
    //可以单个添加约束
    [self.view addConstraint:centerX];
    [self.view addConstraint:top];
    
    //也可以添加约束多个约束
    [self.redView addConstraints:@[width, heith]];
    
    
    
    // 布局blueView
    NSLayoutConstraint *centerX1 = [NSLayoutConstraint constraintWithItem:self.blueView attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.redView attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];
    NSLayoutConstraint *top1 = [NSLayoutConstraint constraintWithItem:self.blueView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self.redView attribute:NSLayoutAttributeBottom multiplier:1.0 constant:20];
    
    NSLayoutConstraint *width1 = [NSLayoutConstraint constraintWithItem:self.blueView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:self.redView attribute:NSLayoutAttributeWidth multiplier:1.5 constant:0];
    NSLayoutConstraint *heith1 = [NSLayoutConstraint constraintWithItem:self.blueView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:self.redView attribute:NSLayoutAttributeWidth multiplier:1.5 constant:0];
    
    //iOS8 以后 NSLayoutConstraint 的类方法 也可以把约束添加到视图上，而且省掉了判断添加到那个视图上的问题，避免了上面例子中因为视图添加错误而导致的崩溃
    [NSLayoutConstraint activateConstraints:@[centerX1,top1, width1, heith1]];
</code></pre>
<h5 id="nslayoutconstraint添加约束注意事项"><code>NSLayoutConstraint</code>添加约束注意事项</h5>
<p>1.如果两个视图（也就是参数 item 和 toItem）是父子关系，设置子控件的约束，约束添加到父控件上<br>
2.如果两个视图（也就是参数 item 和 toItem）是兄弟关系，设置两兄弟的约束，约束会添加到第一个共同的父控件上<br>
3.如果两个视图（也就是参数 item 和 toItem）是同一个视图，约束会添加到自己上(一般给自己添加约束toItem为nil attribute为NSLayoutAttributeNotAnAttribute)<br>
4.要给添加约束的view要设置<code>translatesAutoresizingMaskIntoConstraints</code>为NO 否则约束不生效</p>
<pre><code class="language-objectivec">    UIView *redView = [[UIView alloc]init];
    redView.backgroundColor = [UIColor redColor];
    // 要禁止 autoresize 意思就是遵循autoLayout抛弃原有设置的高度宽度等
    // 使用autolayout的视图必须要设置该属性
    redView.translatesAutoresizingMaskIntoConstraints = NO;
</code></pre>
<h3 id="第二种-nslayoutanchor-ios9以后">第二种 <code>NSLayoutAnchor</code> ios9以后</h3>
<pre><code class="language-objectivec">- (NSLayoutConstraint *)constraintEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;
- (NSLayoutConstraint *)constraintGreaterThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;
- (NSLayoutConstraint *)constraintLessThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;

/* These methods return an inactive constraint of the form thisAnchor = otherAnchor + constant.
 */
- (NSLayoutConstraint *)constraintEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c;
- (NSLayoutConstraint *)constraintGreaterThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c;
- (NSLayoutConstraint *)constraintLessThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c;

</code></pre>
<h4 id="接下来我们来讲一下使用方法">接下来我们来讲一下使用方法</h4>
<p>比如要给redView设置一个约束，如下</p>
<pre><code class="language-objectivec">[self.redView.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor];
</code></pre>
<p>上面代码的意思为 <code>红色的view的centerX和self.view的centerX相等</code></p>
<h4 id="下面看使用nslayoutanchor写的约束代码">下面看使用<code>NSLayoutAnchor</code>写的约束代码</h4>
<pre><code class="language-objectivec">    [self.redView.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor].active = YES;
    [self.redView.topAnchor constraintEqualToAnchor:self.view.safeAreaLayoutGuide.topAnchor constant:20].active = YES;
    [self.redView.widthAnchor constraintEqualToConstant:200].active = YES;
    [self.redView.heightAnchor constraintEqualToConstant:200].active = YES;
    
    [self.blueView.centerXAnchor constraintEqualToAnchor:self.redView.centerXAnchor].active = YES;
    [self.blueView.topAnchor constraintEqualToAnchor:self.redView.bottomAnchor constant:20].active = YES;
    [self.blueView.widthAnchor constraintEqualToAnchor:self.redView.widthAnchor multiplier:1.5].active = YES;
    [self.blueView.heightAnchor constraintEqualToAnchor:self.redView.heightAnchor multiplier:1.5].active = YES;
</code></pre>
<h5 id="nslayoutanchor添加约束注意事项"><code>NSLayoutAnchor</code>添加约束注意事项</h5>
<p>1.要给添加约束的view要设置<code>translatesAutoresizingMaskIntoConstraints</code>为NO 否则约束不生效 <code>自定义view的时候也要给子view设置此属性，总之你要给哪个view设置Layout就要给哪个view设置此属性为NO</code><br>
2.<code>active</code>要设置为YES 这个是控制约束是否真正添加的开关 设置为NO的时候 约束失效</p>
<h3 id="第三种-masonry">第三种 <code>Masonry</code></h3>
<h4 id="直接上代码了">直接上代码了</h4>
<pre><code class="language-objectivec">    [self.redView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.top.equalTo(self.view.mas_topMargin).with.offset(20);
        make.centerX.equalTo(self.view.mas_centerX);
        make.width.height.equalTo(@200);
    }];
    
    [self.blueView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.top.equalTo(self.redView.mas_bottom).offset(20);
        make.centerX.equalTo(self.redView.mas_centerX);
        make.width.height.equalTo(self.redView).multipliedBy(1.5);
    }];
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter 常用布局]]></title>
        <id>https://dargonlee.github.io/post/flutter-chang-yong-bu-ju/</id>
        <link href="https://dargonlee.github.io/post/flutter-chang-yong-bu-ju/">
        </link>
        <updated>2019-09-17T06:33:37.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="行布局-在x轴上">行布局 （在X轴上）</h4>
<blockquote>
<p>Row.mainAxisAlignment 主轴排列方式</p>
</blockquote>
<pre><code class="language-objectivec">Row(
  mainAxisAlignment: MainAxisAlignment.spaceAround,  // 改变这个值 可以更改排列方式 如下图
  mainAxisSize: MainAxisSize.max,
  children: [
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
], )
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/646265-2fc1ab8a4b7f57a4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="row.jpg" loading="lazy"></figure>
]]></summary>
        <content type="html"><![CDATA[<h4 id="行布局-在x轴上">行布局 （在X轴上）</h4>
<blockquote>
<p>Row.mainAxisAlignment 主轴排列方式</p>
</blockquote>
<pre><code class="language-objectivec">Row(
  mainAxisAlignment: MainAxisAlignment.spaceAround,  // 改变这个值 可以更改排列方式 如下图
  mainAxisSize: MainAxisSize.max,
  children: [
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
], )
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/646265-2fc1ab8a4b7f57a4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="row.jpg" loading="lazy"></figure>
<!-- more -->
<blockquote>
<p>Row.crossAxisAlignment 纵轴排列方式</p>
</blockquote>
<pre><code class="language-objectivec">Row(
  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
  crossAxisAlignment: CrossAxisAlignment.start,  // 改变这个值 可以更改排列方式 如下图
  children: [
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 100.0),
    Icon(Icons.stars, size: 50.0),
], )
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/646265-90a2530f54792a81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="列布局在y轴上">列布局（在Y轴上）</h4>
<blockquote>
<p>Column.mainAxisAlignment 列布局 主轴排列方式</p>
</blockquote>
<pre><code class="language-objectivec">Column(
  mainAxisAlignment: MainAxisAlignment.start, // 改变这个值 可以更改排列方式 如下图
  mainAxisSize: MainAxisSize.max,
  children: [
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 50.0),
], )
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://upload-images.jianshu.io/upload_images/646265-ef8cbc570e2abf84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<blockquote>
<p>Column.mainAxisAlignment 列布局 纵轴排列方式</p>
</blockquote>
<pre><code class="language-objectivec">Column(
  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
  crossAxisAlignment: CrossAxisAlignment.start, // 改变这个值 可以更改排列方式 如下图
  children: [
    Icon(Icons.stars, size: 50.0),
    Icon(Icons.stars, size: 100.0),
    Icon(Icons.stars, size: 50.0),
], )
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://upload-images.jianshu.io/upload_images/646265-d03f1a32a2a66c41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="stack布局允许子widget堆叠可以叠加布局view也就是在-z-轴上">Stack布局（允许子widget堆叠，可以叠加布局View，也就是在 Z 轴上）</h4>
<blockquote>
<p>Stack.alignment</p>
</blockquote>
<pre><code class="language-objectivec">Stack(
  alignment: AlignmentDirectional.topStart, //改变这个值 可以更改排列方式 如下面两张图
  children:[
    SizedBox(
      width: 300.0,
      height: 300.0,
      child: Container(color: Colors.green),
), SizedBox(
      width: 200.0,
      height: 200.0,
      child: Container(color: Colors.yellow),
), SizedBox(
      width: 100.0,
      height: 100.0,
      child: Container(color: Colors.red),
), ],
)
```objectivec
![image.png](https://upload-images.jianshu.io/upload_images/646265-6ea3906a2a13098f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/646265-9e0c8ba13561b3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### Positioned布局
&gt; Stack允许子widget堆叠，而Positioned可以给子widget定位 `根据Stack的四个角`
```objectivec
Stack(
  children: [
    SizedBox(
      width: 300.0,
      height: 300.0,
      child: Container(color: Colors.green),
    ),
    Positioned( // 这里的位置都是相对于 上面的SizeBox的位置的
      left: 20.0, 
      top: 20.0,
      width: 100.0,
      height: 100.0,
      child: Container(color: Colors.indigo),
    ),
    Positioned( // 这里的位置都是相对于 上面的SizeBox的位置的
      bottom: 20.0,
      right: 20.0,
      width: 100.0,
      height: 100.0,
      child: Container(color: Colors.black87),
), ],
)
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://upload-images.jianshu.io/upload_images/646265-32432b7a3de5aa7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="expanded布局">Expanded布局</h4>
<blockquote>
<p>Expanded组件可以使Row、Column、Flex等子组件在其主轴方向上展开并填充可用空间(例如，Row在水平方向，Column在垂直方向)。如果多个子组件展开，可用空间会被其flex factor(表示扩展的速度、比例)分割。</p>
</blockquote>
<pre><code class="language-objectivec">Row(
      crossAxisAlignment: CrossAxisAlignment.stretch,
          children: &lt;Widget&gt;[
            Expanded(
              flex: 1, //组件占据剩余空间的比例
              child: Container(
                color: Colors.yellow,
                child: Center(child: Text('flex: 1'),),
              ),
            ),
            Expanded(
              flex: 2,
              child: Container(
                color: Colors.orange,
                child: Center(child: Text('flex: 2'),),
              ),
            ),
            Expanded(
              flex: 3,
              child: Container(
                color: Colors.cyan,
                child: Center(child: Text('flex: 3'),),
              ),
            )
          ],
        ),
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://upload-images.jianshu.io/upload_images/646265-072a28dbc18077cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<h4 id="expanded-padding-sizedbox">Expanded + Padding + SizedBox</h4>
<blockquote>
<p>如何用 <code>padding</code> 和 <code>SizeBox</code> 给内容之间添加间隙</p>
</blockquote>
<pre><code class="language-objectivec">Container(
        height: 200.0,
        color: Colors.yellow,
        padding: EdgeInsets.all(16.0),
        child: Row(
          children: &lt;Widget&gt;[
            Expanded(
              flex: 1,
              child: Container(
                color: Colors.green,
                child: Center(child: Text('flex: 1'),),
              ),
            ),
            SizedBox(width: 40.0,),
            Expanded(
              flex: 2,
              child: Container(
                color: Colors.orange,
                child: Center(child: Text('flex: 2'),),
              ),
            )
          ],
        ),
      ),
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://upload-images.jianshu.io/upload_images/646265-105875d9a122bce3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git的常用命令]]></title>
        <id>https://dargonlee.github.io/post/git-de-chang-yong-ming-ling/</id>
        <link href="https://dargonlee.github.io/post/git-de-chang-yong-ming-ling/">
        </link>
        <updated>2019-08-12T05:38:57.000Z</updated>
        <summary type="html"><![CDATA[<pre><code class="language-bash"># 显示当前的Git配置
$ git config --list

# 查看仓库配置
git config --local -l 

# 查看用户配置
git config --global -l 

# 查看系统配置
git config --system -l </code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code class="language-bash"># 显示当前的Git配置
$ git config --list

# 查看仓库配置
git config --local -l 

# 查看用户配置
git config --global -l 

# 查看系统配置
git config --system -l 

&lt;!-- more --&gt;

# 编辑Git配置文件

git config --local -e 编辑仓库级别配置文件
git config --global -e 编辑用户级别配置文件
git config --system -e 编辑系统级别配置文件

# 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;
</code></pre>
<p>推送操作 切记直接使用 <code>git push</code></p>
<pre><code class="language-bash">git push origin HEAD:refs/for/develop  
</code></pre>
<p>创建并切换到dev分支（本地分支）</p>
<pre><code class="language-bash">git checkout -b dev
</code></pre>
<p>删除本地dev分支(本地)</p>
<pre><code class="language-bash">git branch -d dev
</code></pre>
<p>分支合并</p>
<pre><code class="language-scheme">git checkout master
git merge dev
</code></pre>
<p>推送本地分支到远程</p>
<pre><code class="language-bash">git push -u origin develop
</code></pre>
<p>查看分支：</p>
<pre><code class="language-bash">git branch
</code></pre>
<p>创建分支：</p>
<pre><code class="language-bash">git branch 
</code></pre>
<p>切换分支：</p>
<pre><code class="language-bash">git checkout `或者`git switch `
</code></pre>
<p>删除远程分支：</p>
<pre><code class="language-bash"> git push origin --delete 
</code></pre>
<p>打tag</p>
<pre><code class="language-bash">git tag 
</code></pre>
<p>删除本地tag</p>
<pre><code class="language-bash">git tag -d 
</code></pre>
<p>删除远程tag</p>
<pre><code class="language-bash">git push origin --delete tag 
</code></pre>
<p>推送到哪个分支</p>
<pre><code class="language-bash">git push origin HEAD:refs/for/branch
</code></pre>
<p>回退相关操作</p>
<pre><code class="language-bash">git reset --hard HEAD^ // 回退pull操作

git reset --mixed HEAD^ // 回退commit 只退一步

git reset --hard 139dcfaa558e3276b30b6b2e5cbbb9c00bbdca96 // 回退到某一个版本
git reset --soft HEAD^//该命令会将工作去的文件回退到目标版本，但是不会改变暂存区的状态。

--hard 会清空工作目录和暂存区的改动,而 --soft则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区
</code></pre>
<p>执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</p>
<pre><code class="language-bash">git stash save &quot;save message&quot; :
</code></pre>
<p>查看stash了哪些存储</p>
<pre><code class="language-bash">git stash list
</code></pre>
<p>显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}</p>
<pre><code class="language-scheme">git stash show
</code></pre>
<p>显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p</p>
<pre><code class="language-bash">git stash show -p
</code></pre>
<p>应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1}</p>
<pre><code class="language-bash">git stash apply
</code></pre>
<p>命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}</p>
<pre><code class="language-bash">git stash pop
</code></pre>
<p>从列表中删除这个存储</p>
<pre><code class="language-bash">git stash drop stash@{$num} ：丢弃stash@{$num}存储
</code></pre>
<p>删除所有缓存的stash</p>
<pre><code class="language-bash">git stash clear
</code></pre>
<p>代码提交</p>
<pre><code class="language-bash"># 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
</code></pre>
<p>分支</p>
<pre><code class="language-bash"># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre>
<p>查看信息</p>
<pre><code class="language-bash"># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
</code></pre>
<p>远程同步</p>
<pre><code class="language-bash"># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
</code></pre>
<p>撤销</p>
<pre><code class="language-bash"># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
</code></pre>
<p>撤销本地提交</p>
<blockquote>
<p>HEAD^的意思是上一个版本，也可以写成HEAD~1<br>
如果你进行了2次commit，想都撤回，可以使用HEAD~2</p>
</blockquote>
<p>至于这几个参数：</p>
<pre><code class="language-bash">--mixed 
意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作
这个为默认参数,git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的
</code></pre>
<pre><code class="language-bash">--soft  
不删除工作空间改动代码，撤销commit，不撤销git add . 
</code></pre>
<pre><code class="language-bash">--hard
删除工作空间改动代码，撤销commit，撤销git add . 
注意完成这个操作后，就恢复到了上一次的commit状态。
</code></pre>
<pre><code class="language-bash">顺便说一下，如果commit注释写错了，只是想改一下注释，只需要：
git commit --amend
此时会进入默认vim编辑器，修改注释完毕后保存就好了
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS布局]]></title>
        <id>https://dargonlee.github.io/post/css-bu-ju/</id>
        <link href="https://dargonlee.github.io/post/css-bu-ju/">
        </link>
        <updated>2019-07-09T05:36:06.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="position">position</h1>
<blockquote>
<p>为了制作更多复杂的布局，我们需要讨论下<code>position</code>属性。它有一大堆的值，名字还都特抽象，别提有多难记了。让我们先一个个的过一遍，不过你最好还是把这页放到书签里。</p>
</blockquote>
<ul>
<li><code>static</code>元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分；行内元素则会创建一个或多个行框，置于其父元素中。</li>
</ul>
<pre><code class="language-css">.static {
    position: static;
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="position">position</h1>
<blockquote>
<p>为了制作更多复杂的布局，我们需要讨论下<code>position</code>属性。它有一大堆的值，名字还都特抽象，别提有多难记了。让我们先一个个的过一遍，不过你最好还是把这页放到书签里。</p>
</blockquote>
<ul>
<li><code>static</code>元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分；行内元素则会创建一个或多个行框，置于其父元素中。</li>
</ul>
<pre><code class="language-css">.static {
    position: static;
}
</code></pre>
<!--more-->
<p><code>static</code>是默认值。任意<code>position: static;</code>的元素不会被特殊的定位。一个 static 元素表示它<em>不会被“positioned”</em>，一个 position 属性被设置为其他值的元素表示它<em>会被“positioned”</em>。</p>
<ul>
<li><code>relative</code>元素框相对于之前正常文档流中的位置发生偏移，并且原先的位置仍然被占据。发生偏移的时候，可能会覆盖其他元素。</li>
</ul>
<pre><code class="language-css">.relative1 {
  position: relative;
}

.relative2 {
  position: relative;
  top: -20px;
  left: 20px;
  background-color: white;
  width: 500px;
}
</code></pre>
<blockquote>
<p>relative1 的表现和static一样，除非你添加了一些额外的属性</p>
<p>在一个相对定位（position属性的值为relative）的元素上设置<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙</p>
</blockquote>
<p><code>absolute</code>元素框不再占有文档流位置，并且相对于包含块进行偏移(所谓的包含块就是最近一级外层元素position不为static的元素)</p>
<p><code>absolute</code>与<code>fixed</code>的表现类似，但是它不是相对于视窗而是相对于<em>最近的“positioned”祖先元素</em>。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。记住一个“positioned”元素是指 position 值不是<code>static</code>的元素。</p>
<pre><code class="language-css">.relative { // 父元素
  position: relative; 
  width: 600px;
  height: 400px;
}
.absolute { // 子元素
  position: absolute;
  top: 120px;
  right: 0;
  width: 300px;
  height: 200px;
}
</code></pre>
<blockquote>
<p>子元素是相对定位的。如果它的父元素是<code>position: static;</code>，子元素会跳过父元素直接相对于body元素定位。</p>
<p>换句话说就是 子元素要想使用  `absolute 进行绝对定位 那么它相对的那个元素postition必须relative，如果父元素没有relative的话 子元素会相对本身最近的一个有relative属性的元素进行定位</p>
</blockquote>
<p><code>fixed</code>元素框不再占有文档流位置，并且相对于视窗进行定位</p>
<pre><code class="language-css">&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;
.footer {
  position: fixed;
  bottom: 0;
  left: 0;
  height: 70px;
  background-color: white;
  width: 100%;
}
</code></pre>
<p><code>sticky</code>(这是css3新增的属性值)粘性定位，官方的介绍比较简单，或许你不能理解。其实，它就相当于relative和fixed混合。最初会被当作是relative，相对于原来的位置进行偏移；一旦超过一定阈值之后，会被当成fixed定位，相对于视口进行定位</p>
<blockquote>
<p>相对于body定位并且是悬浮的</p>
</blockquote>
<ul>
<li><code>floate</code></li>
</ul>
<blockquote>
<p>另一个布局中常用的CSS属性是<code>float</code>。Float 可用于实现文字环绕图片</p>
</blockquote>
<pre><code class="language-css">img {
  float: right;
  margin: 0 0 1em 1em;
}
</code></pre>
<ul>
<li><code>clear</code></li>
</ul>
<blockquote>
<p><code>clear</code>属性被用于控制浮动。比较下面两个例子：</p>
</blockquote>
<pre><code class="language-html">&lt;div class=&quot;box&quot;&gt;...&lt;/div&gt;
&lt;section&gt;...&lt;/section&gt;
</code></pre>
<pre><code class="language-css">.box {
  float: left;
  width: 200px;
  height: 100px;
  margin: 1em;
}
在这个例子中， section 元素实际上是在 div 之后的（译注：DOM结构上）。然而 div 元素是浮动到左边的，于是 section 中的文字就围绕了 div ，并且 section 元素包围了整个元素。如果我们想让 section 显示在浮动元素之后呢？
</code></pre>
<pre><code class="language-css">.box {
  float: left;
  width: 200px;
  height: 100px;
  margin: 1em;
}
.after-box {
  clear: left;
}
使用 clear 我们就可以将这个段落移动到浮动元素 div 下面。你需要用 left 值才能清除元素的向左浮动。你还可以用 right 或 both 来清除向右浮动或同时清除向左向右浮动。
</code></pre>
<p>清除浮动</p>
<pre><code class="language-css">img {
  float: right;
}

.clearfix { //清除浮动
  overflow: auto;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS-给UILabel增加复制粘贴功能]]></title>
        <id>https://dargonlee.github.io/post/ios-gei-uilabel-zeng-jia-fu-zhi-nian-tie-gong-neng/</id>
        <link href="https://dargonlee.github.io/post/ios-gei-uilabel-zeng-jia-fu-zhi-nian-tie-gong-neng/">
        </link>
        <updated>2019-06-11T05:37:07.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="第一步">第一步</h2>
<pre><code class="language-objectivec">//让label有资格成为第一响应者
- (BOOL)becomeFirstResponder
{
    return YES;
}

//label能执行哪些操作(比如 拷贝 等)
- (BOOL)canPerformAction:(SEL)action withSender:(id)sender
{
    if (action == @selector(copy:) || action == @selector(paste:) || action == @selector(cut:)) return YES;
    return NO;
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="第一步">第一步</h2>
<pre><code class="language-objectivec">//让label有资格成为第一响应者
- (BOOL)becomeFirstResponder
{
    return YES;
}

//label能执行哪些操作(比如 拷贝 等)
- (BOOL)canPerformAction:(SEL)action withSender:(id)sender
{
    if (action == @selector(copy:) || action == @selector(paste:) || action == @selector(cut:)) return YES;
    return NO;
}
</code></pre>
<!--more-->
<h2 id="第二步">第二步</h2>
<pre><code class="language-objectivec">
- (void)copy:(UIMenuController *)menu
{
    //将自己的文字赋值到粘贴板
    [self copy:menu];
    //清空文字
    self.text = nil;
}

- (void)paste:(UIMenuController *)menu
{
    //将自己的文字赋值到粘贴板
    UIPasteboard * board = [UIPasteboard generalPasteboard];
    board.string = self.text;
}

- (void)cut:(UIMenuController *)menu
{
    UIPasteboard * board = [UIPasteboard generalPasteboard];
    self.text = board.string;
}
</code></pre>
<h2 id="第三步">第三步</h2>
<pre><code class="language-objectivec">- (void)awakeFromNib
{
    [self setup];
    [super awakeFromNib];
}

- (instancetype)initWithFrame:(CGRect)frame
{
    if (self == [super initWithFrame:frame]) {
        [self setup];
    }
    return self;
}

- (void)setup
{
    self.userInteractionEnabled = YES;

    [self addGestureRecognizer:[[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(labelClick)]];
}
</code></pre>
<p>显示menu</p>
<pre><code class="language-objectivec">- (void)labelClick
{
    //1.让label成为第一响应者(这里的self是UILabel)
    [self becomeFirstResponder];

    //2.显示menuController
    UIMenuController * menu = [UIMenuController sharedMenuController];
//    [menu setTargetRect:self.frame inView:self.superview];
    [menu setTargetRect:self.bounds inView:self];
    [menu setMenuVisible:YES animated:YES];

    NSLog(@&quot;%s&quot;,__func__);
}
</code></pre>
<h1 id="over">OVER</h1>
<p>如果你想自定义的话可以写下面方法(相应的实现方法需要再控制器里面实现不然用不了)</p>
<pre><code class="language-objectivec">UIMenuController * menu = [UIMenuController sharedMenuController];
UIMenuItem * reply = [[UIMenuItem alloc]initWithTitle:@&quot;回复&quot; action:@selector(replay:)];
UIMenuItem * ding = [[UIMenuItem alloc]initWithTitle:@&quot;顶&quot; action:@selector(ding:)];
UIMenuItem * report = [[UIMenuItem alloc]initWithTitle:@&quot;举报&quot; action:@selector(report:)];
menu.menuItems = @[reply,ding,report];
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[修改iOS返回按钮的几种方式]]></title>
        <id>https://dargonlee.github.io/post/xiu-gai-ios-fan-hui-an-niu-de-ji-chong-fang-shi/</id>
        <link href="https://dargonlee.github.io/post/xiu-gai-ios-fan-hui-an-niu-de-ji-chong-fang-shi/">
        </link>
        <updated>2019-02-13T02:43:05.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="第一种">第一种</h3>
<pre><code class="language-objectivec">UIImage *backButtonImage = [[UIImage imageNamed:@&quot;back&quot;] resizableImageWithCapInsets:UIEdgeInsetsMake(0, 25, 0, 0)];

[[UIBarButtonItem appearance] setBackButtonBackgroundImage:backButtonImage forState:UIControlStateNormal barMetrics:UIBarMetricsDefault];

[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(NSIntegerMin, NSIntegerMin) forBarMetrics:UIBarMetricsDefault];
</code></pre>
<blockquote>
<p>提示:上面这种方法会被系统给拉伸,需要在当前控制器里面设置</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="第一种">第一种</h3>
<pre><code class="language-objectivec">UIImage *backButtonImage = [[UIImage imageNamed:@&quot;back&quot;] resizableImageWithCapInsets:UIEdgeInsetsMake(0, 25, 0, 0)];

[[UIBarButtonItem appearance] setBackButtonBackgroundImage:backButtonImage forState:UIControlStateNormal barMetrics:UIBarMetricsDefault];

[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(NSIntegerMin, NSIntegerMin) forBarMetrics:UIBarMetricsDefault];
</code></pre>
<blockquote>
<p>提示:上面这种方法会被系统给拉伸,需要在当前控制器里面设置</p>
</blockquote>
<!--more-->
<h3 id="第二种">第二种</h3>
<pre><code class="language-objectivec">UIBarButtonItem *backItem = [[UIBarButtonItem alloc] init];
backItem.title = @&quot;&quot;;
//主要是以下两个图片设置
self.navigationController.navigationBar.backIndicatorImage = [UIImage imageNamed:@&quot;backPic&quot;];
self.navigationController.navigationBar.backIndicatorTransitionMaskImage = [UIImage imageNamed:@&quot;backPic&quot;];        
self.navigationItem.backBarButtonItem = backItem;
</code></pre>
<blockquote>
<p>提示: 这种方法在父类方法中设置好使</p>
</blockquote>
<h3 id="-以上两种方法都是在不改变系统手势滑动返回的情况下的">- 以上两种方法都是在不改变系统手势滑动返回的情况下的</h3>
<h3 id="第三种">第三种</h3>
<pre><code class="language-objectivec">//创建一个UIButton
UIButton *backButton = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 40, 40)];
//设置UIButton的图像
[backButton setImage:[UIImage imageNamed:@&quot;left_select_img.png&quot;] forState:UIControlStateNormal];
//给UIButton绑定一个方法，在这个方法中进行popViewControllerAnimated
[backButton addTarget:self action:@selector(backItemClick) forControlEvents:UIControlEventTouchUpInside];
//然后通过系统给的自定义BarButtonItem的方法创建BarButtonItem
UIBarButtonItem *backItem = [[UIBarButtonItem alloc]initWithCustomView:backButton];
//覆盖返回按键
self.navigationItem.leftBarButtonItem = backItem;
</code></pre>
<blockquote>
<p>提示:这种方法会失去手势滑动返回的功能</p>
</blockquote>
<h3 id="第四种">第四种</h3>
<pre><code class="language-objectivec">//重新创建一个barButtonItem
UIBarButtonItem *backItem = [[UIBarButtonItem alloc]initWithTitle:@&quot;你想要设置的返回按钮文字&quot; style:UIBarButtonItemStylePlain target:nil action:nil];
//设置backBarButtonItem即可
self.navigationItem.backBarButtonItem = backItem;
</code></pre>
<blockquote>
<p>提示:上面这种方式只是修改返回文字而已 至于返回图标还是系统提供的 手势滑动返回依然存在</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS控制器View加载顺序详细版]]></title>
        <id>https://dargonlee.github.io/post/ios-kong-zhi-qi-view-jia-zai-shun-xu-xiang-xi-ban/</id>
        <link href="https://dargonlee.github.io/post/ios-kong-zhi-qi-view-jia-zai-shun-xu-xiang-xi-ban/">
        </link>
        <updated>2019-01-23T06:35:16.000Z</updated>
        <summary type="html"><![CDATA[<p><code>控制器声明周期</code></p>
<pre><code class="language-objectivec">//通过nib问价初始化触发
- (instancetype)initWithCoder:(NSCoder *)aDecoder

//nib文件被加载的时候，会发送一个消息到nib文件中的每一个对象
- (void)awakeFromNib

//开始加载视图控制器自带的view
- (void)loadView

//视图控制器的view被加载完成
- (void)viewDidLoad

//视图控制器的view将要显示在window上

- (void)viewWillAppear:(BOOL)animated

//视图控制器的view开始更新Autolayout
- (void)updateViewConstraints

//视图控制器的view开始更新内容视图的位置
- (void)viewWillLayoutSubviews

//视图控制器的view已经更新内容视图的位置
- (void)viewDidLayoutSubviews

//视图控制器的view已经显示到window上
- (void)viewDidAppear:(BOOL)animated

//视图控制的view将要从window上消失
- (void)viewWillDisappear:(BOOL)animated

//视图控制器的view已经从window上消失
- (void)viewDidDisappear:(BOOL)animated
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p><code>控制器声明周期</code></p>
<pre><code class="language-objectivec">//通过nib问价初始化触发
- (instancetype)initWithCoder:(NSCoder *)aDecoder

//nib文件被加载的时候，会发送一个消息到nib文件中的每一个对象
- (void)awakeFromNib

//开始加载视图控制器自带的view
- (void)loadView

//视图控制器的view被加载完成
- (void)viewDidLoad

//视图控制器的view将要显示在window上

- (void)viewWillAppear:(BOOL)animated

//视图控制器的view开始更新Autolayout
- (void)updateViewConstraints

//视图控制器的view开始更新内容视图的位置
- (void)viewWillLayoutSubviews

//视图控制器的view已经更新内容视图的位置
- (void)viewDidLayoutSubviews

//视图控制器的view已经显示到window上
- (void)viewDidAppear:(BOOL)animated

//视图控制的view将要从window上消失
- (void)viewWillDisappear:(BOOL)animated

//视图控制器的view已经从window上消失
- (void)viewDidDisappear:(BOOL)animated
</code></pre>
<!-- more -->
<p>加载过程:<br>
1 一般情况下调用 init方法或者调用initWithNibName方法实例化UIViewController, 不管调用哪个方法都为调用initWithNibName(方法定义如下)</p>
<ul>
<li>
<p><code>-(id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil</code></p>
</li>
<li>
<p>接着会调用loadView方法来生成UIViewController.view</p>
</li>
<li>
<p><code>- (void)loadView</code></p>
</li>
<li>
<p>下面来简单说下loadView底层</p>
<ul>
<li>
<p>判断下有没有指定storyboard，如果有，就去加载storyboard描述的控制器的view</p>
</li>
<li>
<p>判断下有没有指定nibName,如果有，就去加载nibName描述的控制器的view</p>
</li>
<li>
<p><code>- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil</code></p>
</li>
<li>
<p>如果判断有没有指定nibName,[self nibName]</p>
</li>
<li>
<p>判断下nibName是否为空，如果为空，他会尝试找下有没有跟控制器同名，但是不带Controller的xib</p>
</li>
<li>
<p>跟控制器同名的xib,nibName = ViewController,但是这一步有条件，前提条件你没有重写loadView</p>
</li>
<li>
<p>如果都没有找到，直接创建默认控制器的view</p>
</li>
</ul>
</li>
</ul>
<p><code>- (void)awakeFromNib;</code></p>
<ul>
<li>
<p>这个方法用的时候，outlet还没有连接起来，是view Controller刚从storyboard建的时候，没有完全建好，不过可能有一些事情要在这个方法里面完成，比如splitViewDelegate，需要在非常早期完成。然后调用 viewDidLoad方法<br>
<code>- (void)viewDidLoad</code></p>
</li>
<li>
<p>如果loadView不能生成UIViewController.view系统将会反复调用loadView及viewDidLoad方法, 并且最终调用[super loadView] 方法返回UIViewController.view<br>
然后依次调用如下2个方法, 这2个方法也十分重要, 在UINavigationController的POP操作后有时将要显示的UIViewController中的View并没有释放(也有可能释放掉) , UIViewController将不会调用上面的三个方法(initWithNibName,loadView,viewDidLoad) 而会调用下面这2个方法</p>
</li>
<li>
<p><code>- (void)viewWillAppear:(BOOL)animated;</code></p>
</li>
<li>
<p><code>- (void)viewDidAppear:(BOOL)animated;</code><br>
紧接着调用下面两个方法view中frame值布局，使子控制器的frame值更加准确</p>
</li>
<li>
<p><code>- (void)viewWillLayoutSubviews</code></p>
</li>
<li>
<p><code>-(void)viewDidLayoutSubviews</code></p>
</li>
<li>
<p>页面消失的方法</p>
</li>
</ul>
<p><code>- (void)viewWillDisappear:(BOOL)animated;</code><br>
<code>- (void)viewDidDisappear:(BOOL)animated;</code><br>
<code>- (void)viewWillUnload;</code>//iOS5.0添加- (void)viewDidUnload;<br>
<code>- (void)dealloc；</code></p>
<ul>
<li>
<p>控制器View一些方法的区分</p>
<ul>
<li>viewDidLoad其实没什么可混淆的,无论通过什么途径加载(Xcode或者IB,这里的加载属于实例化)完view后肯定会执行这个方法.</li>
<li><code>- loadView</code>需要分两种情况.
<ul>
<li>当你通过Xcode实例化一个类的时候就需要自己在controller中实现这个方法.</li>
<li>而在IB中实例化就不需要实现它.</li>
<li><code>- initWithNibName</code>这个方法是在controller的类在IB中创建,但是通过Xcode实例化controller的时候用的.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>awakeFromNib这个方法是一个类在IB中被实例化是被调用的.</p>
</li>
<li>
<p>看了帖子发现大家都推荐使用viewDidLoad而不要使用awakeFromNib,应为viewDidLoad会被多次调用,</p>
</li>
<li>
<p>而awakeFromNib只会当从nib文件中unarchive的时候才会被调用一次.</p>
</li>
<li>
<p>实际测试中发现,当一个类的awakeFromNib被调用的时候,那么这个类的viewDidLoad就不会被调用了,这个感觉很奇怪.</p>
</li>
<li>
<p><code>- initWithCoder</code>是一个类在IB中创建但在Xcode中被实例化时被调用的.</p>
</li>
<li>
<p>比如,通过IB创建一个controller的nib文件,然后在xocde中通过initWithNibName来实例化这个controller,那么这个controller的initWithCoder会被调用.</p>
</li>
<li>
<p><code>- awakeFromNib</code> 当.nib文件被加载的时候，会发送一个awakeFromNib的消息到.nib文件中的每个对象，每个对象都可以定义自己的awakeFromNib函数来响应这个消息，执行一些必要的操作。也就是说通过nib文件创建view对象是执行awakeFromNib</p>
</li>
</ul>
<p>viewDidLoad 当view对象被加载到内存是就会执行viewDidLoad，所以不管通过nib文件还是代码的方式创建对象都会执行viewDidLoad</p>
]]></content>
    </entry>
</feed>